@node using
@chapter Using @value{PRJNAME}


Once @value{PACKAGE} is properly installed, we can invoke it either in
an interactive terminal session or as the interpreter for invoking a
script.

@cindex Command line
@cindex Invoking @value{PRJNAME}

@menu
* using interactive::           Interactive sessions.
* using invoking::              Command line arguments.
* using scripts::               Executing Scheme scripts.
* using libraries::             @rnrs{6} libraries and extensions.
* using programs::              Compiling Scheme programs.
* using rlwrap::                Using @command{rlwrap}.
* using binfmt::                Launching programs on Linux.
@end menu

@c page
@node using interactive
@section Interactive sessions


If we want an interactive session, use a bare @value{EXECUTABLE}
command, with no options.

@example
$ @value{RAWEXECUTABLE}
Vicare Scheme version 0.3d0
Revision devel/a59ec3abedf0a80e07d011269ba9aeb134227e41
Build 2013-04-13

Copyright (c) 2006-2010 Abdulaziz Ghuloum and contributors
Copyright (c) 2011-2013 Marco Maggi

vicare> (+ 2 2)
4
@end example

@noindent
end--of--file (@key{Ctrl-D} in a typical terminal window) will terminate
the session.

@c page
@node using invoking
@section Command line arguments


The synopsis of the @value{EXECUTABLE} program is as follows:

@smallexample
@value{RAWEXECUTABLE} [@var{OPTIONS}] [PROGRAM]              [-- [@var{PROGOPTS}]]
@value{RAWEXECUTABLE} [@var{OPTIONS}] --r6rs-script     FILE [-- [@var{PROGOPTS}]]
@value{RAWEXECUTABLE} [@var{OPTIONS}] --binary-program  FILE [-- [@var{PROGOPTS}]]
@value{RAWEXECUTABLE} [@var{OPTIONS}] --compile-program FILE
@value{RAWEXECUTABLE} [@var{OPTIONS}] --compile-library LIBFILE
@value{RAWEXECUTABLE} [@var{OPTIONS}] --compile FILE
@value{RAWEXECUTABLE} [@var{OPTIONS}] --compile-dependencies PROGRAM
@end smallexample

@noindent
the @var{OPTIONS} are interpreted by @value{EXECUTABLE}, @var{PROGOPTS}
can be obtained using the @func{command-line} procedure in the
@library{rnrs programs} library; when running the @repl{}: the first
element of the returned list will be the string @samp{*interactive*},
corresponding to the script name in @rnrs{6}--script mode.

The @value{EXECUTABLE} executable recognises a few command line switches
that influence how @value{PACKAGE} starts; the following are the main
options, driving the execution mode.  It is an error to put on the
command line two or more of these options.

@table @code
@item --r6rs-script @var{PROGRAM}
@cindex Command line option @option{--r6rs-script}
@cindex @option{--r6rs-script}, command line option
Start Vicare in @rnrs{6}--script mode.  The @var{PROGRAM} file is handled
as an @rnrs{6} program.  Example:

@example
$ cat test.sps
(import (rnrs))
(write (command-line))
(newline)

$ @value{RAWEXECUTABLE} --r6rs-script test.sps hi there
("test.sps" "hi" "there")
@end example

@item --binary-program @var{PROGRAM}
@cindex Command line option @option{--binary-program}
@cindex @option{--binary-program}, command line option
Start Vicare in compiled--program mode.  The @var{PROGRAM} file is
handled as a serialised @rnrs{6} program: it is loaded and executed.

@item --compile-program @var{PROGRAM}
@cindex Command line option @option{--compile-program}
@cindex @option{--compile-program}, command line option
Load the source @rnrs{6} program @var{PROGRAM}, compile it and store a
serialised version of it in a file whose name is built from
@var{PROGRAM}.  @var{PROGRAM} itself is not evaluated.

@item --compile-dependencies @var{IMPORTS-FILE}
@cindex Command line option @option{--compile-dependencies}
@cindex @option{--compile-dependencies}, command line option
Load the @rnrs{6} program @var{IMPORTS-FILE}, compile all the libraries
upon which it depends and store them in the FASL repository.
@var{IMPORTS-FILE} itself is not evaluated.

@item --compile-library @var{LIBFILE}
@cindex Command line option @option{--compile-library}
@cindex @option{--compile-library}, command line option
Load the @rnrs{6} library source @var{LIBFILE}, compile it and save the
result in the @fasl{} repository.

@item -c @var{FILE}
@itemx --compile @var{FILE}
@cindex Command line option @option{-c}
@cindex @option{-c}, command line option
@cindex Command line option @option{--compile}
@cindex @option{--compile}, command line option
Load the selected @var{FILE}, recognise it as program or library by the
file extension (@code{.sps} or @code{.sls}), compile it and store it as
@fasl{} file.
@end table

When none of these options is given, but a standalone @var{PROGRAM}
argument is present on the command line: act as if the option
@option{--r6rs-script} is present with the given file name.

If no standalone @var{PROGRAM} argument is present: enter the @repl{}.
When neither the option @option{--rcfile} nor the option
@option{--no-rcfile} is used: before entering the @repl{}, the default
run--command file @file{~/.vicarerc} is loaded.

The rest of the command line arguments are recognised by the standard
Scheme run time system.

@table @code
@item -b path/to/boot/file.boot
@itemx --boot path/to/boot/file.boot
@cindex Command line option @option{--boot}
@cindex @option{--boot}, command line option
@cindex Command line option @option{-b}
@cindex @option{-b}, command line option
Use the specified boot file as the initial system boot file.  The boot
file is a binary file that contains all the code and data of the Scheme
system.  In the absence of the @option{-b} flag, the executable will use
the default boot file.  Running @value{EXECUTABLE} with the @option{-h}
option shows the location where the default boot file was installed.

@item --no-rcfile
@cindex Command line option @option{--no-rcfile}
@cindex @option{--no-rcfile}, command line option
Disable loading of run--command files.

@item --rcfile @var{FILE}
@cindex Command line option @option{--rcfile}
@cindex @option{--rcfile}, command line option
Load and evaluate @var{FILE} as an @rnrs{6} program at startup, before
loading libraries and running the main program.  This option can be used
multiple times.

When the execution mode is to enter the @repl{}: using this option
disables loading the default file @file{~/.vicarerc}; only the selected
@var{FILE} scripts are loaded.

@item -o @var{OFILE}
@itemx --output @var{OFILE}
@cindex Command line option @option{--output}
@cindex @option{--output}, command line option
Select the pathname of an output file.  This selection has multiple
purposes and it is ignored when irrelevant.  @var{OFILE} is used as:
output @fasl{} file name when compiling individual library files; output
@fasl{} file name when compiling program files.

@item -l @var{LIBFILE}
@itemx --load-library @var{LIBFILE}
@cindex Command line option @option{-l}
@cindex @option{-l}, command line option
@cindex Command line option @option{--load-library}
@cindex @option{--load-library}, command line option
Load @var{libfile} expecting it to contain one or more @rnrs{6}
libraries; after executing the RC files, load the libraries in the
internal collection, but do not add them to any environment.  This
option can be used multiple times.

@item --source-path @var{DIRECTORY}
@cindex Command line option @option{--source-path}
@cindex @option{--source-path}, command line option
Add @var{DIRECTORY} to the library search path.  This option can be used
multiple times.

@item -L @var{DIRECTORY}
@itemx --library-path @var{DIRECTORY}
@cindex Command line option @option{--library-path}
@cindex @option{--library-path}, command line option
@cindex Command line option @option{-L}
@cindex @option{-L}, command line option
Add @var{DIRECTORY} to the @fasl{} search path.  This option can be used
multiple times.

@item --store-directory @var{DIRECTORY}
@cindex Command line option @option{--store-directory}
@cindex @option{--store-directory}, command line option
Select @var{DIRECTORY} as pathname under which compiled library files
are temporarily stored before being installed.  When used multiple
times: the last one wins.

@item --more-file-extensions
@cindex Command line option @option{--more-file-extensions}
@cindex @option{--more-file-extensions}, command line option
Rather than searching only libraries with extension @samp{.vicare.sls}
and @samp{.sls}, search also for @samp{.vicare.ss}, @samp{.ss},
@samp{.vicare.scm}, @samp{.scm} and the @samp{main} file.  @ref{using
libraries searching} for more details.

@item --prompt @var{STRING}
@cindex Command line option @option{--prompt}
@cindex @option{--prompt}, command line option
Use @var{STRING} as prompt for the @repl{}.  Defaults to @samp{vicare},
to which the character @samp{>} is appended for each nested @repl{}
level.  @ref{iklib cafe} for more details.

@item --repl-on-sigint
@cindex Command line option @option{--repl-on-sigint}
@cindex @option{--repl-on-sigint}, command line option
When this option is used an interprocess signal handler is registered at
program startup to enter a debugging @repl{} whenever a @code{SIGINT}
signal is received.

@item --raw-repl
@cindex Command line option @option{--raw-repl}
@cindex @option{--raw-repl}, command line option
Do not create a readline console input port even if the readline
interface is available.

@item -d
@itemx -g
@itemx --debug
@cindex Command line option @option{--debug}
@cindex @option{--debug}, command line option
@cindex Command line option @option{-d}
@cindex @option{-d}, command line option
@cindex Command line option @option{-g}
@cindex @option{-g}, command line option
Turn on debugging mode.  With this unhandled exceptions in the program
will result in starting the debugger, which allows stack trace
inspection.

@item -nd
@itemx --no-debug
@cindex Command line option @option{--no-debug}
@cindex @option{--no-debug}, command line option
@cindex Command line option @option{-nd}
@cindex @option{-nd}, command line option
Turn off debugging mode.

@item --gc-integrity-checks
@cindex Command line option @option{--gc-integrity-checks}
@cindex @option{--gc-integrity-checks}, command line option
Enable garbage collection integrity checks.  This slows down the garbage
collection.

@item --no-gc-integrity-checks
@cindex Command line option @option{--no-gc-integrity-checks}
@cindex @option{--no-gc-integrity-checks}, command line option
Disable garbage collection integrity checks.  This is the default.

@item --print-loaded-libraries
@cindex Command line option @option{--print-loaded-libraries}
@cindex @option{--print-loaded-libraries}, command line option
Whenever a library file is loaded print a message on the console error
port.  This is for debugging purposes.  When used together with
@option{--debug-messages}: even more detailed messages are generated for
library related actions.

@item --no-print-loaded-libraries
@cindex Command line option @option{--no-print-loaded-libraries}
@cindex @option{--no-print-loaded-libraries}, command line option
Disables the effect of @option{--print-loaded-libraries}.

@item --debug-messages
@cindex Command line option @option{--debug-messages}
@cindex @option{--debug-messages}, command line option
Be more verbose aboud undertaken actions.  This is for debugging
purposes.

@item --no-debug-messages
@cindex Command line option @option{--no-debug-messages}
@cindex @option{--no-debug-messages}, command line option
Disables the effect of @option{--debug-messages}.

@item --report-errors-at-runtime
@cindex Command line option @option{--report-errors-at-runtime}
@cindex @option{--report-errors-at-runtime}, command line option
When possible and meaningful: report errors at runtime rather than at
compile time.  Runtime errors reporting is @rnrs{6} compliant.  The
default is to raise errors at compile time.

@item --no-report-errors-at-runtime
@cindex Command line option @option{--no-report-errors-at-runtime}
@cindex @option{--no-report-errors-at-runtime}, command line option
Disables the effect of @option{--report-errors-at-runtime}.

@item --strict-r6rs
@cindex Command line option @option{--strict-r6rs}
@cindex @option{--strict-r6rs}, command line option
Strictly follow @rnrs{6} specifications: disable Vicare extensions.

@item --no-strict-r6rs
@cindex Command line option @option{--no-strict-r6rs}
@cindex @option{--no-strict-r6rs}, command line option
Do not strictly follow @rnrs{6} specifications: enable @value{PRJNAME}
extensions.  Disables the effect of @option{--strict-r6rs}.  This is the
default.

@item --descriptive-labels
@cindex Command line option @option{--descriptive-labels}
@cindex @option{--descriptive-labels}, command line option
For debugging purposes: generate descriptive labels in expanded and
assembly code.

@item --no-descriptive-labels
@cindex Command line option @option{--no-descriptive-labels}
@cindex @option{--no-descriptive-labels}, command line option
For debugging purposes: do not generate descriptive labels in expanded
code and assembly code.  Disables the effect of
@option{--descriptive-labels}.  This is the default.

@item --library-locator @var{NAME}
@cindex Command line option @option{--library-locator}
@cindex @option{--library-locator}, command line option
Select a Scheme library locator.  @var{NAME} can be one among:
@samp{run-time}, @samp{compile-time}, @samp{source}. For details on
searching libraries @ref{using libraries searching, Library search
algorithms}.  For details on the built--in library locators @api{}
@ref{libutils locating, Locating libraries}.

@item -O0
@cindex Command line option @option{-O}
@cindex @option{-O}, command line option
Turn off use of the source optimizer.

@item -O1
@itemx -O2
@itemx -O3
@cindex Command line option @option{-O}
@cindex @option{-O}, command line option
Turn on various levels of compile optimisations.

@item --optimizer-passes-count @var{COUNT}
@cindex Command line option @option{--optimizer-passes-count}
@cindex @option{--optimizer-passes-count}, command line option
Specify how many passes to perform with the source optimizer.  Must be a
positive fixnum.  Defaults to 1.

@item --enable-open-mvcalls
@itemx --disable-open-mvcalls
@cindex Command line option @option{--enable-open-mvcalls}
@cindex @option{--enable-open-mvcalls}, command line option
@cindex Command line option @option{--disable-open-mvcalls}
@cindex @option{--disable-open-mvcalls}, command line option
Enable or disable inlining of calls to @func{call-with-values}.
Defaults to disable.

@item --print-assembly
@cindex Command line option @option{--print-assembly}
@cindex @option{--print-assembly}, command line option
Print to the current error port the assembly instructions generated when
compiling code.

@item --print-optimizer
@itemx --print-optimiser
@cindex Command line option @option{--print-optimizer}
@cindex @option{--print-optimizer}, command line option
Print to the current error port a symbolic expression which results from
running the optimiser.

@item -V
@itemx --version
@cindex Command line option @option{--version}
@cindex @option{--version}, command line option
@cindex Command line option @option{-V}
@cindex @option{-V}, command line option
Display the version message then exit.

@item --version-only
@cindex Command line option @option{--version-only}
@cindex @option{--version-only}, command line option
Display only the version number on the standard error port, followed by
a newline, then exit.

@item --license
@cindex Command line option @option{--license}
@cindex @option{--license}, command line option
Display the license message then exit.

@item -h
@itemx --help
@cindex Command line option @option{--help}
@cindex @option{--help}, command line option
@cindex Command line option @option{-h}
@cindex @option{-h}, command line option
Display the help message then exit.

@item --
@cindex Command line option @option{--}
@cindex @option{--}, command line option
Mark the end of @value{EXECUTABLE} options; all the arguments after this
marker can be obtained by calling the @func{command-line} procedure.

@item -v
@itemx --verbose
@cindex Command line option @option{--verbose}
@cindex @option{--verbose}, command line option
@cindex Command line option @option{-v}
@cindex @option{-v}, command line option
Turn on verbose messages describing expander and compiler operations.

@item --silent
@cindex Command line option @option{--silent}
@cindex @option{--silent}, command line option
Turn off verbose messages describing compiler operations.
@end table

@c page
@node using scripts
@section Executing Scheme scripts


Scheme scripts can be executed using the following command:

@example
@value{RAWEXECUTABLE} --r6rs-script @var{PROGRAM}
@end example

@noindent
or the shorter:

@example
@value{RAWEXECUTABLE} @var{PROGRAM}
@end example

@value{PACKAGE} follows the @rnrs{6} recommendations to install a
wrapper program called @command{scheme-script} only when the
@command{configure} option @option{--enable-scheme-script} is used at
package configuration time; this is to avoid conflicts with other Scheme
implementations.  In this scenario, it is possible to execute Scheme
scripts as follows:

@example
scheme-script @var{PROGRAM} [program options]
@end example

@noindent
where the optional program options can be retrieved with
@func{command-line}, @ref{stdlib programlib, command-line}.  When using
@command{scheme-script} it is impossible to select command arguments to
be passed to @value{PRJNAME} rather than to the script.

Here is a sample script (Pig Latin---``Igpay Atinlay''---is a code that
was at one time popular among very young North American children).

@example
(import (rnrs))

;;; Convert a string to its Pig Latin equivalent.
;;;
;;; If the first character is a vowel, append "yay".
;;; "egg" -> "eggyay"
;;;
;;; If the first character is a consonant, remove it,
;;; and append it plus "ay" to the string.
;;; "foo" -> "oofay"

(define pig-latin
  (lambda (str)
    (let ((first (string-ref str 0)))
      (if (memv first '(#\a #\e #\i #\o #\u))
	  (string-append str "yay")
	  (string-append
 	    (substring str 1 (string-length str))
	    (string first) "ay")))))

(display
 (map pig-latin
     (cdr (command-line))))
(newline)
@end example

Assuming we have stored the script in the file @file{demo.sps}, we can
invoke this script via @value{EXECUTABLE}:

@example
$ @value{RAWEXECUTABLE} --r6rs-script demo.sps ice cream after dinner
(iceyay reamcay afteryay innerday)
@end example

On Unix/Linux systems, scripts generally start with a ``shebang'' line
(@emph{sh}arp plus @emph{bang}) which names an interpreter for the
script.  All modern systems have the @command{env} command which
searches for a command in the user's path.

@example
#!/usr/bin/env @value{RAWEXECUTABLE} --r6rs-script
(import (rnrs))

...
@end example

Now we can make the file executable, and use it directly.

@example
$ chmod +x demo.sps
$ ./demo.sps ice cream after dinner
(iceyay reamcay afteryay innerday)
@end example

There are a few fine points.

@itemize
@item
If the first two bytes of a script represent the sequence @samp{#!} in
@ascii{} encoding: the first line is discarded and not parsed as Scheme
code.  This allows scripts on Unix systems to start with the command
line needed to use them; notice that this will discard valid sharp--bang
comments (like @code{#!r6rs}) if they are at the very beginning of a
file.

@item
Under Mac OS X, if a script name ends with the @code{.command}
extension, then it can be executed from the Finder by double--clicking
on it.  This brings up a terminal window in which the script is
executed.  The @code{.command} extension can be hidden from the
@emph{Get Info} item from the Finder's File menu.
@end itemize

@c page
@node using libraries
@section @rnrs{6} libraries and extensions


A library exports features that can be imported into programs and other
libraries; a library is named by a list of symbols, for example
@library{nausicaa uri pathname}.  The core features of the @rnrs{6}
language is provided in the library @library{rnrs}; the full
@value{PRJNAME} features are provided by the library @library{vicare}.

@menu
* using libraries intro::       Introduction to @value{PRJNAME} libraries.
* using libraries filenames::   File names from library references.
* using libraries paths::       Library search paths.
* using libraries searching::   Library search algorithms.
* using libraries compiling::   Compiling libraries in binary format.
* using libraries examples::    Examples of libraries usage.
@end menu

@c page
@node using libraries intro
@subsection Introduction to libraries


A library consists of a ``file'' (some assemblage of text) that contains
a library form, which might look like this:

@example
(library (sample)
  (export cube)
  (import (rnrs))
  (define cube
    (lambda (x)
      (* x x x))))
@end example

@noindent
notice the @func{import} clause; libraries have no predefined namespace,
and therefore at least @library{rnrs} must be imported.

We can import @library{sample} into another library, a script, or a
@value{PRJNAME} top--level session:

@example
> (import (sample))
> (cube 3)
27
@end example

Library names are lists, thus allowing the writer of one or more
libraries to group related libraries together.  For example,
@value{PRJNAME} installs a whole hierarchy of libraries under
@library{vicare language-extensions}:

@example
(vicare language-extensions amb)
(vicare language-extensions infix))
...
@end example

@noindent
@value{PRJNAME}'s own Scheme libraries are under the hierarchies:
@library{vicare ---}, @library{srfi ---} and @library{nausicaa ---}.

@value{PRJNAME}'s boot image and distributed libraries are installed in
the directory:

@example
$(libdir)/vicare-scheme
@end example

@noindent
on 32-bit @gnu{}+Linux systems:

@example
/usr/local/lib/vicare-scheme
@end example

@noindent
on 64-bit @gnu{}+Linux systems:

@example
/usr/local/lib64/vicare-scheme
@end example

@noindent
for example the library @library{vicare ffi} on @gnu{}+Linux systems is
installed as:

@example
/usr/local/lib/vicare-scheme/vicare/ffi.fasl
@end example

User libraries that are meant to be usable by @value{PRJNAME} and other
@rnrs{6} implementations should be installed in the directory:

@example
$(libdir)/scheme/r6rs
@end example

@noindent
on 32-bit @gnu{}+Linux systems:

@example
/usr/local/lib/scheme/r6rs
@end example

@c page
@node using libraries filenames
@subsection File names from library references


A library is a file with the same name as the last component of the
library name.  For example, the library @library{sample} will correspond
to a source file named @file{sample.sls} and a binary file named
@file{sample.fasl} somewhere in the file system.  The file extension
@code{.sls} stands for ``Scheme Library Source'' and @code{.fasl} stands
for ``FASt Loading''.

@quotation
@strong{NOTE} @value{PRJNAME} will also accept the extensions @code{.ss}
and @code{.scm} when the command line option
@option{--more-file-extensions} is used.
@end quotation

Here is an example of each case:

@itemize
@item
Importing @library{sample} causes @value{PRJNAME} to look for a binary
file named @file{sample.fasl} and a source file named @file{sample.sls}.

@item
Importing @library{yoyodyne sample} causes @value{PRJNAME} to look for a
directory named @file{yoyodyne}, and within that a binary file named
@file{sample.fasl} and a source file named @file{sample.sls}.  The
@func{library} form for this library must still specify the library name
as @library{yoyodyne sample}, not @library{sample}.
@end itemize

By default, @value{PRJNAME} attempts to import the library @library{a b
c} in binary format as follows: build file ``stem'' @code{/a/b/c},
append the string @code{.fasl} to the stem; it also attempts to import
the library @library{a b c} from source as follows: build file ``stem''
@code{/a/b/c}, append each of the following strings to the stem:
@code{.vicare.sls}, @code{.sls}.  Directories from the search paths are
prepended to the file stem plus extension and searched on the file
system, stopping at the first match.

There are two refinements of the library search algorithm for source
libraries, which are performed when the @option{--more-file-extensions}
command line option is used.

@itemize
@item
A common pattern is to distribute a main library along with a number of
additional extensions: we might have a main library named @library{lib},
and additional optional extensions named @library{lib extras} and
@library{lib frills}.

Although the previous packaging method can be used, @value{PRJNAME}
allows us to use a simpler technique where the main library is stored in
@file{lib/main.sls}, and the extensions are stored in
@file{lib/extras.sls} and @file{lib/frills.sls}, respectively.

@item
When searching for source libraries: @value{PRJNAME} will also look in
@file{lib/main.vicare.sls} before trying @file{lib/main.sls}; this
allows us to provide a @value{PRJNAME}--specific implementation as well
as a generic implementation.  When searching for binary libraries: only
the file @file{lib/main.fasl} is searched.
@end itemize

When the the command line option @option{--more-file-extensions} is used
and the library @library{a b c} is imported in source form:

@enumerate
@item
The file ``stem'' is built: @code{/a/b/c}.

@item
Each of the following strings is appended to the stem, in order, until a
matching file is found:

@example
/main.vicare.sls
/main.vicare.ss
/main.vicare.scm
/main.sls
/main.ss
/main.scm
.vicare.sls
.vicare.ss
.vicare.scm
.sls
.ss
.scm
@end example
@end enumerate

@noindent
if there is no match, then the import request fails.

Whenever the library name component @code{main} appears as last and not
unique component: when building the file stem such component is
``quoted'' by appending an underscore character; examples:

@example
(alpha beta main)       @result{} "alpha/beta/main_"
(main alpha)            @result{} "main/alpha"
(main)                  @result{} "main"
@end example

@c page
@node using libraries paths
@subsection Library search paths


@cindex Library source path
@cindex Binary library source path
@cindex Source library source path
@cindex @fasl{} file source path
@cindex @func{library-source-search-path}
@cindex @func{library-binary-search-path}
@cindex @env{VICARE_SOURCE_PATH}, system environment variable
@cindex @env{VICARE_LIBRARY_PATH}, system environment variable
@cindex Environment variable @env{VICARE_SOURCE_PATH}
@cindex Environment variable @env{VICARE_LIBRARY_PATH}


@value{PRJNAME} has a search algorithm for libraries that is similar to
those used in other languages.  @value{PRJNAME}'s search path comprises
a series of directories; when we try to import a library whose name
contains just one component, @value{PRJNAME} will examine each directory
in the search path for a file with a matching name.  Importing a library
whose name is a list of components causes @value{PRJNAME} to look for a
series of subdirectories with matching names.

There are two search paths, one for binary libraries and one for source
libraries:

@itemize
@item
The source libraries search path is stored in the parameter
@func{library-source-search-path}.

@item
The binary libraries search path is stored in the parameter
@func{library-binary-search-path}.
@end itemize

@noindent
both these parameters are meant to contain lists of strings representing
directory pathnames and can be updated as necessary.

@c ------------------------------------------------------------

@subsubheading Source path initialisation


The default value of the parameter @func{library-source-search-path} is composed as
follows:

@enumerate
@item
The parameter is initialised to the empty list.

@item
At the beginning of execution, @value{PRJNAME} consults the environment
variable @env{VICARE_SOURCE_PATH}; when set, it is expected to hold a
colon separated list of directory pathnames, in Unix--style.  The list
is parsed and the directories are placed, in the given order, in
@func{library-source-search-path}.

@item
If the options @option{-L} and @option{--search-path} are present on the
command line: their value is expected to be a string representing a
directory pathname.  Such pathnames are prepended, in the given order,
to @func{library-source-search-path}.

@item
While @value{RAWEXECUTABLE} is running: we can modify at will the content of
@func{libary-path}.
@end enumerate

@c ------------------------------------------------------------

@subsubheading Binary path initialisation


The default value of the parameter @func{library-binary-search-path} is composed
as follows:

@enumerate
@item
The parameter is initialised to a list of directory pathnames built at
package configuration time, in this order:

@example
$(libdir)/scheme/r6rs
$(libdir)/vicare-scheme
@end example

@noindent
on 64-bit @gnu{}+Linux systems, these are usually:

@example
/usr/local/lib64/scheme/r6rs
/usr/local/lib64/vicare-scheme
@end example

@noindent
and on 32-bit @gnu{}+Linux systems:

@example
/usr/local/lib/scheme/r6rs
/usr/local/lib/vicare-scheme
@end example

@item
At the beginning of execution @value{PRJNAME} consults the environment
variable @env{VICARE_LIBRARY_PATH}; when set, it is expected to hold a
colon separated list of directory pathnames, in Unix--style.  The list
is parsed and the directories are placed, in the given order, in
@func{library-binary-search-path}.

@item
If the options @option{-F} and @option{--fasl-path} are present on the
command line: their value is expected to be a string representing a
directory pathname.  Such pathnames are prepended, in the given order,
to @func{library-binary-search-path}.

@item
While @value{RAWEXECUTABLE} is running: we can modify at will the
content of @func{library-binary-search-path}.
@end enumerate

In the following example session the user sets
@env{VICARE_LIBRARY_PATH}; the settings are reflected in the value of
@code{(library-binary-search-path)}; a further directory is then set during the
session:

@example
$ export VICARE_LIBRARY_PATH=$HOME/scheme:/tmp/library
$ echo $VICARE_LIBRARY_PATH
/home/marco/scheme:/tmp/library
$ @value{RAWEXECUTABLE}
...

> (import (prefix (vicare libraries) libs.))
> (libs.library-binary-search-path)
("/home/marco/scheme"
 "/tmp/library"
 "/usr/local/lib/scheme/r6rs"
 "/usr/local/lib/vicare-scheme")
> (libs.library-binary-search-path
     (cons "/opt/sw/extra-libraries" (libs.library-binary-search-path)))
> (libs.library-binary-search-path)
("/opt/sw/extra-libraries"
 "/home/marco/scheme"
 "/tmp/library"
 "/usr/local/lib/scheme/r6rs"
 "/usr/local/lib/vicare-scheme")
@end example

In programs intended to be distributed, we should resist the urge to set
@func{library-binary-search-path} and @func{library-source-search-path}, as the user's file
hierarchies might not match ours; for most libraries, simply telling the
user to install the files in one of the directories on the search path
is good enough.

@c page
@node using libraries searching
@subsection Library search algorithms


In the typical scenario: packages compile source libraries in binary
format and store them in @fasl{} files; then such @fasl{} files are
installed in one of the directory referenced by the parameter
@func{library-binary-search-path}; finally, when running an application, imported
libraries are loaded in binary form from @fasl{} files.

There are two basic modes to search for libraries:

@table @strong
@item run--time search
To be used when executing a program with the purpose of running an
application.

@item compile--time search
To be used when executing a program with the purpose of compiling source
libraries to binary format for installation.  This mode is selected only
when one of the command line options @option{--compile-dependencies} and
@option{--compile-library} is used.
@end table

A library is imported by specifying a @rnrs{6} library reference in an
@clause{import} clause.  A library loaded from a @fasl{} file can be
accepted as matching the reference or rejected; the causes for rejection
are:

@itemize
@item
The identifiers in the @rnrs{6} library name from the @fasl{} file do
not match the identifiers in the library reference.

@item
The version specification in the @rnrs{6} library name from the @fasl{}
file does not comply with the version reference specification in the
library reference.

@item
The @fasl{} file has been compiled with a @value{PRJNAME} boot image
different from the one used to load it.

@item
A library @samp{X} is importing another compiled library @samp{Y};
@samp{X} was compiled using the binary object @samp{Y.1}, but now the
binary object @samp{Y.2} is being loaded: @samp{Y.2} is rejected.
@end itemize

@noindent
A library loaded from a source file can be accepted as matching the
reference or rejected; the causes for rejection are:

@itemize
@item
The identifiers in the @rnrs{6} library name from the source file do not
match the identifiers in the library reference.

@item
The version specification in the @rnrs{6} library name from the source
file does not comply with the version reference specification in the
library reference.
@end itemize

@c ------------------------------------------------------------

@subsubheading Run--time libraries search


Given a @rnrs{6} library reference, @value{PRJNAME} performs the
following operations:

@enumerate
@item
Build the ``stem'' of the library file, joining the identifiers from the
library reference with a directory separator and adding a directory
separator as prefix.  For example the library reference @library{alpha
beta (1 2)} generates the stem @code{/alpha/beta}.

@item
All the directories listed in the parameter @func{library-binary-search-path} are
visited, in order: the directory is prepended to the stem and the
@fasl{} file extension is appended to it; the resulting file is tested
for existence stopping at the first match.  For example the following
files might be tested:

@example
~/.vicare/precompiled/alpha/beta.fasl
/usr/local/lib64/scheme/r6rs/alpha/beta.fasl
/usr/local/lib64/vicare-scheme/alpha/beta.fasl
@end example

@item
If a @fasl{} file exists: it is loaded expecting it to contain a binary
library.  If the library is accepted the search terminates; if the
library is rejected the search goes on with the next directory from
@func{library-binary-search-path}.

@item
If no matching @fasl{} file is found or all the binary libraries found
are rejected: the search continues for source files.  All the
directories listed in the parameter @func{library-source-search-path} are visited, in
order: the directory is prepended to the stem and the source file
extensions are appended to it; the resulting file is tested for
existence stopping at the first match.  For example the following files
might be tested:

@example
~/share/vicare-scheme/alpha/beta.vicare.sls
~/share/vicare-scheme/alpha/beta.sls
/usr/local/share/scheme/r6rs/alpha/beta.vicare.sls
/usr/local/share/scheme/r6rs/alpha/beta.sls
/usr/local/share/vicare-scheme/alpha/beta.vicare.sls
/usr/local/share/vicare-scheme/alpha/beta.sls
@end example

@item
If a source file exists: it is loaded expecting it to contain a source
library.  If the library is accepted the search terminates; if the
library is rejected the search goes on with the next file or the next
directory from @func{library-source-search-path}.

@item
If no source file is found or all the source libraries found are
rejected: the search fails.
@end enumerate

@c ------------------------------------------------------------

@subsubheading Compile--time libraries search


Given a @rnrs{6} library reference, @value{PRJNAME} performs the
following operations:

@enumerate
@item
Build the ``stem'' of the library file, joining the identifiers from the
library reference with a directory separator and adding a directory
separator as prefix.  For example the library reference @library{alpha
beta (1 2)} generates the stem @code{/alpha/beta}.

@item
All the directories listed in the parameter @func{libary-path} are
visited, in order: the directory is prepended to the stem and the source
file extensions are appended to it; the resulting files are tested for
existence stopping at the first match.  For example, in the source tree
of a package, if:

@example
(library-source-search-path)  @result{} ("./lib")
@end example

@noindent
the following files are be tested:

@example
./lib/alpha/beta.vicare.sls
./lib/alpha/beta.sls
@end example

@item
If a source file exists: the source file is loaded, expecting it to
contain a source library.  If the source library is accepted: the search
terminates; if the source library is rejected: the search continues with
the next file extension or the next directory from
@func{library-source-search-path}.

@item
If a source file does not exist: the search continues looking for a
binary library.  All the directories listed in the parameter
@func{library-binary-search-path} are visited, in order: the directory is
prepended to the stem and the @fasl{} file extension is appended to it;
the resulting file is tested for existence stopping at the first match.
For example the following files might be tested:

@example
~/.vicare/precompiled/alpha/beta.fasl
/usr/local/lib64/scheme/r6rs/alpha/beta.fasl
/usr/local/lib64/vicare-scheme/alpha/beta.fasl
@end example

@item
If a @fasl{} file exists: it is loaded expecting it to contain a binary
library.  If the library is accepted the search terminates; if the
library is rejected the search goes on with the next directory from
@func{library-binary-search-path}.

@item
If no matching @fasl{} file is found or all the binary libraries found
are rejected: the search fails.
@end enumerate

@c page
@node using libraries compiling
@subsection Compiling libraries in binary format


@menu
* using libraries compiling lib::   Compiling a single library.
* using libraries compiling deps::  Compiling all the dependencies.
@end menu

@c page
@node using libraries compiling lib
@subsubsection Compiling a single library


This library compilation strategy is implemented by a proper execution
mode of @value{EXECUTABLE}; in this mode:

@itemize
@item
The compile--time library locator is selected, @ref{using libraries
searching, Compile--time libraries search}.

@item
A @rnrs{6} library is loaded from an explicitly selected source file,
compiled, and possibly invoked and visited.

@item
It is assumed that all the library's dependency libraries are available
in binary format.

@item
The loaded library is serialized to a @fasl{} file in an explicitly
selected output file or in the selected
@func{compiled-library-store-directory}.
@end itemize

This execution mode is enabled by the command line option
@option{--compile-library} of @value{EXECUTABLE}; when using this mode the
command line option @option{--cache-libraries} is
@strong{ignored}.

Let's say we have the libraries:

@example
(alpha beta (1 0))
(alpha gamma (1 2))
@end example

@noindent
in the files:

@example
$(srcdir)/lib/alpha/beta.sls
$(srcdir)/lib/alpha/gamma.sls
@end example

@noindent
we want to compile them to:

@example
$(builddir)/lib/alpha/beta.fasl
$(builddir)/lib/alpha/gamma.fasl
@end example

@noindent
and @library{alpha gamma (1 2)} imports @library{alpha beta (1 0)}.  We
have multiple options:

@itemize
@item
We explicitly execute (in the correct order) the commands that compile
one library at a time, explicitly selecting the source and binary file
pathnames.  First, to compile @library{alpha beta (1 0)}, we do:

@example
vicare \
  --compile-library $(srcdir)/lib/alpha/beta.sls \
  --output $(builddir)/lib/alpha/beta.fasl
@end example

@noindent
then, to compile @library{alpha gamma (1 2)}, we do:

@example
vicare \
  --fasl-path $(builddir)/lib \
  --compile-library $(srcdir)/lib/alpha/gamma.sls \
  --output $(builddir)/lib/alpha/gamma.fasl
@end example

@item
We explicitly execute (in the correct order) the commands that compile
one library at a time, explicitly selecting the output directory for
@fasl{} files.  First, to compile @library{alpha beta (1 0)}, we do:

@example
vicare \
  --store-directory $(builddir)/lib \
  --compile-library $(srcdir)/lib/alpha/beta.sls
@end example

@noindent
then, to compile @library{alpha gamma (1 2)}, we do:

@example
vicare \
  --store-directory $(builddir)/lib \
  --fasl-path $(builddir)/lib \
  --compile-library $(srcdir)/lib/alpha/gamma.sls
@end example
@end itemize

This compilation strategy is useful when compiling a ``big'' number of
libraries with a traditional @file{Makefile}:

@itemize
@item
It allows compiling only libraries for which the source is newer than
the binary.

@item
It allows running the compilation commands in parallel when possible,
using, for example, the @option{-j} option of @gnu{} Make.
@end itemize

To use this strategy effectively we need to write all the compilation
commands, correctly tracking the dependencies; this is tedius, but there
are ways to automatically generate the needed commands.

@c page
@node using libraries compiling deps
@subsubsection Compiling all the dependencies of a program


This library compilation strategy is implemented by a proper execution
mode of @value{EXECUTABLE}; in this mode:

@itemize
@item
The compile--time library locator is selected, @ref{using libraries
searching, Compile--time libraries search}.

@item
A @rnrs{6} program is loaded from a file but @strong{not} executed.

@item
All the program's dependency libraries are loaded, compiled, and
possibly invoked and visited.

@item
All the libraries loaded from a source file are serialized to @fasl{}
files in the selected @func{compiled-library-store-directory}; all the
libraries loaded from a @fasl{} file are left untouched.
@end itemize

This execution mode is enabled by the command line option
@option{--compile-dependencies} of @value{EXECUTABLE}; when using this
mode the command line option @option{--output} is @strong{ignored}.

Let's say we have the libraries:

@example
(alpha beta (1 0))
(alpha gamma (1 2))
@end example

@noindent
in the files:

@example
$(srcdir)/lib/alpha/beta.sls
$(srcdir)/lib/alpha/gamma.sls
@end example

@noindent
and we want to compile them to:

@example
$(builddir)/lib/alpha/beta.fasl
$(builddir)/lib/alpha/gamma.fasl
@end example

@noindent
we prepare a Scheme script for this purpose, containing the required
@func{import} forms:

@example
;; compile-all.sps --
;;

(import (only (alpha beta))
        (only (alpha beta)))

;;; end of file
@end example

@noindent
and we execute it as follows:

@example
vicare \
   --search-path $(srcdir)/lib \
   --store-directory $(builddir)/lib \
   --compile-dependencies compile-all.sps
@end example

If a selected library depends on the other selected library:
@value{PRJNAME} will automatically take care of generating the
appropriate binary formats.  If a selected library depends on other
libraries, not explicitly selected by the script: @value{PRJNAME} will
automatically take care of generating the appropriate binary formats and
@fasl{} files in the selected @func{compiled-library-store-directory}.

@c page
@node using libraries examples
@subsection Examples of library usage


Consider a program using the procedure @func{pretty-print} to format
some code, and suppose further that pretty printing is just a nice
add--on (e.g. using @file{write} suffices, but pretty--printing is
@emph{just prettier}).

@value{PRJNAME} exports a good pretty--printing facility in its
@library{vicare} library.  However, since @func{pretty-print} is not a
standard procedure, a program that uses it would be rendered unportable
to other @rnrs{6} Scheme implementations.

The programmer can put the @code{.vicare.sls} extension to use in this
situation, by writing two versions of a @library{pretty-printing}
library: one for use by @value{PRJNAME}, and one portable for other
implementations.

@example
;; pretty-printing.vicare.sls --
;;
;; Can be used only by @value{PRJNAME} Scheme.

(library (pretty-printing)
  (export pretty-print)
  (import (only (vicare) pretty-print)))

;;; end of file
@end example

@example
;; pretty-printing.sls --
;;
;; For any other Scheme implementation, portable though
;; not very pretty.

(library (pretty-printing)
  (export pretty-print)
  (import (rnrs))
  (define (pretty-print x port)
    (write x port)
    (newline port)))

;;; end of file
@end example

@c page
@node using programs
@section Compiling Scheme programs


@cindex @rnrs{6} programs
@cindex Scheme programs
@cindex Scheme scripts
@cindex Compiling Scheme scripts
@cindex Binary programs


Scheme programs can be executed by @value{PRJNAME} from both source and
binary formats.

@itemize
@item
To run a Scheme script, a program in source form, we invoke the
executable @value{EXECUTABLE} using the option @option{--r6rs-script} to
select the pathname of the file:

@example
vicare --r6rs-script path/to/script.sps
@end example

@item
To run a compiled Scheme program, we invoke the executable
@value{EXECUTABLE} using the option @option{--binary-program} to select
the pathname of the file:

@example
vicare --binary-program path/to/program
@end example
@end itemize

On @gnu{}+Linux platforms it is possible to execute programs directly
without explicitly invoking the executable, @ref{binfmt, Launching
programs directly on @gnu{}+Linux}.

To compile a source program into binary form, we can use the specific
command line option @option{--compile-program} or the general command
line option @option{--compile} (which can be abbreviated as
@option{-c}).

To compile @file{script.sps} into @file{script.fasl} we can do:

@example
vicare --compile-program script.sps --output script.fasl
@end example

@noindent
the option @option{--compile} recognises input files with extension
@code{.sps} as programs, so we can also do:

@example
vicare --compile script.sps --output script.fasl
@end example

@noindent
or with short options:

@example
vicare -c script.sps -o script.fasl
@end example

There is no need to use the extension @code{.fasl} for binary programs,
so it is recommended to just do:

@example
vicare -o script -c script.sps
@end example

@noindent
or, even shorter:

@example
vicare -c script.sps
@end example

@noindent
which will automatically build the output file name by stripping
@code{.sps} from the input file name; the output file name is created in
the same directory of the input file name.

@c page
@node using rlwrap
@section Using @command{rlwrap}


@cindex @command{rlwrap}


While @value{PRJNAME} comes with an interface to @gnu{} Readline or
compatible library, the @repl{} interaction, as of version 0.2d9, offers
only very basic editing capabilities.  For this reason it is suggested
to use @command{rlwrap}:

@center @url{http://utopia.knoware.nl/~hlub/rlwrap/}

@noindent
to run @value{PRJNAME}'s @repl{} through this shell script:

@smallexample
#!/bin/sh
#
# Vicare Scheme GNU Readline wrapper using Rlwrap.

## Configuration variables.

vicare_PROGRAM=$(type -p vicare)
rlwrap_PROGRAM=$(type -p rlwrap)

COMPLETIONS_FILE=/home/marco/.vicare_completions
COMPLETIONS_OPTION=--file=$@{COMPLETIONS_FILE@}

## Data variables.

# Do NOT include '\!' and '?' in this string.
BREAK_CHARS="\"#'(),;\`\\|[]@{@}"

## Check programs and data files existence.

function error () @{
    local MESSAGE=$@{1:?@}
    printf 'vie error: %s\n' "$@{MESSAGE@}" >&2
    exit 2
@}
function warning () @{
    local MESSAGE=$@{1:?@}
    printf 'vie warning: %s\n' "$@{MESSAGE@}" >&2
@}

test -x "$@{rlwrap_PROGRAM@}" || \
  error "cannot find program 'rlwrap'"
test -x "$@{vicare_PROGRAM@}" || \
  error "cannot find program 'vicare'"

if ! test -f "$@{COMPLETIONS_FILE@}" ; then
    warning "cannot find completions file '$@{COMPLETIONS_FILE@}'"
    COMPLETIONS_OPTION=
fi

## Run.

exec "$@{rlwrap_PROGRAM@}"                    \
    --ansi-colour-aware                     \
    --break-chars=$@{BREAK_CHARS@}            \
    --complete-filenames                    \
    --history-no-dupes=2                    \
    --multi-line                            \
    --prompt-colour='1;31'                  \
    --quote-characters='"'                  \
    --remember                              \
    $@{COMPLETIONS_OPTION@}                   \
    "$@{vicare_PROGRAM@}" --raw-repl "$@@"

### end of file
@end smallexample

@c page
@node using binfmt
@section Launching programs on Linux


When running @value{PRJNAME} on a @gnu{}+Linux system we can take
advantage of the features offered by the @code{binfmt_misc} kernel
module to launch directly executable programs without prefixing the
program name with the @value{EXECUTABLE} executable.

It all comes down to this: after setting up the feature as explained in
the appendix @ref{binfmt}, we write a file containing:

@example
;;;!vicare
(import (only (program-library) main))
(main)
@end example

@noindent
where @library{program-library} is an installed library containing the
application code and @func{main} is the function that starts the
application.  If we enable executable permissions for the file and make
sure that the first bytes in the file are the sequence
@code{;;;!vicare}, we can configure the Linux kernel to start the
program handing its command line to the executable @value{EXECUTABLE}.

@c end of file

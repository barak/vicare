
                      The quest to solve Issue #25
                      ============================

                             by Marco Maggi


This file  documents the quest  to solve Issue  #35, an error  in Vicare
Scheme causing  the generation of  a corrupt Scheme  continuation object
and consequently an  abort of the process.  The causes  of the issue are
low level and  involve the assembly code generated by  the compiler; for
this reason it is difficult to  inspect the problem.  This document is a
work-in-progress explanation of the issue causes and implemented fixes.

  The short  version: once upon a  time Ikarus Scheme did  not have post
garbage collection  hooks and  everything was  fine; then  post-GC hooks
were introduced and problems arised in some rare situations; then Vicare
Scheme  started to  use  post-GC hooks  everywhere  and problems  arised
frequently.


The problem
-----------

Whenever a request  to create a Scheme continuation object  is served by
Scheme  code, the  Scheme  stack can  be  in one  of  the following  two
situations:

1. The frame pointer register references the frame base of the stack:

            high memory
     |                      | <-- pcb->frame_base
     |----------------------|
     | ik_underflow_handler | <-- FPR
     |----------------------|
     |       argument       |
     |----------------------|
               ...
     |----------------------|
     |      free word       | <-- pcb->stack_base
     |----------------------|
     |                      |
            low memory

   in this  case it is *wrong*  to create a continuation  object because
   the Scheme  stack is empty.   Rather we  should just accept  the last
   continuation object pushed on the "pcb->next_k" list.

2. There are some frames on the stack:

           high memory
     |                      | <-- pcb->frame_base
     |----------------------|
     | ik_underflow_handler |
     |----------------------|
       ... other frames ...
     |----------------------|          --
     |     local value 1    |          .
     |----------------------|          .
     |     local value 1    |          . frame 1
     |----------------------|          .
     |   return address 1   |          .
     |----------------------|          --
     |     local value 0    |          .
     |----------------------|          .
     |     local value 0    |          . frame 0
     |----------------------|          .
     |   return address 0   | <-- FPR  .
     |----------------------|          --
     |      argument        |
     |----------------------|
               ...
     |----------------------|
     |      free word       | <-- pcb->stack_base
     |----------------------|
     |                      |
            low memory

   in this case it  is perfectly fine to freeze the  stack frames into a
   continuation object and to update the stack as follows:

           high memory
     |                      |
     |----------------------|
     | ik_underflow_handler |
     |----------------------|                     --
       ... other frames ...                       .
     |----------------------|                     .
     |     local value 0    |                     . freezed
     |----------------------|                     . frames
     |     local value 0    |                     .
     |----------------------|                     .
     |    return address 0  | <- pcb->frame_base  .
     |----------------------|                     --
     | ik_underflow_handler | <- FPR
     |----------------------|
     |         kont         | -> continuation object
     |----------------------|
               ...
     |----------------------|
     |      free word       | <- pcb->stack_base
     |----------------------|
     |                      |
            low memory

  Portions of  the code involved  in creating a new  continuation object
are copied below (slightly edited):

   (define (%primitive-call/cf func)
     (if ($fp-at-base)
         (func ($current-frame))
       ($seal-frame-and-call func)))

   (define-primop $seal-frame-and-call unsafe
     ((V func)
      (with-tmp*
          ((kont (prm 'alloc-no-hooks
	              (K continuation-size)
	              (K vector-tag)))
           (base (prm 'int+
                      (prm 'mref pcr (K pcb-frame-base))
                      (K (- wordsize))))
           (underflow-handler (prm 'mref base (K 0))))
        (prm 'mset kont (K off-continuation-tag)
	     (K continuation-tag))
        (prm 'mset kont (K off-continuation-top)
	     fpr)
        (prm 'mset kont (K off-continuation-size)
	     (prm 'int- base fpr))
        (prm 'mset kont (K off-continuation-next)
	     (prm 'mref pcr (K pcb-next-continuation)))
        (prm 'mset pcr (K pcb-next-continuation) kont)
        (prm 'mset pcr (K pcb-frame-base) fpr)
        (prm '$call-with-underflow-handler
	     underflow-handler (T func) kont)))
     ((E . args)
      (interrupt))
     ((P . args)
     (interrupt)))

   (define (do-overflow n)
     (foreign-call "ik_collect" n)
     (let ((ls (post-gc-hooks)))
       (unless (null? ls)
         (do-post-gc ls n)))
     #t)

we see  the function  %PRIMITIVE-CALL/CF testing  for the  frame pointer
being at  the frame base of  the stack or not,  and performing different
actions accordingly.

  Notice  especially  that: upon  entering  the  code of  the  primitive
operation  $SEAL-FRAME-AND-CALL it  has  already been  decided that  the
frame pointer  is *not* at  the base of  the Scheme stack;  if something
that moves  the frame pointer away  from its position happens,  an error
occurs.  This is  the cause of Issue #35; until  now two probable causes
have been uncovered.


Cause 1: The function DO-OVERFLOW must return 1 value
-----------------------------------------------------

Whenever a Scheme  object is created by Scheme code:  a region of memory
is reserved to it on the Scheme heap.  If the Scheme heap has not enough
free space or,  more precisely, if the  amount of free space  is below a
fixed amount: a  garbage collection is triggered to  reclaim memory and,
if there  is the  need, to  allocate new memory  pages that  enlarge the
heap.

  The  assembly code  performing memory  allocation checks  if there  is
enough  room in  the heap;  if there  is not:  it jumps  to an  assembly
subroutine that  calls the  Scheme function  DO-OVERFLOW, then  it jumps
back and moves on allocating  memory.  The function DO-OVERFLOW performs
the memory allocation and executes the post-GC hooks.

  The Scheme  function call  to DO-OVERFLOW has  nothing special,  it is
implemented  with the  usual call  table; here  is the  assembly of  the
subroutine inside the function %PRIMITIVE-CALL/CF for a 32-bit i686 CPU:

   (label perform-garbage-collection)
   ;;Upon arriving here the scenario of the Scheme stack is:
   ;;
   ;;        high memory
   ;;   |                  |
   ;;   |------------------|
   ;;   |  return address  | <- esp
   ;;   |------------------|
   ;;   |     closure      | <- esp - wordsize = esp - 4
   ;;   |------------------|
   ;;   |                  | <- esp - 2*wordsize = esp - 8
   ;;   |------------------|
   ;;   |                  | <- esp - 3*wordsize = esp - 12
   ;;   |------------------|
   ;;   |                  |
   ;;        low memory
   ;;
   ;;where CLOSURE is the argument to %PRIMITIVE-CALL/CF.

   ;;Put on the stack the size of a continuation object (4 machine
   ;;words).
   (movl 16 (disp -12 %esp))
   ;;Load in EAX the the reference to closure object of DO-OVERFLOW...
   (movl (disp (obj do-overflow) 11) %eax)
   ;;...and put it in the Closure Pointer Register (CPR=EDI).
   (movl %eax %edi)

   ;;Load in EAX the encoded number of arguments for the call to
   ;;DO-OVERFLOW (the fixnum -1, raw value -4).
   (movl -4 %eax)

   ;;Adjust the stack pointer to reference the machine word right
   ;;above the first free word.
   (subl 4 %esp)

   ;;Upon arriving here the scenario on the Scheme stack is:
   ;;
   ;;        high memory
   ;;   |                  |
   ;;   |------------------|
   ;;   |  return address  |
   ;;   |------------------|
   ;;   |     closure      | <- esp
   ;;   |------------------|
   ;;   |                  |
   ;;   |------------------|
   ;;   | cont object size |
   ;;   |------------------|
   ;;   |                  |
   ;;        low memory
   ;;
   ;;everything is ready to perform the "call" instruction.

   ;;Jump to the call instruction.
   (jmp (label L24))

   ;;This is the call table.  Notice that the label for 0, 2 or multiple
   ;;return values is the special assembly routine that ignores the
   ;;returned values.
   (byte-vector #(2))
   (int 8)
   (current-frame-offset)
   (label-address SL_multiple_values_ignore_rp)

   ;;Perform the call to DO-OVERFLOW.
   (pad 5 (label L24) (call (disp -3 %edi)))

   ;;Right after the "call" instruction, the scenario on the Scheme
   ;;stack is:
   ;;
   ;;        high memory
   ;;   |                  |
   ;;   |------------------|
   ;;   |  return address  |
   ;;   |------------------|
   ;;   |     closure      |
   ;;   |------------------|
   ;;   |  return address  | <- esp
   ;;   |------------------|
   ;;   | cont object size |
   ;;   |------------------|
   ;;   |                  |
   ;;        low memory
   ;;
   ;;and upon coming back here after DO-OVERFLOW has returned 1 value,
   ;;the scenario is:
   ;;
   ;;        high memory
   ;;   |                  |
   ;;   |------------------|
   ;;   |  return address  |
   ;;   |------------------|
   ;;   |     closure      | <- esp
   ;;   |------------------|
   ;;   |       #t         |
   ;;   |------------------|
   ;;   |                  |
   ;;        low memory
   ;;

   ;;Readjust the stack pointer so that it references the return value
   ;;of the call to %PRIMITIVE-CALL/CF.
   (addl 4 %esp)

   ;;Upon arriving here the scenario on the Scheme stack is:
   ;;
   ;;        high memory
   ;;   |                  |
   ;;   |------------------|
   ;;   |  return address  | <- esp
   ;;   |------------------|
   ;;   |     closure      |
   ;;   |------------------|
   ;;   |        #t        |
   ;;   |------------------|
   ;;   |                  |
   ;;        low memory
   ;;
   ;;and the heap has room for the continuation object.

   ;;Jump back to the assembly code that will perform the Scheme
   ;;continuation object allocation.
   (jmp (label allocation-point))

  So everything is all right if DO-OVERFLOW returns 1 value; but the
original function from Ikarus Scheme is:

   (define do-overflow
     (lambda (n)
       (foreign-call "ik_collect" n)
       (let ([ls (post-gc-hooks)])
         (unless (null? ls)
	   (do-post-gc ls n)))))

so the return value is: whatever UNLESS returns when the test is true or
the return  value of DO-POST-GC; there  is no guarantee that  such forms
return 1 value.

  What happens if, for example, DO-OVERFLOW returns zero values?  Rather
than jumping back right after the "call" instruction, the execution flow
jumps to the label  "SL_multiple_values_ignore_rp", which is an assembly
routine implemented as follows:

   (label SL_multiple_values_ignore_rp)
   (ret)

so there is no stack pointer adjustment:

   (addl 4 %esp) ;missing!!!

and the stack pointer register is left in the wrong position.

  This  problem was  addressed  by adding  the return  value  #t to  the
function DO-OVERFLOW.

  Notice that a function implementation without post-GC hooks:

   (define do-overflow
     (lambda (n)
       (foreign-call "ik_collect" n)))

does not cause problems, because FOREIGN-CALL always returns 1 value (by
definition).


Cause 2: The post-GC hooks may change the stack
-----------------------------------------------

After running the garbage  collection, the function DO-OVERFLOW executes
the post-GC hooks;  such functions can do almost  everything to finalise
the   values  collected   into   guardians.    This  includes   creating
continuation objects that seal the frames on the stack.

  It can happen that: after entering the execution of %PRIMITIVE-CALL/CF
and having determined that the frame  pointer is *not* at the frame base
of the stack, a post-GC hook creates some continuation objects; whenever
the  execution   flow  goes  back  to   $SEAL-FRAME-AND-CALL  the  stack
pointer  *is* at  the base  of the  stack and  a corrupted  continuation
object is created.

  The original Ikarus  Scheme code allocates the  continuation object in
%PRIMITIVE-CALL/CF with:

   (prm 'alloc (K continuation-size) (K vector-tag))

which  causes the  function DO-OVERFLOW  to be  called if  there is  not
enough room in the heap; DO-OVERFLOW executes the post-GC hooks.

  The code has been fixed to:

   (prm 'alloc-no-hooks (K continuation-size) (K vector-tag))

where the new primitive ALLOC-NO-HOOKS directly performs:

   (foreign-call "ik_collect" n)

without calling DO-OVERFLOW and without running the post-GC hooks.


### end of file
# Local Variables:
# mode: text
# coding: utf-8-unix
# fill-column: 72
# paragraph-start: "*"
# End:

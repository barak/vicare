@node iklib
@chapter Language extensions


@cindex Library @library{vicare}
@cindex @library{vicare}, library
@cindex Library @library{vicare language-extensions}
@cindex @library{vicare language-extensions}, library


In addition to the libraries listed in the @rnrs{6} standard,
@value{PRJNAME} offers more libraries which provide additional features;
here is a list of some of them:

@table @asis
@item @library{vicare}
It is a composite library, it exports a superset of all the supported
bindings of @rnrs{6}.

@item @library{vicare language-extensions}
It exports all the bindings exported by @library{vicare} that are
@strong{not} exported by @library{rnrs (6)}.

@item @library{vicare platform constants}
Exports one syntax identifier binding for each platform constant that
makes sense to access from Scheme.

@item @library{vicare platform utilities}
Defines helper functions to deal with platform specific issues;
@libsref{platform, Hosting platform utilities} for details.

@item @library{vicare platform features}
@cindex Library @library{vicare platform features}
@cindex @library{vicare platform features}, library
Exports an identifier syntax for every @code{HAVE_} symbol defined by
the configuration script @command{configure}; such syntaxes expand to a
boolean value: @true{} if the feature is available, @false{} otherwise.
@end table

@menu
* iklib progname::              Finding the @value{EXECUTABLE} executable.
* iklib config::                Configuration options inspection.
* iklib cmdline::               Command line arguments.
* iklib env-inquiry::           Environment inquiry.
* iklib syntaxes::              Additional syntaxes.
* iklib unwind-protect::        The unwind--protection mechanism.
* iklib compensations::         Compensation stacks.
* iklib coroutines::            Running coroutines.
* iklib conditions::            Additional condition types.
* iklib reader::                Extensions to the reader.
* iklib expander::              Interface to the expander.
* iklib shared::                Shared structures graph notation.
* iklib environment::           Environments.
* iklib cafe::                  Cafe.
* iklib structs::               Structures and type descriptors.
* iklib records::               Extensions to @rnrs{6} records.
* iklib promises::              Delay, force and promises.
* iklib characters::            Additional character functions.
* iklib keywords::              Keyword objects.
* iklib lists::                 Additional list functions.
* iklib bytevectors::           Additional bytevector functions.
* iklib strings::               Additional string functions.
* iklib vectors::               Additional vector functions.
* iklib symbols::               Additional symbol functions.
* iklib fixnums::               Additional functions on fixnums.
* iklib flonums::               Additional functions on flonums.
* iklib numerics::              Additional functions on numbers.
* iklib enumerations::          Additional functions on enumerations.
* iklib hashtables::            Additional functions on hashtables.
* iklib load::                  Loading source files.
* iklib modules::               Local modules.
* iklib libraries::             Local libraries.
* iklib parameters::            Parameters.
* iklib gensym::                Gensyms.
* iklib printing::              Printing.
* iklib tracing::               Tracing for debugging.
* iklib timing::                Timing.
* iklib gc::                    Interfacing with garbage collection.
* iklib guardians::             Guardians and garbage collection.
* iklib io::                    Input/output library.
* iklib pointers::              Handling pointer objects.
* iklib memory::                Memory management.
* iklib cstrings::              Raw C strings.
* iklib errno::                 Interface to @code{errno}.
* iklib time::                  Basic time and date functions.
* iklib readline::              Readline interface.
* iklib debug::                 Debugging utilities.
* iklib misc::                  Miscellaneous functions.
@end menu

@c page
@node iklib progname
@section Finding the @value{EXECUTABLE} executable


The following bindings are exported by the library @library{vicare}.


@defun vicare-argv0
Return a bytevector holding the C string in the @code{argv[0]} argument
to the @cfunc{main} function of the current @value{PRJNAME} process.
@end defun


@defun vicare-argv0-string
Return a Scheme string holding the C string in the @code{argv[0]}
argument to the @cfunc{main} function of the current @value{PRJNAME}
process.
@end defun

@c page
@node iklib config
@section Configuration options inspection


The following bindings are exported by the library @library{vicare}.


@defun vicare-built-with-arguments-validation-enabled
Return @true{} if the package was installed along with procedure
arguments validation enabled; otherwise return @false{}.
@end defun


@defun vicare-built-with-srfi-enabled
Return @true{} if the package was installed along with the @srfi{}
libraries; otherwise return @false{}.
@end defun


@defun vicare-built-with-iconv-enabled
Return @true{} if the package was configured with bindings to Libiconv
enabled; otherwise return @false{}.
@end defun


@defun vicare-built-with-ffi-enabled
Return @true{} if the package was configured with bindings to Libffi
enabled; otherwise return @false{}.
@end defun


@defun vicare-built-with-posix-enabled
Return @true{} if the package was configured with @posix{} features
enabled; otherwise return @false{}.
@end defun


@defun vicare-built-with-glibc-enabled
Return @true{} if the package was configured with @gnu{} C Library
features enabled; otherwise return @false{}.
@end defun


@defun vicare-built-with-linux-enabled
Return @true{} if the package was configured with Linux features
enabled; otherwise return @false{}.
@end defun

@c page
@node iklib cmdline
@section Command line arguments


The following bindings are exported by the library @library{vicare}.


@deffn Parameter command-line-arguments
Hold the value returned by @func{command-line} as defined by @rnrs{6}.
It is initialised to the actual command line arguments from the
@value{PRJNAME} process execution.
@end deffn

@c page
@node iklib env-inquiry
@section Environment inquiry


@defun host-info
Return a string being the value @gnu{} Autoconf assigned to the
@code{target} variable.  Examples: @code{i686-pc-linux-gnu},
@code{x86_64-unknown-linux-gnu}.
@end defun


The @posix{} function @cfunc{uname} fills a data structure of type
@code{struct utsname} with strings representing a description of the
underlying platform.  @value{PRJNAME} defines objects of type
@code{utsname} to provide at the Scheme level such informations;
@code{utsname} objects are disjoint from all the other types.


@defun uname
Interface to the C function @cfunc{uname}, @manpage{uname, Get name and
information about current kernel}.  Build and return a new object of
type @code{utsname}.  If successful return the object, otherwise raise
an exception.
@end defun


@defun utsname? @var{obj}
Return @true{} if @var{obj} is an object of type @code{utsname},
otherwise return @false{}.
@end defun


@defun utsname-sysname @var{utsname}
@defunx utsname-nodename @var{utsname}
@defunx utsname-release @var{utsname}
@defunx utsname-version @var{utsname}
@defunx utsname-machine @var{utsname}
Accessors for the fields of the @var{utsname} object.  All the returned
values are strings.
@end defun


The following bindings are specified by @ansrfi{112}, exported by
@library{vicare} and reexported by the @srfi{}'s libraries,
@libsref{srfi env-inquiry spec, Specification}.

@defun implementation-name
Return the string @code{"vicare-scheme"}.
@end defun


@defun implementation-version
Return the @value{PRJNAME} version string.  Example:

@example
(import (vicare))
(implementation-version)        @result{} "0.3d4"
@end example
@end defun


@defun cpu-architecture
Return a Scheme string representing the contents of the field
@code{machine} of the @code{struct utsname} filled by @cfunc{uname}.
Example:

@example
(import (vicare))
(cpu-architecture)      @result{} "x86_64"
@end example
@end defun


@defun machine-name
Return a Scheme string representing the contents of the field
@code{nodename} of the @code{struct utsname} filled by @cfunc{uname}.
Example:

@example
(import (vicare))
(machine-name)          @result{} "governatore"
@end example
@end defun


@defun os-name
Return a Scheme string representing the contents of the field
@code{sysname} of the @code{struct utsname} filled by @cfunc{uname}.
Example:

@example
(import (vicare))
(os-name)               @result{} "Linux"
@end example
@end defun


@defun os-version
Return a Scheme string representing the contents of the field
@code{version} of the @code{struct utsname} filled by @cfunc{uname}.
Example:

@example
(import (vicare))
(os-version)
@result{} "#2 SMP Mon Sep 17 14:19:22 CDT 2012"
@end example
@end defun

@c page
@node iklib syntaxes
@section Additional syntaxes


@menu
* iklib syntaxes libraries::    Extended @code{library} syntax.
* iklib syntaxes programs::     Extended program syntax.
* iklib syntaxes lambdas::      @func{lambda}-like additional syntaxes.
* iklib syntaxes defines::      @func{define}-like additional syntaxes.
* iklib syntaxes defstxs::      @func{define-syntax}-like additional syntaxes.
* iklib syntaxes bindings::     Additional binding syntaxes.
* iklib syntaxes control::      Additional control flow syntaxes.
* iklib syntaxes loops::        Additional loop syntaxes.
* iklib syntaxes returnable::   Early return from code blocks.
* iklib syntaxes blocking::     Blocking raised exceptions.
* iklib syntaxes dynenv::       Capturing the current dynamic
                                environment.
* iklib syntaxes integrable::   Integrable expressions and functions.
* iklib syntaxes stale::        Declaring compiled library in
                                stale state.
* iklib syntaxes include::      Including source files at expand time.
* iklib syntaxes body::         Internal body.
* iklib syntaxes types::        Type syntaxes.
* iklib syntaxes predicates::   Predicate syntaxes.
* iklib syntaxes slots::        Slot getter and setter syntaxes.
* iklib syntaxes try::          The @func{try}, @func{catch}, @func{finally} syntaxes.
* iklib syntaxes splice1st::    Splice first form syntax.
* iklib syntaxes increments::   Incrementing and decrementing.
* iklib syntaxes infix::        Infix to prefix transformer.
* iklib syntaxes misc::         Miscellaneous syntaxes.
* iklib syntaxes properties::   Syntactic binding properties.
* iklib syntaxes predaux::      Predicate auxiliary functions.
* iklib syntaxes type-of::      Determining the type of expressions.
* iklib syntaxes expansion-of:: Inspecting expansion results.
* iklib syntaxes optim-of::     Inspecting optimisation results.
* iklib syntaxes assembly-of::  Inspecting assembly language results.
@end menu

@c page
@node iklib syntaxes libraries
@subsection Extended @code{library} syntax


@cindex @clause{options}, library clause
@cindex Library clause @clause{options}


@value{PRJNAME} extends the format of @code{library} forms by allowing
an optional @clause{options} clause:

@example
(libary @meta{libary-name}
  (options @meta{option} ...)
  (export  @meta{export-spec} ...)
  (import  @meta{import-spec} ...)
  @meta{library-body})
@end example

@noindent
where each @meta{option} is a symbolic expression.


@defvr {Library Option} visit-upon-loading
Forces invoking and visiting a library upon its loading from the source
or compiled file.

The @rnrs{6} allows, and @value{PRJNAME} implements, a form of lazy
evaluation of library code; an imported library is loaded but:

@itemize
@item
Its code for run--time (the ``invoke code'' in @value{PRJNAME}'s jargon)
is evaluated only when an exported variable is referenced in the
importing code.

@item
Its code for expand--time (the ``visit code'' in @value{PRJNAME}'s
jargon) is evaluated only when an exported syntax is first referenced in
the importing code.
@end itemize

@noindent
This is the default operations mode for @value{PRJNAME}.  This library
option rejects this lazy mode, requesting that this library is visited
when the library is loaded; visiting a library implies invoking it.

This option is especially useful when the library assigns properties to
syntactic bindings (@pxref{iklib syntaxes properties}) and when adding
methods to Nausicaa's multimethods.
@end defvr


@defvr {Library Option} tagged-language
Turn on the tagged language extensions, @ref{tags, Tagged language}.
@end defvr

@c page
@node iklib syntaxes programs
@subsection Extended program syntax


@cindex @clause{options}, program clause
@cindex Program clause @clause{options}


@value{PRJNAME} extends the format of programs by allowing an optional
@clause{options} clause after the @clause{import} one:

@example
(import  @meta{import-spec} ...)
(options @meta{option} ...)
@meta{program-body}
@end example

@noindent
where each @meta{option} is a symbolic expression.


@defvr {Library Option} tagged-language
Turn on the tagged language extensions, @ref{tags, Tagged language}.
@end defvr

@c page
@node iklib syntaxes lambdas
@subsection @func{lambda}--like additional syntaxes


The syntaxes @func{lambda*} and @func{case-lambda*} are similar to
@func{lambda} and @func{case-lambda} as defined by @rnrs{6}, but they
allow the selection of predicate functions to validate the arguments and
the return value; a predicate function accepts a single argument and
returns true or @false{}.  Examples:

@example
#!vicare
(import (vicare)
  (vicare system $fx))

(define add
  ;;Fail if called with a non-fixnum argument.
  (lambda* (@{a fixnum?@} @{b fixnum?@})
    ($fx+ a b)))

(define vec
  ;;Fail if attempting to return a non-vector.
  (lambda* (@{_ vector?@} fun)
    (fun 1 2)))

(add 1 2)       @result{} 3
(add 1 #\2)     @error{} &procedure-argument-violation

(vec vector)    @result{} #(1 2)
(vec list)      @error{} &expression-return-value-violation
@end example

@noindent
in the definition of the function bound to @func{vec}: notice that
@code{@{_ vector?@}} is not a function argument, it is a special
notation used to select a predicate function to validate the return
value.

In the extended @func{lambda*} and @func{case-lambda*} syntaxes the
@meta{pred-formals} can have any of the forms:

@example
(@meta{var} ...)
(@metao{var} @meta{var} ... . @meta{rest})
@meta{args}
@end example

Where in the standard @func{lambda} and @func{case-lambda} syntaxes an
identifier is used to name a formal argument, in the extended
@func{lambda*} and @func{case-lambda*} syntaxes each formal argument
@meta{var} can have any of the forms:

@example
@meta{id}
(brace @meta{id} @meta{pred})
@end example

@noindent
where @meta{id} is an identifier naming the formal argument; @meta{pred}
is an identifier which, at run time, must evaluate to a predicate
function; @func{brace} is the binding exported by @library{vicare}.  The
formal argument @meta{rest} can have only one of the following forms:

@example
@meta{rest-id}
(brace @meta{rest-id} @meta{pred})
@end example

@noindent
and the formal argument @meta{args} can have one of the following forms:

@example
@meta{args-id}
(brace @meta{args-id} @meta{pred})
@end example

The first item in the @meta{pred-formals} can have the special syntax:

@example
(brace _ @metao{pred} @meta{pred} ...)
@end example

@noindent
where @code{_} is the binding exported by @rsixlibrary{base}; in this
case such item does @strong{not} represent a formal argument, it just
selects predicates to validate the values returned by the last
@meta{body} form.

@c ------------------------------------------------------------

@deffn Syntax lambda* @meta{pred-formals} @metao{body} @meta{body} @dots{}
Like the standard @func{lambda} and additionally allows the selection of
predicate functions to validate the arguments and the return value.  The
formal arguments are handled according to the following rules:

@itemize
@item
When all the items in @meta{pred-formals} are as specified for the
standard @func{lambda}: this syntax is equivalent to @func{lambda} as
defined by @rnrs{6}.

@item
If the boot image has been compiled with procedure arguments validation
@strong{enabled}, and @meta{pred-formals} selects predicates to validate
the arguments: if a predicate fails for its formal argument, an
exception is raised using @condition{procedure-argument-violation}.

@item
If the boot image has been compiled with procedure arguments validation
@strong{disabled}, the predicate selections in @meta{pred-formals} are
ignored and @func{lambda*} behaves like the standard @func{lambda}.

@item
If the first element of @meta{pred-formals} has the format:

@example
(brace _ @metao{pred} @meta{pred} ...)
@end example

@noindent
the values returned by the last @meta{body} form are validated using the
given @meta{pred}: if a predicate fails for its returned value, an
exception is raised using @condition{expression-return-value-violation}.
@end itemize

In addition the fluid identifier syntax @code{__who__} is bound to the
quoted symbol @code{_}.

Usage examples:

@itemize
@item
Function with two predicate arguments:

@example
#!vicare
(import (vicare))
(define f
  (lambda* (@{a number?@} @{b number?@})
    (list (number->string a) (number->string b))))

(f 1 2)         @result{} ("1" "2")
@end example

@item
Function with two mandatory arguments and the rest argument:

@example
#!vicare
(import (vicare))

(define (list-of-numbers? obj)
  (and (list? obj)
       (for-all number? obj)))

(define f
  (lambda* (@{a number?@} @{b number?@}
            . @{rest list-of-numbers?@})
    (list (number->string a)
          (number->string b)
          (length rest))))

(f 1 2 3 4 5)           @result{} ("1" "2" 3)
@end example

@item
Function with the @meta{args} argument:

@example
#!vicare
(import (vicare))

(define (list-of-numbers? obj)
  (and (list? obj)
       (for-all number? obj)))

(define f
  (lambda* @{args list-of-numbers?@}
    (length args)))

(f 1 2 3)               @result{} 3
@end example

@item
Function with a single validated return value:

@example
#!vicare
(import (vicare))

(define f
  (lambda* (@{_ fixnum?@} val)
    val))

(f 1)                   @result{} 1
@end example

@item
Function with multiple validated return values:

@example
#!vicare
(import (vicare))

(define f
  (lambda* (@{_ fixnum? string?@} a b)
    (values a b)))

(f 1 "2")               @result{} 1, "2"
@end example
@end itemize
@end deffn

@c ------------------------------------------------------------

@deffn Syntax case-lambda* @meta{pred-cl-clause} @dots{}
Like the standard @func{case-lambda} and additionally allows the
selection of predicate functions to validate the arguments and the
return value.  Clause by clause the formals are handled as explained for
@func{lambda*}.

In addition the fluid identifier syntax @code{__who__} is bound to the
quoted symbol @code{_}.

Usage examples:

@example
#!vicare
(import (vicare))

(define f
  (case-lambda*
   ((@{a number?@})
    (number->string a))))

(define g
  (case-lambda*
   (@{args list?@}
    (length args))))

(f 123)                 @result{} "123"
(g 1 2 3)               @result{} 3
@end example
@end deffn

@c page
@node iklib syntaxes defines
@subsection @func{define}--like additional syntaxes


@deffn Syntax case-define @meta{who} @metao{cl-clause} @meta{cl-clause} @dots{}
Convenience syntax which expands as follows:

@example
(case-define @meta{who} @metao{cl-clause} @meta{cl-clause} @dots{})
@expansion{} (define @meta{who}
      (case-lambda @metao{cl-clause} @meta{cl-clause} @dots{}))
@end example
@end deffn


@deffn Syntax define* @meta{who} @meta{expression}
@deffnx Syntax define* @meta{who}
@deffnx Syntax define* (@meta{who} . @meta{formals}) @metao{body} @meta{body} @dots{}
@deffnx Syntax define* (@meta{pred-who} . @meta{formals}) @metao{body} @meta{body} @dots{}
Like the standard @func{define} as defined by @rnrs{6}, but when
defining a function: allow the selection of predicate functions to
validate the arguments and the return value.

Predicates selections is performed as explained for the @func{lambda*}
extended syntax, @ref{iklib syntaxes lambdas, @func{lambda}--like
additional syntaxes}.  There is an exception, where @func{lambda*} uses
the @code{_} symbol to select predicates for the returned values,
@func{define*} uses the binding identifier @meta{who}.

In addition, when defining a function, the fluid identifier syntax
@code{__who__} is bound to the quoted symbol @meta{who}.

Usage examples:

@itemize
@item
Function with two predicate arguments:

@example
#!vicare
(import (vicare))

(define* (f @{a number?@} @{b number?@})
  (list (number->string a) (number->string b)))

(f 1 2)         @result{} ("1" "2")
@end example

@item
Function with two mandatory arguments and the rest argument:

@example
#!vicare
(import (vicare))

(define (list-of-numbers? obj)
  (and (list? obj)
       (for-all number? obj)))

(define* (f @{a number?@} @{b number?@}
            . @{rest list-of-numbers?@})
  (list (number->string a)
        (number->string b)
        (length rest)))

(f 1 2 3 4 5)           @result{} ("1" "2" 3)
@end example

@item
Function with the @meta{args} argument:

@example
#!vicare
(import (vicare))

(define (list-of-numbers? obj)
  (and (list? obj)
       (for-all number? obj)))

(define* (f . @{args list-of-numbers?@})
  (length args))

(f 1 2 3)               @result{} 3
@end example

@item
Function with a single validated return value:

@example
#!vicare
(import (vicare))

(define* (@{f fixnum?@} val)
  val)

(f 1)                   @result{} 1
@end example

@item
Function with multiple validated return values:

@example
#!vicare
(import (vicare))

(define* (@{f fixnum? string?@} a b)
  (values a b))

(f 1 "2")               @result{} 1, "2"
@end example

@item
Accessing the function name:

@example
(import (vicare))

(define* (f)
  __who__)

(f)     @result{} f
@end example
@end itemize
@end deffn

@c ------------------------------------------------------------

@deffn Syntax case-define* @meta{who} @metao{pred-cl-clause} @meta{case-clause} @dots{}
Convenience syntax that expands to something similar to:

@example
(case-define* @meta{whoe} @metao{pred-cl-clause} @meta{pred-cl-clause} @dots{})
@expansion{} (define @meta{who}
      (case-lambda* @metao{pred-cl-clause} @meta{pred-cl-clause} @dots{}))
@end example

In addition the fluid identifier syntax @code{__who__} is bound to the
quoted symbol @meta{who}.
@end deffn

@c ------------------------------------------------------------

@deffn Syntax define-values @meta{formals} @metao{form} @meta{form} @dots{}
Evaluate the given forms and bind the, possibly multiple, result of the
last one to the given @meta{var} identifiers.  @var{formals} has the
same syntax of the @func{lambda} formals.

@example
(define-values (a b c)
  (values 1 2 3))

(list a b c)    @result{} (1 2 3)
@end example
@end deffn


@deffn Syntax define-constant-values @var{formals} @metao{form} @meta{form} @dots{}
Evaluate the given forms and bind the, possibly multiple, result of the
last one to the given formals identifiers; make the formals identifiers
immutable.  @var{formals} has the same syntax of the @func{lambda}
formals.

@example
(define-constant-values (a b c)
  (values 1 2 3))

(list a b c)    @result{} (1 2 3)
(set! a 99)     @error{} &syntax
@end example
@end deffn


@deffn Syntax define-inline (@meta{name} @meta{arg} @dots{} . @meta{rest}) @metao{body} @meta{body} @dots{}
Similar to @func{define}, but create a binding that is always expanded
inline and can @strong{neither} be invoked recursively @strong{nor} used
as function rgument.  This syntax only defines a syntax.

@example
(define-inline (incr x)
  (+ x 1))

(incr 2)        @result{} 3
@end example

In the example above, we can think of @code{(incr 2)} as expanding to:

@example
(let ((x 2))
  (+ x 1))
@end example
@end deffn


@deffn Syntax define-inline-constant @meta{name} @meta{expr}
@meta{expr} is evaluated only once at expand time, the result is
returned by the macro transformer bound to @meta{name}.  It is
impossible to modify the result of the expansion of @meta{name} by
acting upon @meta{name}.
@end deffn


@deffn Syntax define-integrable (@meta{name} @meta{arg} @dots{} . @meta{rest}) @metao{body} @meta{body} @dots{}
Similar to @func{define}, but create a binding that is always expanded
inline and @strong{can} be both invoked recursively and used as function
argument.  This syntax defines both a syntax and a function.

@example
(define-integrable (incr x)
  (+ x 1))

(incr 2)
@result{} 3

(map incr '(10 20 30)))
@result{} (11 21 31)
@end example

In the example above, we can think of @code{(incr 2)} as expanding to:

@example
((lambda (x)
   (+ x 1))
 2)
@end example
@end deffn

@c page
@node iklib syntaxes defstxs
@subsection @func{define-syntax}--like additional syntaxes


@deffn Syntax define-syntax @meta{name}
@deffnx Syntax define-syntax @meta{name} @meta{transformer}
@deffnx Syntax define-syntax (@meta{name} @meta{arg}) @metao{body} @meta{body} @dots{}
Like @func{define-syntax} defined by @rnrs{6}, but additionally accepts
the syntax:

@example
(define-syntax (@meta{name} @meta{arg}) @metao{body} @meta{body} @dots{})
@expansion{} (define-syntax @meta{name} (lambda (@meta{arg}) @metao{body} @meta{body} @dots{}))
@end example

@noindent
and the syntax:

@example
(define-syntax @meta{name})
@expansion{} (define-syntax @meta{name} (syntax-rules ()))
@end example
@end deffn


@deffn Syntax define-syntax* @meta{name}
@deffnx Syntax define-syntax* @meta{name} @meta{transformer}
@deffnx Syntax define-syntax* (@meta{name} @meta{arg}) @metao{body} @meta{body} @dots{}
Like @func{define-syntax} defined by Vicare.  Additionally, when the
last form is used: the fluid identifier syntax @code{__who__} is bound
to @meta{name}; the non-hygienic binding @func{synner} is introduced and
bound to a function.

@example
(define-syntax* (@meta{name} @meta{arg}) @metao{body} @meta{body} @dots{})
@expansion{} (define-syntax* (@meta{name} @meta{arg})
      (fluid-let-syntax
          ((__who__ (identifier-syntax (quote @meta{name}))))
        (letrec
            ((synner (case-lambda
                       ((message)
                        (synner message #f))
                       ((message subform)
                        (syntax-violation __who__
                           message @meta{arg} subform)))))
          @metao{body} @meta{body} @dots{})))
@end example
@end deffn


@deffn Syntax define-constant @meta{var} @meta{expr}
Like @func{define} but create an immutable binding.

@example
(define-constant X 1)
X               @result{} 1
(set! X 2)      @error{} &syntax
@end example
@end deffn


@deffn Syntax define-syntax-rule (@meta{name} @meta{pattern} @dots{} . @meta{rest}) @metao{body} @meta{body} @dots{}
Convenience syntax to define a @func{syntax-rules} transformer with a
single clause.  Expand to:

@example
(define-syntax-rule (@meta{name} @meta{pattern} @dots{} . @meta{rest})
  @metao{body} @meta{body} @dots{})
@expansion{} (define-syntax @meta{name}
      (syntax-rules ()
        ((_ @meta{pattern} @dots{} . @meta{rest})
         (begin @metao{body} @meta{body} @dots{}))))
@end example
@end deffn


@deffn Syntax define-auxiliary-syntaxes @metao{name} @meta{name} @dots{}
Define auxiliary syntaxes to be used as literal identifiers by
@func{syntax-rules}, @func{syntax-case} and similar macros; expand to:

@example
(define-syntax @metao{name} (syntax-rules ()))
(define-syntax @meta{name}  (syntax-rules ()))
@dots{}
@end example
@end deffn


@deffn Syntax define-alias @meta{alias-id} @meta{old-id}
Define a new binding for @meta{alias-id} as an alias for @meta{old-id},
which must be a bound identifier in the current lexical environment.

@example
(let ((a 1))
  (define-alias b a)
  b)
@result{} 1
@end example
@end deffn

@c page
@node iklib syntaxes bindings
@subsection Additional binding syntaxes


@deffn Syntax receive @meta{formals} @meta{expression} @metao{body} @meta{body} @dots{}
Expect @meta{expression} to evaluate to multiple values and bind such
values as specified by the @meta{formals}; evaluate the @meta{body} in
the region of such bindings.  The expansion is:

@example
(receive @meta{formals}
    @meta{expression}
  @metao{body} @meta{body} @dots{})
@expansion{} (call-with-values
        (lambda ()
          @meta{expression})
      (lambda @meta{formals}
        @metao{body} @meta{body} @dots{}))
@end example
@end deffn


@deffn Syntax receive-and-return (@meta{retval} @dots{}) @meta{expression} @metao{body} @meta{body} @dots{}
Expect @meta{expression} to evaluate to multiple values and bind such
values to the identifiers @meta{retval}; evaluate the @meta{body} forms
in the region of such bindings; return the values bound to
@meta{retval}.  The expansion is:

@example
(receive-and-return (@meta{retval} @dots{})
    @meta{expression}
  @metao{body} @meta{body} @dots{})
@expansion{} (call-with-values
        (lambda ()
          @meta{expression})
      (lambda (@meta{retval} @dots{})
        @metao{body} @meta{body} @dots{}
        (values @meta{retval} @dots{})))
@end example
@end deffn


@deffn Syntax let*-syntax ((@meta{lhs} @meta{rhs}) @dots{}) @metao{form} @meta{form} @dots{}
Similar to @func{let-syntax}, expands into nested @func{let-syntax}
forms:

@example
(let*-syntax () @meta{body})
@expansion{} (begin () @meta{body})

(let*-syntax ((@meta{lhs} @meta{rhs})) @meta{body})
@expansion{} (let-syntax ((@meta{lhs} @meta{rhs})) @meta{body})

(let*-syntax ((@metao{lhs} @metao{rhs})
              (@meta{lhs} @meta{rhs})
              ...)
  @meta{body})
@expansion{} (let-syntax ((@metao{lhs} @metao{rhs}))
      (let*-syntax ((@meta{lhs} @meta{rhs}) ...) @meta{body}))
@end example
@end deffn


@deffn Syntax let-constants ((@meta{lhs} @meta{rhs}) @dots{}) @metao{body} @meta{body} @dots{}
Like @func{let} but create immutable bindings.  Attempting to mutate the
bindings with @func{set!} will result in an expand time syntax
violation.
@end deffn


@deffn Syntax let*-constants ((@meta{lhs} @meta{rhs}) @dots{}) @metao{body} @meta{body} @dots{}
Like @func{let*} but create immutable bindings.  Attempting to mutate
the bindings with @func{set!} will result in an expand time syntax
violation.
@end deffn


@deffn Syntax letrec-constants ((@meta{lhs} @meta{rhs}) @dots{}) @metao{body} @meta{body} @dots{}
Like @func{letrec} but create immutable bindings.  Attempting to mutate
the bindings with @func{set!} will result in an expand time syntax
violation.
@end deffn


@deffn Syntax letrec*-constants ((@meta{lhs} @meta{rhs}) @dots{}) @metao{body} @meta{body} @dots{}
Like @func{letrec*} but create immutable bindings.  Attempting to mutate
the bindings with @func{set!} will result in an expand time syntax
violation.
@end deffn

@c page
@node iklib syntaxes control
@subsection Additional control flow syntaxes


@deffn Syntax begin0 @metao{expr} @meta{expr} ...
Evaluate all the expressions in the given order and return the return
values of @metao{expr}.  This syntax comes from the @rnrs{6} original
document, Appendix A ``Formal semantics''.

@example
(begin0
    1
  2)
@result{} 1
@end example
@end deffn


@deffn Syntax xor @meta{expr} ...
Exclusive @syntax{or}.  When expanded with no expressions: evaluate to
@false{}.
@end deffn


@deffn Macro case-identifiers @meta{expr} ((@metao{identifier} @meta{identifier} ...) @metao{sym-body} @meta{sym-body} ...) ...
@deffnx Macro case-identifiers @meta{expr} ((@metao{identifier} @meta{identifier} ...) @metao{sym-body} @meta{sym-body} ...) ... (else @metao{else-body} @meta{else-body} ...)
@deffnx {Auxiliary Syntax} else
Special implementation of @func{case} expecting only identifiers as
datums; identifiers are compared with @func{free-identifier=?}.
@func{else} must be the binding exported by @library{rnrs} and
@library{vicare}.

@meta{expr} must be an expression evaluating to an identifier, else the
behaviour is undefined.
@end deffn

@c page
@node iklib syntaxes loops
@subsection Additional loop syntaxes


@menu
* iklib syntaxes loops while::  Iterating with the @syntax{while} syntax.
* iklib syntaxes loops until::  Iterating with the @syntax{until} syntax.
* iklib syntaxes loops for::    Iterating with the @syntax{for} syntax.
* iklib syntaxes loops do::     Iterating with the @syntax{do} syntax.
* iklib syntaxes loops fluids:: Fluid bindings for loop syntaxes.
@end menu

@c page
@node iklib syntaxes loops while
@subsubsection Iterating with the @syntax{while} syntax


@deffn Syntax while @meta{test} @meta{body} ...
@deffnx {Auxiliary Syntax} continue
@deffnx {Auxiliary Syntax} break
If the expression @meta{test} evaluates to true: evaluate the body forms
@meta{body} and recurse; else return unspecified values.  In the body:
the syntax @func{continue} causes immediate looping to next iteration,
starting with the @meta{test}; the syntax @func{break} causes immediate
escaping out of the loop.
@end deffn

@c page
@node iklib syntaxes loops until
@subsubsection Iterating with the @syntax{until} syntax


@deffn Syntax until @meta{test} @meta{body} ...
@deffnx {Auxiliary Syntax} continue
@deffnx {Auxiliary Syntax} break
If the expression @meta{test} evaluates to false: evaluate the body
forms @meta{body} and recurse; else return unspecified values.  In the
body: the syntax @func{continue} causes immediate looping to next
iteration, starting with the @meta{test}; the syntax @func{break} causes
immediate escaping out of the loop.
@end deffn

@c page
@node iklib syntaxes loops for
@subsubsection Iterating with the @syntax{for} syntax


@deffn Syntax for (@meta{init} @meta{test} @meta{post}) @metao{body} @meta{body} @dots{}
@deffnx {Auxiliary Syntax} continue
@deffnx {Auxiliary Syntax} break
This is an iteration syntax similar to the C language @code{for}:

@example
(import (vicare))

(for ((define i 0) (< i 3) (set! i (+ 1 i)))
  (display i)
  (display #\space))
@print{} 0 1 2

(define i)
(for ((set! i 0) (< i 3) (set! i (+ 1 i)))
  (display i)
  (display #\space))
@print{} 0 1 2

(for ((begin
        (define i 5)
        (define j 10))
      (positive? i)
      (begin
        (set! i (+ -1 i))
        (set! j (+ -1 j))))
  (display i)
  (display #\space)
  (display j)
  (display #\space))
@print{} 5 10 4 9 3 8 2 7 1 6
@end example

The form @meta{init} can be a sequence of definitions and expressions;
it is evaluated first and only once; its return values are discarded.
The region of bindings defined by @meta{init} includes the @meta{test},
@meta{post} and @meta{body} forms.

The form @meta{test} must be an expression; it is evaluated at the
beginning of each iteration: if the result is true the next iteration
takes place, else the loop terminates.

The forms @meta{body} must be expressions; they are evaluated at each
iteration when the @meta{test} evaluates to true; the return values are
discarded.

The form @meta{post} must be an expression; it is evaluated at the end
of each iteration after the @meta{body} forms; the return values are
discarded.

The syntax @func{continue} can be used in the body to immediately exit
from the body and jump directly to the evaluation of @meta{post}.

The syntax @func{break} can be used in the body to immediately break out
of the loop and return to the continuation of @func{for}.
@end deffn

@c page
@node iklib syntaxes loops do
@subsubsection Iterating with the @syntax{do} syntax


@deffn Syntax do @meta{body} (while @meta{test})
@deffnx Syntax do @meta{body} (until @meta{test})
@deffnx {Auxiliary Syntax} while
@deffnx {Auxiliary Syntax} until
@deffnx {Auxiliary Syntax} continue
@deffnx {Auxiliary Syntax} break
These syntaxes extend the built--in @syntax{do} syntax as defined by
@rnrs{6}.

For @code{do ... (while ...)}:

@itemize
@item
Evaluate @meta{body} at least once, then: if the expression @meta{test}
evaluates to non--false loop; else return unspecified values.

@item
Using @syntax{continue} in the body cause a direct jump to the end of
the current iteration, evaluating the @meta{test}.

@item
Using the syntax @syntax{break} in the body causes immediate escaping
out of the loop; if arguments are given to @syntax{break}: they become
the return values of the syntax.
@end itemize

For @code{do ... (until ...)}:

@itemize
@item
Evaluate @meta{body} at least once, then if the expression @meta{test}
evaluates to false loop; else return unspecified values.

@item
Using @syntax{continue} in the body cause a direct jump to the end of
the current iteration, evaluating the @meta{test}.

@item
Using the syntax @syntax{break} in the body causes immediate escaping
out of the loop; if arguments are given to @syntax{break}: they become
the return values of the syntax.
@end itemize

For the standard syntax:

@itemize
@item
Using @syntax{continue} in the body cause a direct jump to the end of
the current iteration, evaluating the @meta{test}.

@item
Using the syntax @syntax{break} in the body causes immediate escaping
out of the loop; if arguments are given to @syntax{break}: they become
the return values of the syntax.
@end itemize
@end deffn

@c page
@node iklib syntaxes loops fluids
@subsubsection Fluid bindings for loop syntaxes


@deffn {Fluid Syntax} continue
Causes the innermost @syntax{do}, @syntax{while}, @syntax{until} or
@syntax{for} loop to jump immediately to the next iteration.  Being a
fluid syntax: it is possible to use this keyword in custom syntaxes.
@end deffn


@deffn {Fluid Syntax} break @meta{expr} ...
Causes the innermost @syntax{do}, @syntax{while}, @syntax{until} or
@syntax{for} loop to exit immediately to the continuation of the whole
loop syntax.  When arguments are given: they are returned to the
continuation; when no arguments are given: zero values are returned.
Being a fluid syntax: it is possible to use this keyword in custom
syntaxes.
@end deffn


@value{PRJNAME} does @strong{not} bind @syntax{break} and
@syntax{continue} in uses of the named @syntax{let} syntax; this is
because:

@itemize
@item
Named @syntax{let} is a convenience syntax to define a recursive
function; recursive functions do not have the @syntax{break} and
@syntax{continue} operators in other languages.  In Scheme, all the loop
syntaxes are just convenience for a recursive function definition, but
the named @syntax{let} is more so.

@item
The operation performed by @syntax{continue} in a named @syntax{let} is
just performed by calling the function itself.  Calling the function is
more flexible because it allows tail calls and non--tail calls.

@item
The operation performed by @syntax{break} in a recursive function can be
performed using @syntax{returnable} and @syntax{return} in the body:

@example
(returnable
  (let loop ()
    ...
    (return)
    ...))
@end example

@item
By keeping named @syntax{let} clean of fluid bindings, we can more
freely use it as building block for custom loop syntaxes.
@end itemize

@c page
@node iklib syntaxes returnable
@subsection Early return from code blocks


The standardised Scheme languages do not define the common @code{return}
keyword present in many languages, like C and Python.  Despite this, it
is quite easy to obtain the ``early return'' functionality through the
use of continuations:

@example
(call/cc
    (lambda (return)
      (display 'before)
      (return 1)
      (display 'never)))
@print{} before
@result{} 1
@end example

Many programmers are used to the @code{return} keyword, so
@value{PRJNAME} includes some syntaxes to support it.  The use of all
these syntaxes involves the creation of a continuation, which is a
performance penalty.


@deffn {Fluid Syntax} return @meta{expr} ...
This syntax is meant to be used to return from some enclosing block,
returning the given optional arguments.  Being a fluid syntax: it is
possible to rebind this keyword in custom syntaxes.
@end deffn


@deffn Syntax returnable @metao{body} @meta{body} @dots{}
Like @func{begin}, but allow the use of the keyword @func{return} to
return values to the enclosing continuation.

@example
(returnable
  (display 'before)
  (return)
  (display 'never))
@print{} before

(returnable
  (display 'before)
  (return 1)
  (display 'never))
@print{} before
@result{} 1

(returnable
  (display 'before)
  (return 1 2)
  (display 'never))
@print{} before
@result{} 1 2
@end example
@end deffn

@c page
@node iklib syntaxes blocking
@subsection Blocking raised exceptions


Sometimes we want to block raised exceptions, for example when we are
already handling a previously raised exception.


@deffn Syntax with-blocked-exceptions @meta{thunk}
@deffnx Syntax with-blocked-exceptions @meta{exception-retvals-maker} @meta{thunk}
Evaluate @meta{thunk} and return its return values.

When used with one argument: if @meta{thunk} raises an exception, return
the raised object.

When used with two arguments: if @meta{thunk} raises an exception, apply
the procedure @meta{exception-retvals-maker} to the raised object and
return its return values.  Exceptions raised by
@meta{exception-retvals-maker} are @strong{not} blocked.
@end deffn


Usage examples:

@example
(import (vicare))

(with-blocked-exceptions
  (lambda ()
    (raise 99)))
@result{} 99

(with-blocked-exceptions
    (lambda (E)
      (values E 1 2 3))
  (lambda ()
    (raise 99)))
@result{} 99 1 2 3
@end example

@c page
@node iklib syntaxes dynenv
@subsection Capturing the current dynamic environment


@deffn Syntax with-current-dynamic-environment @meta{exception-retvals-maker} @meta{thunk}
Install and return a thunk that, wherever it is called, evaluates
@meta{thunk} in the dynamic environment of the macro use and returns its
return values.  If @meta{thunk} raises an exception: apply the procedure
@meta{exception-retvals-maker} to the raised object and return its
return values.

Exceptions raised by @meta{exception-retvals-maker} are @strong{not}
blocked.
@end deffn


Usage examples:

@example
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(define parm
  (make-parameter #f))

(with-result
  (parametrise ((parm 'outer))
    (let* ((counter 0)
           (thunk   (parametrise ((parm 'inner))
                      (with-current-dynamic-environment
                          values
                        (lambda ()
                          (set! counter (+ 1 counter))
                          (add-result (list 'inside-thunk (parm))))))))
      (add-result (parm))
      (add-result 'calling-thunk-1)
      (thunk)
      (add-result 'calling-thunk-2)
      (thunk)
      counter)))
@result{} (2 (outer
       calling-thunk-1 (inside-thunk inner)
       calling-thunk-2 (inside-thunk inner)))

(with-result
  (parametrise ((parm 'outer))
    (let* ((counter 0)
           (thunk   (parametrise ((parm 'inner))
                      (with-current-dynamic-environment
                          values
                        (lambda ()
                          (set! counter (+ 1 counter))
                          (add-result (list 'inside-thunk (parm)))
                          (add-result 'raise-exception)
                          (raise 123))))))
      (add-result (parm))
      (add-result 'calling-thunk-1)
      (thunk)
      (add-result 'calling-thunk-2)
      (thunk)
      counter)))
@result{} (2 (outer
       calling-thunk-1 (inside-thunk inner) raise-exception
       calling-thunk-2 (inside-thunk inner) raise-exception))
@end example

@c page
@node iklib syntaxes integrable
@subsection Integrable expressions and functions


@cindex Function inlining
@cindex Function integration
@cindex Expression inlining
@cindex Expression integration
@cindex Inlining of functions and expressions
@cindex Integration of functions and expressions
@cindex Expanding functions inline
@cindex Expanding expressions inline


Compilers act upon ``compilation units'', which for @value{PRJNAME} are:
@rnrs{6} libraries, @rnrs{6} programs, symbolic expressions handed to
@func{eval}; the latter includes standalone expressions typed at the
@repl{}.  Under @value{PRJNAME}:

@itemize
@item
Whenever a function defined in a compilation unit is called in the same
compilation unit: the compiler has access to the source code, so it
@strong{always} attempts to integrate it (expand it inline); such
integration can succeed or fail depending on the cost of such operation.

@item
Whenever a function defined in a compilation unit is called in another
compilation unit: the compiler has @strong{no} access to the source
code, so it never attempts to integrate it.
@end itemize

@noindent
this scenario is somewhat different from the one of languages like C,
which make use of object files that allow inlining of functions defined
in other files.

Sometimes we do want to always integrate expressions, even across
compilation unit boundaries; for this purpose @value{PRJNAME} provides
@func{define-inline} to integrate expressions and
@func{define-integrable} to integrate functions.


@deffn Syntax define-inline (@meta{name} @meta{arg} ... . @meta{rest}) @metao{body} @meta{body} ...
Similar to @func{define}, but create a binding for an expression that is
always expanded inline and can @strong{neither} be invoked recursively
@strong{nor} used as function argument.  This syntax only defines a
syntax embedding the source code of the expression in a syntax object.

@example
(define-inline (incr x)
  (+ x 1))

(incr 2)        @result{} 3
@end example

In the example above, we can think of @code{(incr 2)} as expanding to:

@example
(let ((x 2))
  (+ x 1))
@end example
@end deffn


@deffn Syntax define-integrable (@meta{name} @meta{arg} ... . @meta{rest}) @metao{body} @meta{body} ...
Similar to @func{define}, but create a binding that is always expanded
inline and @strong{can} be both invoked recursively and used as function
argument.  This syntax defines both a syntax and a function, with the
syntax embedding the source code of the function in a syntax object.

@example
(define-integrable (incr x)
  (+ x 1))

(incr 2)
@result{} 3

(map incr '(10 20 30)))
@result{} (11 21 31)
@end example

In the example above, we can think of @code{(incr 2)} as expanding to:

@example
((lambda (x)
   (+ x 1))
 2)
@end example
@end deffn


@c page
@node iklib syntaxes stale
@subsection Declaring compiled library in stale state


@cindex Stale libraries
@cindex Libraries, stale with respect to source
@cindex Compiled libraries, stale with respect to source


@deffn Syntax stale-when @meta{stale-expr} @metao{body} @meta{body} @dots{}
Act like @func{begin}, but in addition causes an expression,
@meta{stale-expr}, to be registered in the state of a compiled library.
When such expression evaluates to false: the compiled library is stale
with respect to some source file.  See for example the @func{include}
syntax.
@end deffn

@c page
@node iklib syntaxes include
@subsection Including source files at expand time


@deffn Syntax include @meta{filename}
@deffnx Syntax include @meta{filename} #t
Include in the current source file the contents of the file selected by
the pathname @meta{filename}, which must be a string.  Everything
happens as if the code was present in place of the @func{include} form.
When the optional @true{} argument is given: print a message on the
current error port describing the include operation.
@end deffn

@c page
@node iklib syntaxes body
@subsection Internal body


@deffn Syntax internal-body @meta{definition} @dots{} @metao{expr} @meta{expr} @dots{}
Delimits an internal body, evaluating the definitions and then the
expression.  This syntax must be used in expression context.

@example
(import (vicare))

(let ()
  (define a 1)
  (display a)
  (internal-body
    (define b 2)
    (define c 3)
    (display a)
    (display b)
    (display c)))
@print{} 1123
@end example
@end deffn

@c page
@node iklib syntaxes types
@subsection Type syntaxes


The syntactic bindings of Vicare struct types and @rnrs{6} record types
allow the identifier name to act as reference to the maker function with
the special syntax:

@example
(?type (?arg ...))
@end example

@noindent
that is, for struct types:

@example
(import (vicare))

(define-struct color
  (red green blue))

(color (1 2 3))                    @result{} #["color" 1 2 3]
(apply (color (...)) 1 '(2 3))     @result{} #["color" 1 2 3]
@end example

@noindent
and for @rnrs{6} record types:

@example
(import (vicare))

(define-record-type color
  (fields red green blue))

(color (1 2 3))
@result{} #[r6rs-record: color red=1 green=2 blue=3]

(apply (color (...)) 1 '(2 3))
@result{}  #[r6rs-record: color red=1 green=2 blue=3]
@end example

@noindent
where @code{...} is the ellipsis binding exported by @rsixlibrary{base}
and @library{vicare}.


@deffn Syntax type-descriptor @meta{name}
Expand to an expression which, when evaluated, results in:

@itemize
@item
A Vicare struct type descriptor if the given identifier argument
@meta{name} is a struct type name.

@item
A @rnrs{6} record type descriptor if the given identifier argument
@meta{name} is a record type name.
@end itemize
@end deffn

@c page
@node iklib syntaxes predicates
@subsection Predicate syntaxes


@deffn Syntax is-a? @meta{expr} @meta{type-id}
@deffnx Syntax is-a? <> @meta{type-id}
@deffnx Syntax is-a? _ @meta{type-id}
@deffnx {Auxiliary Syntax} <>
@deffnx {Auxiliary Syntax} _
Expand to an expression which, when evaluated, returns @true{} if
@meta{expr} evaluates to a struct or record of type @meta{type-id}.

@meta{expr} can be any expression returning a single value.
@meta{type-id} must the type name of a Vicare struct (defined by
@func{define-struct}) or an @rnrs{6} record type name (defined by
@func{define-record-type}).

When @code{<>} is used as first argument: the syntax evaluates to a
predicate function.

@example
(import (vicare))

(define-struct doublet
  (a b))

(define-record-type triplet
  (fields a b c))

(is-a? (make-doublet 1 2)   doublet)    @result{} #t
(is-a? (make-triplet 1 2 3) triplet)    @result{} #t

((is-a? <> doublet) (make-doublet 1 2)) @result{} #t

(is-a? 123 triplet)                     @result{} #f
@end example
@end deffn

@c page
@node iklib syntaxes slots
@subsection Slot getter and setter syntaxes


The syntaxes @func{slot-ref} and @func{slot-set!} allow both access to
fields of Vicare's structs:

@example
(import (vicare))

(define-struct color
  (red green blue))

(define S
  (make-color 1 2 3))

(slot-set! S red   color 19)
(slot-set! S green color 29)
(slot-set! S blue  color 39)

(slot-ref S red   color)        @result{} 19
(slot-ref S green color)        @result{} 29
(slot-ref S blue  color)        @result{} 39
@end example

@noindent
and access to fields of @rnrs{6} records:

@example
(import (vicare))

(define-record-type color
  (fields (mutable red)
          (mutable green)
          (mutable blue)))

(define R
  (make-color 1 2 3))

(slot-set! R red   color 19)
(slot-set! R green color 29)
(slot-set! R blue  color 39)

(slot-ref R red   color)        @result{} 19
(slot-ref R green color)        @result{} 29
(slot-ref R blue  color)        @result{} 39
@end example


@deffn Syntax slot-ref @meta{expr} @meta{field-name} @meta{type}
@deffnx Syntax slot-ref <> @meta{field-name} @meta{type}
@deffnx Syntax slot-ref _ @meta{field-name} @meta{type}
@deffnx {Auxiliary Syntax} <>
@deffnx {Auxiliary Syntax} _
Expand to the slot accessor of @meta{field-name} applied to @meta{expr}.

@meta{expr} can be any expression evaluating to an instance of
@meta{type}; @meta{type} must be an identifier bound to a Vicare
struct--type descriptor or a @rnrs{6} record--type descriptor;
@meta{field-name} must be an identifier representing the name of a
field.

When @meta{type} is bound to a struct--type descriptor: this syntax
expands to a use of @func{struct-type-field-ref}; @ref{iklib structs
fields, struct-type-field-ref}.

When @meta{type} is bound to a record--type descriptor: this syntax
expands to a use of @func{record-type-field-ref}; @ref{iklib records
fields, record-type-field-ref}.

When @code{<>} or @code{_} is used in place of @meta{expr}: the syntax
evaluates to a slot accessor function.
@end deffn

@c ------------------------------------------------------------

@deffn Syntax slot-set! @meta{expr} @meta{field-name} @meta{type} @meta{new-val}
@deffnx Syntax slot-set! <> @meta{field-name} @meta{type} <>
@deffnx Syntax slot-set! _ @meta{field-name} @meta{type} _
@deffnx {Auxiliary Syntax} <>
@deffnx {Auxiliary Syntax} _
Expand to the slot mutator of @meta{field-name} applied to @meta{expr}
and @meta{new-val}.

@meta{expr} can be any expression evaluating to an instance of
@meta{type}; @meta{type} must be an identifier bound to a Vicare
struct--type descriptor or a @rnrs{6} record--type descriptor;
@meta{field-name} must be an identifier representing the name of a
field.

When @meta{type} is bound to a struct--type descriptor: this syntax
expands to a use of @func{struct-type-field-set!}; @ref{iklib structs
fields, struct-type-field-set!}.

When @meta{type} is bound to a record--type descriptor: this syntax
expands to a use of @func{record-type-field-set!}; @ref{iklib records
fields, record-type-field-set!}.

When @code{<>} or @code{_} is used in place of both @meta{expr} and
@meta{new-val}: the syntax evaluates to a slot mutator function.
@end deffn

@c page
@node iklib syntaxes try
@subsection The @func{try}, @func{catch}, @func{finally} syntaxes


The syntax @func{try} can be used to handle raised exceptions in
addition to the @rnrs{6}--defined syntaxes @func{with-exception-handler}
and @func{guard}.  The syntax is basically a wrapper for @func{guard}
from @rsixlibrary{exceptions} (@pxref{guard}).


@deffn Syntax try @meta{body} @meta{catch-clauses}
@deffnx Syntax try @meta{body} @meta{catch-clauses} @meta{finally-clause}
@deffnx Syntax try @meta{body} @meta{finally-clause}
@deffnx {Auxiliary Syntax} catch
@deffnx {Auxiliary Syntax} finally
@deffnx {Auxiliary Syntax} else
Evaluate the form @meta{body} and return its results.  If no exceptions
are raised by @meta{body}: before returning evaluate the
@meta{finally-clause}.  If an exception is raised by @meta{body}: handle
it with the @meta{catch-clauses} and, before returning, evaluate the
@meta{finally-clause}.

The @meta{catch-clauses} argument must have the format:

@example
(catch @meta{var} @metao{catch-clause} @meta{catch-clause} ...)
@end example

@noindent
where @meta{var} must be an identifier and every @meta{catch-clause} has
one of the forms:

@example
((@metao{tag} @meta{tag} ...) @metao{tag-body} @meta{tag-body} ...)
(else @metao{else-body} @meta{else-body} ...)
@end example

@noindent
where the optional @clause{else} clause must appear only once as last
one.

The @meta{finally-clause} must have the format:

@example
(finally @metao{finally-body} @meta{finally-body} ...)
@end example

@noindent
when the @clause{finally} clause is present: the @meta{body} is wrapped
into an unwind--protection syntax, @xref{iklib unwind-protect, The
unwind-protection mechanism}.

The following expansions take place:

@itemize
@item
No else, no finally.

@example
(try
   @meta{body}
  (catch @meta{var}
    ((@metao{tag} @meta{tag} ...)
     @metao{tag-body}
     @meta{tag-body}
     ...)
    ...))
@expansion{} (guard (@meta{var}
              ((or (condition-is-a? @meta{var} @metao{tag})
                   (condition-is-a? @meta{var} @meta{tag})
                   ...)
               @metao{tag-body}
               @meta{tag-body}
               ...)
              ...)
      @meta{body})
@end example

@item
Else, no finally.

@example
(try
   @meta{body}
  (catch @meta{var}
    ((@metao{tag} @meta{tag} ...)
     @metao{tag-body}
     @meta{tag-body}
     ...)
    ...)
    (else
     @metao{else-body}
     @meta{else-body}
     ...))
@expansion{} (guard (@meta{var}
              ((or (condition-is-a? @meta{var} @metao{tag})
                   (condition-is-a? @meta{var} @meta{tag})
                   ...)
               @metao{tag-body}
               @meta{tag-body}
               ...)
               ...
              (else
               @metao{else-body}
               @meta{else-body}
               ...))
      @meta{body})
@end example

@item
Finally, no else.

@example
(try
   @meta{body}
  (catch @meta{var}
    ((@metao{tag} @meta{tag} ...)
     @metao{tag-body}
     @meta{tag-body}
     ...)
    ...)
  (finally
    @metao{finally-body}
    @meta{finally-body}
    ...))
@expansion{} (with-unwind-protection
        (lambda (dummy)
          @metao{finally-body}
          @meta{finally-body}
          ...)
      (lambda ()
        (guard (@meta{var}
                ((or (condition-is-a? @meta{var} @metao{tag})
                     (condition-is-a? @meta{var} @meta{tag})
                     ...)
                 @metao{tag-body}
                 @meta{tag-body}
                 ...)
                ...)
            @meta{body})))
@end example

@item
Finally, no catch.

@example
(try
    @meta{body}
  (finally
    @metao{finally-body}
    @meta{finally-body}
    ...))
@expansion{} (with-unwind-protection
        (lambda (dummy)
          @metao{finally-body}
          @meta{finally-body}
          ...)
      (lambda ()
        @meta{body}))
@end example
@end itemize
@end deffn


Some usage examples without the @clause{finally} clause:

@example
(import (vicare))

(define-condition-type &this
    &error
  make-this-condition
  condition-this?
  (a condition-this.a)
  (b condition-this.b)
  (c condition-this.c))

(define (doit thunk)
  (try
      (thunk)
    (catch E
      ((&this)
       (list (condition-this.a E)
             (condition-this.b E)
             (condition-this.c E)))
      ((&message)
       (condition-message E))
      (else E))))

(doit (lambda ()
        (raise (make-this-condition 1 2 3))))
@result{} (1 2 3)

(doit (lambda ()
        (raise (make-message-condition "ciao"))))
@result{} "ciao"

(doit (lambda ()
        (raise 123)))
@result{} 123
@end example

Evaluation order tracking for @clause{finally} clauses:

@lisp
(with-result
  (try
      (add-result 'body)
    (catch E
      ((&error)   (add-result 'catch-error))
      ((&warning) (add-result 'catch-warning))
      (else       (add-result 'catch-else)))
    (finally
     (add-result 'finally))))
@result{} (body (body finally))

(with-result
  (try
      (begin
        (add-result 'body)
        (raise (make-warning)))
    (catch E
      ((&error)   (add-result 'catch-error))
      ((&warning) (add-result 'catch-warning))
      (else       (add-result 'catch-else)))
    (finally
     (add-result 'finally))))
@result{} (catch-warning (body catch-warning finally))
@end lisp

@c page
@node iklib syntaxes splice1st
@subsection Splice first form syntax


@deffn Syntax splice-first-expand @meta{form}
When the use of a @func{splice-first-expand} syntax appears as first
subform of an enclosing form, @meta{form} must have the format:

@example
(@meta{rator} @meta{rand} ...)
@end example

@noindent
and it is spliced in the enclosing form, then the result is expanded:

@example
((splice-first-expand (@meta{rator} @meta{rand} ...) @meta{arg} ...)
@expansion{} (@meta{rator} @meta{rand} ... @meta{arg} ...)
@end example

When the use of a @func{splice-first-expand} syntax appears as second or
subsequent subform: it expands into @meta{form} itself, which is then
expanded:

@example
(splice-first-expand @meta{form})
@expansion{} @meta{form}
@end example

This syntax must be used with care.
@end deffn


Usage examples:

@example
(import (vicare))

(splice-first-expand 123)               @result{} 123
(splice-first-expand (+ 1 2))           @result{} 3

((splice-first-expand (+)) 1 2)           @result{} 3
((splice-first-expand (+) 1 2) 3 4)       @expansion{} (+ 1 2 3 4)

(let-syntax ((doit (syntax-rules ()
                     ((_ ?arg ...)
                      (+ (square ?arg) ...)))))
  ((splice-first-expand (doit 1 2)) 3 4))
@expansion{} (+ (square 1) (square 2) (square 3) (square 4))

(let-syntax ((arg1 (identifier-syntax 1))
             (arg2 (identifier-syntax 2))
             (doit (syntax-rules ()
                     ((_ ?arg ...)
                      (+ (square ?arg) ...)))))
  ((splice-first-expand (doit arg1 arg2)) 3 4))
@expansion{} (+ (square 1) (square 2) (square 3) (square 4))

(let*-syntax ((arg1 (identifier-syntax 1))
              (arg2 (identifier-syntax 2))
              (doit (syntax-rules ()
                      ((_ ?arg ...)
                       (+ (square ?arg) ...))))
              (flop (syntax-rules ()
                      ((_ ?arg ...)
                       (splice-first-expand
                        (doit arg1 ?arg ...))))))
  ((flop arg2) 3 4))
@expansion{} (+ (square 1) (square 2) (square 3) (square 4))

(let*-syntax ((arg1 (identifier-syntax 1))
              (arg2 (identifier-syntax 2))
              (doit (syntax-rules ()
                      ((_ ?arg ...)
                       (+ (square ?arg) ...))))
              (flop (syntax-rules ()
                      ((_ ?arg ...)
                       (splice-first-expand
                        (doit arg1 ?arg ...)))))
              (flip (syntax-rules ()
                      ((_ ?arg ...)
                       (flop ?arg ...)))))
  ((flip arg2) 3 4))
@expansion{} (+ (square 1) (square 2) (square 3) (square 4))
@end example

@c page
@node iklib syntaxes infix
@subsection Infix to prefix transformer


@deffn Syntax infix @meta{obj} @dots{}
The @func{infix} macro converts the traditional infix notation for
mathematical expressions to the equivalent Scheme's prefix notation.
@func{infix} expands to a prefix expression to be evaluated at
run--time, in the lexical context of the macro use; as a special case
@code{(infix)} is equivalent to @code{(values)}.
@end deffn

The macro allows us to evaluate forms like:

@example
(infix atan(1, 2))      @expansion{} (atan 1 2)
(infix 1 + 2 + 3)       @expansion{} (+ (+ 1 2) 3)
(infix 1 + 2 * 3)       @expansion{} (+ 1 (* 2 3))
(infix (1 + 2) * 3)     @expansion{} (* (+ 1 2) 3)

(infix 2 expt 3 expt 4) @expansion{} (expt 2 (expt 3 4))
(infix 2 ** 3 ** 4)     @expansion{} (expt 2 (expt 3 4))

(infix - 5)             @expansion{} (- 5)
(infix + 5)             @expansion{} (+ 5)
(infix 5 !)             @expansion{} (factorial 5)

(infix 1 > 2 ? 3 + 4 : 5 * 6)
@expansion{} (if (> 1 2) (+ 3 4) (* 5 6))

(define a 1)
(define b 2)
(define c 3)
(infix cos(a) * tan(b) / c)
@expansion{} (/ (* (cos a) (tan b)) c)
@end example

@menu
* iklib syntaxes infix syntax:: Notes on the supported syntax.
* iklib syntaxes infix prec::   Operators precedence.
* iklib syntaxes infix notes::  Random notes on the features.
@end menu

@c page
@node iklib syntaxes infix syntax
@subsubsection Notes on the supported syntax


Some expression syntax interpretation rules:

@itemize
@item
Any Scheme value can be element of the input form; numbers and all the
other values are just put there as operands.

@example
#!vicare
(infix list("ciao", 'hello, '#ve(ascii "salut")))
@result{} ("ciao" hello #ve(ascii "salut"))
@end example

@item
The following bound identifiers exported by @library{vicare} are
interpreted as binary infix operators:

@example
+ - * / div div0 mod mod0 expt
fl+ fl- fl* fl/ flexpt
fx+ fx- fx* fxdiv fxdiv0 fxmod fxmod0
< > <= >= = !=
fx<? fx>? fx<=? fx>=? fx=?
fl<? fl>? fl<=? fl>=? fl=?
eq? eqv? equal?
and or xor
bitwise-and bitwise-ior bitwise-xor
bitwise-arithmetic-shift-left
bitwise-arithmetic-shift-right
fxand fxior fxxor
fxarithmetic-shift-left
fxarithmetic-shift-right
@end example

@noindent
in addition the following identifiers are recognised by their symbol
name and interpreted as aliases of binary infix operators:

@example
&&              @expansion{} and
\x23D0;\x23D0;  @expansion{} or
\x00AC;         @expansion{} not
\x2227;         @expansion{} and
\x2228;         @expansion{} or
\x22BB;         @expansion{} xor
==              @expansion{} =
<>              @expansion{} !=
\x00D7;         @expansion{} *
\x22C5;         @expansion{} *
**              @expansion{} expt
%               @expansion{} mod
&               @expansion{} bitwise-and
\x23D0;         @expansion{} bitwise-ior
^               @expansion{} bitwise-xor
<<              @expansion{} bitwise-arithmetic-shift-left
>>              @expansion{} bitwise-arithmetic-shift-right
@end example

@noindent
where the symbols with escape sequences are:

@table @samp
@item \x00AC;
Unicode character not sign.

@item \x00D7;
Unicode character times.

@item \x2227;
Unicode character logical and.

@item \x2228;
Unicode character logical or.

@item \x22BB;
Unicode character xor.

@item \x22C5;
Unicode character dot operator.

@item \x23D0;
Unicode character vertical bar extension.
@end table

@item
The following bound identifiers exported by @library{vicare} are
interpreted as unary prefix operators:

@example
+ - ++ --
fx+ fx- fl+ fl-
not bitwise-not fxnot
@end example

@noindent
in addition the following identifiers are recognised by their symbol
name and interpreted as aliases of unary prefix operators:

@example
!       @expansion{} not
~       @expansion{} bitwise-not
@end example

@item
The following bound identifiers exported by @library{vicare} are
interpreted as unary postfix operators:

@example
++ --
@end example

@noindent
in addition the following identifiers are recognised by their symbol
name and interpreted as aliases of unary postfix operators:

@example
!       @expansion{} factorial
@end example

@item
Almost all the binary infix operators are left--associative with the
exception of @func{expt} and @func{flexpt} which are right--associative:

@example
;; left-associative
(infix 10 - 5 - 3)              @expansion{} (- (- 10 5) 3)
(infix 10 - 5 - 3)              @expansion{} (- 10 5 3)
(infix 10 / 5 / 3)              @expansion{} (/ (/ 10 5) 3)
(infix 10 / 5 / 3)              @expansion{} (/ 10 5 3)

;; right-associative
(infix 10 expt 5 expt 3)        @expansion{} (expt 10 (expt 5 3))
@end example

@item
The identifiers @func{++} and @func{--} are unary operators that can be
applied to expressions both in prefix and postfix positions.  They
expand as follows:

@example
#!vicare
(infix ++ X)            @expansion{} (pre-incr! X)
(infix -- X)            @expansion{} (pre-decr! X)
(infix X ++)            @expansion{} (post-incr! X)
(infix X --)            @expansion{} (post-decr! X)
@end example

@noindent
where @func{pre-incr!}, @func{pre-decr!}, @func{post-incr!} and
@func{post-decr!} are the bindings exported by @library{vicare}.

@item
The ternary conditional operator involves the identifiers @func{?}  and
@func{:}, which are recognised by their symbol name.

@example
(infix 1 > 2 ? 3 + 4 : 5 * 6)
@expansion{} (if (> 1 2) (+ 3 4) (* 5 6))
@end example

@item
Identifiers which are not operators are interpreted as variable
references.

@item
If an identifier is followed by a left parenthesis: it is interpreted as
the binding of a procedure in a procedure application.  Procedure
application requires the arguments to be grouped in a list, using the
comma as separator.

@example
(define (fun a b c)
  (+ a b c))

(infix fun (1, 2, 3))   @expansion{} (fun 1 2 3)
@end example

@quotation
@strong{NOTE} The Scheme reader transforms the sequence:

@example
, @meta{form}
@end example

@noindent
into:

@example
(unsyntax @meta{form})
@end example

@noindent
so the list of arguments is:

@example
( @metai{arg} (unsyntax @meta{arg}) ... )
@end example

@rnrs{6} does not define the comma to be a delimiter, so writing:

@example
func (@metai{arg}, @meta{arg}, ...)
@end example

@noindent
with no space between the @meta{arg} and the comma is a syntax error in
strict @rnrs{6} implementations.  @value{PRJNAME} extends the reader to
handle the comma as a delimiter, so the above expression is valid in the
@func{infix} syntax.
@end quotation

@item
The identifiers @func{quote}, @func{quasiquote}, @func{syntax} and
@func{quasisyntax} are not subject to infix to prefix conversion; the
use of such syntaxes just expands to the prefix object:

@example
(infix (quote       ciao))  @expansion{} (quote ciao)
(infix (quasiquote  ciao))  @expansion{} (quasiquote ciao)
(infix (syntax      ciao))  @expansion{} (syntax ciao)
(infix (quasisyntax ciao))  @expansion{} (quasisyntax ciao)
@end example

@item
Matched left and right round parentheses are used to group
subexpressions, overriding operators precedence rules.
@end itemize

@c page
@node iklib syntaxes infix prec
@subsubsection Operators precedence


To determine sensible precedences for operators, we make the following
observations:

@itemize
@item
Logical operators (@func{and}, @func{or}, @func{not}, @dots{}) are meant
to be applied to predicate operand expressions and they return a boolean
value.

@item
Numeric comparison operators (@func{=}, @func{<}, @func{>}, @dots{}) are
meant to be applied to numeric operand expressions and they return a
boolean value.

@item
Arithmetic operators (@func{+}, @func{-}, @func{*}, @func{/}, @dots{})
are meant to be applied to numeric operand expressions and they return a
numeric value.

@item
The C language has established a tradition of writing expressions
containing bitwise operators @code{1 & 2 + ~ 3} meaning @code{(1 & 2) +
(~ 3)}, in which bitwise operators take precedence over every other
operator.

@item
It makes sense to write expressions like @code{1 < i and i < 4} meaning
@code{(1 < i) and (i < 4)}, because it makes no sense to interpret it as
@code{1 < (i and i) < 4}.

@item
It makes sense to write expressions like @code{1 + 2 < 3 + 4} meaning
@code{(1 + 2) < (3 + 4)}, because it makes no sense to interpret it as
@code{1 + (2 < 3) + 4}.
@end itemize

So @value{PRJNAME} defines operators precedence as follows, from high
precedence to low precedence:

@enumerate
@item
Procedure application: the left parenthesis preceeded by an identifier
starts a procedure application.

@item
Binary infix bitwise shift operators:

@example
bitwise-arithmetic-shift-left
bitwise-arithmetic-shift-right
fxarithmetic-shift-left
fxarithmetic-shift-right
@end example

@item
Unary prefix bitwise operators:

@example
bitwise-not fxnot
@end example

@item
Binary infix bitwise operators:

@example
bitwise-and bitwise-ior bitwise-xor
fxand fxior fxxor
@end example

@item
Unary prefix arithmetic operators:

@example
+ - ++ -- fx+ fx- fl+ fl-
@end example

@item
Unary postfix arithmetic operators:

@example
++ -- !
@end example

@item
Binary infix arithmetic exponentiation operators:

@example
expt flexpt
@end example

@item
Binary infix arithmetic modulo operators:

@example
mod mod0 fxmod fxmod0
@end example

@item
Binary infix multiplication and division arithmetic operators:

@example
* / div div0 fl* fl/ fx* fxdiv fxdiv0
@end example

@item
Binary infix addition and subtraction arithmetic operators:

@example
+ - fl+ fl- fx+ fx-
@end example

@item
Comparison operators:

@example
< > <= >= = !=
fx<? fx>? fx<=? fx>=? fx=?
fl<? fl>? fl<=? fl>=? fl=?
eq? eqv? equal?
@end example

@item
Unary prefix logical operators:

@example
not
@end example

@item
Binary infix logical operators:

@example
and or xor
@end example

@item
Ternary conditional operator @code{@dots{} ? @dots{} : @dots{}}.

@item
Procedure application arguments separator, which is the comma.
@end enumerate

Here some expansion examples:

@example
(infix ! 2 + 3)         @expansion{} (not (2 + 3))
(infix (! 2) + 3)       @error{} expected numeric argument

(infix fxnot 3)         @result{} -3
(infix fxnot 3 + 10)    @result{} 7

(infix ! cos(3))        @expansion{} (not (cos 3))
@end example

@c page
@node iklib syntaxes infix notes
@subsubsection Random notes on the features


@subsubheading About the exponentiation and bitwise XOR operators

The @func{infix} macro uses @samp{**} as exponentiation operator and
@samp{^} as bitwise XOR operator; this is controversial because a lot of
people, especially LaTeX users, is used to think of @samp{^} as
exponentiation operator.  The C language has established a tradition to
interpret @samp{^} as bitwise exclusive OR operator, and the Python
language has adopted it; @value{PRJNAME} sticks to it, too.

@subsubheading About the vertical bar

The C language has established a tradition of interpreting the single
vertical bar @samp{|} as bitwise inclusive OR operator and the double
vertical bar as @samp{||} as logical inclusive OR operator.

In the @rnrs{6} Scheme language the vertical bar is used in the block
comments delimiters @samp{#| @dots{} |#}.  @value{PRJNAME}'s source code
reader uses the vertical bar to specify symbols whose name does not
comply with @rnrs{6}, @ref{iklib reader stx, Miscellaneous additional
syntaxes}.  Some text editors for software programmers handle the
vertical bar specially in Scheme mode, in particular for syntax
highlighting.

It would be possible to extend @value{PRJNAME}'s reader to allow
@samp{|} and @samp{||} to be symbols, but, at present, this confuses
some text editors in a way that is not easy to fix.  So, for now, rather
than the vertical bar, @func{infix} recognises the Unicode character
vertical bar extension (@samp{\x23D0;}) as bitwise inclusive OR and the
double vertical bar extension as logical inclusive OR.

@c page
@node iklib syntaxes increments
@subsection Incrementing and decrementing


@deffn Syntax {++} @meta{expr}
@deffnx Syntax {++} @meta{expr} @meta{step}
Increment @meta{expr} by @meta{step} and return the result.  Both
@meta{expr} and @meta{step} must be expressions evaluating to a number
object; when @meta{step} is not given: it defaults to the fixnum
@code{1}.

As special case, when @meta{expr} is an identifier: the syntax expands
as follows:

@example
#!vicare
(++ @meta{id} @meta{step})
@expansion{} (begin
      (set! @meta{id} (+ @meta{id} @meta{step}))
      @meta{id})
@end example
@end deffn


@deffn Syntax pre-incr! @meta{expr}
@deffnx Syntax pre-incr! @meta{expr} @meta{step}
Alias for @func{++}.
@end deffn


@deffn Syntax post-incr! @meta{expr}
@deffnx Syntax post-incr! @meta{expr} @meta{step}
Increment @meta{expr} by @meta{step} and return the result.  Both
@meta{expr} and @meta{step} must be expressions evaluating to a number
object; when @meta{step} is not given: it defaults to the fixnum
@code{1}.

As special case, when @meta{expr} is an identifier: the syntax expands
as follows:

@example
(post-incr! @meta{id} @meta{step})
@expansion{} (receive-and-return (v)
        @meta{id}
      (set! @meta{id} (+ @meta{id} @meta{step})))
@end example
@end deffn


@deffn Syntax @code{--} @meta{expr}
@deffnx Syntax @code{--} @meta{expr} @meta{step}
Decrement @meta{expr} by @meta{step} and return the result.  Both
@meta{expr} and @meta{step} must be expressions evaluating to a number
object; when @meta{step} is not given: it defaults to the fixnum
@code{1}.

As special case, when @meta{expr} is an identifier: the syntax expands
as follows:

@example
#!vicare
(-- @meta{id} @meta{step})
@expansion{} (begin
      (set! @meta{id} (- @meta{id} @meta{step}))
      @meta{id})
@end example
@end deffn


@deffn Syntax pre-decr! @meta{expr}
@deffnx Syntax pre-decr! @meta{expr} @meta{step}
Alias for @func{--}.
@end deffn


@deffn Syntax post-decr! @meta{expr}
@deffnx Syntax post-decr! @meta{expr} @meta{step}
Decrement @meta{expr} by @meta{step} and return the result.  Both
@meta{expr} and @meta{step} must be expressions evaluating to a number
object; when @meta{step} is not given: it defaults to the fixnum
@code{1}.

As special case, when @meta{expr} is an identifier: the syntax expands
as follows:

@example
(post-decr! @meta{id} @meta{step})
@expansion{} (receive-and-return (v)
        @meta{id}
      (set! @meta{id} (- @meta{id} @meta{step})))
@end example
@end deffn

@c page
@node iklib syntaxes misc
@subsection Miscellaneous syntaxes


@deffn Syntax endianness @meta{endianness-symbol}
Extend the syntax defined by @rnrs{6}.  The name of
@meta{endianness-symbol} must be a symbol describing an endianness.
Supported symbols are @code{big}, @code{little}, @code{network} an
@code{native}; @code{network} is converted to @code{big}, @code{native}
is converted to the return value of @code{(native-endianness)}.
@end deffn


@deffn {Fluid Syntax} __who__
A fluid syntax to be bound to the quoted name of the function being
executed; it can be used as argument for the @condition{who} condition
object.  It is meant to be used as follows:

@example
(define (func arg)
  (fluid-let-syntax
      ((__who__ (identifier-syntax (quote func))))
    ---))
@end example
@end deffn


@deffn {Identifier Syntax} __file__
Expand to a quoted string representing the source code location, for
example the source file pathname.
@end deffn


@deffn {Identifier Syntax} __line__
Expand to @false{} or a number representing the line number.
@end deffn


@deffn {Fluid Syntax} brace
A fluid syntax which is free to be bound to whatever user code needs.
When the Scheme code reader is in @code{#!vicare} mode: brace lists are
read as @func{brace} forms as follows:

@example
@{@}              @expansion{} (brace)
@{1 2 3@}         @expansion{} (brace 1 2 3)
@{1 . 2@}         @expansion{} (brace 1 . 2)
@end example
@end deffn


@deffn {Fluid Syntax} {<>}
A fluid syntax which is free to be bound to whatever user code needs.
It is meant to be a placeholder for some expression defined by the local
context; for example: it is used by the syntaxes @func{is-a?},
@func{slot-ref} and @func{slot-set!}.
@end deffn


@deffn Syntax begin-for-syntax @metao{body} @meta{body} @dots{}
@deffnx Syntax eval-for-expand @metao{body} @meta{body} @dots{}
Evaluate the @meta{body} forms at expand time; these syntaxes count as
definitions in a body.  Notice that definitions in the body are visible
by other code evaluated for expand:

@example
(begin-for-syntax
  (define a 1))

(begin-for-syntax
  (define b 2))

(begin-for-syntax
  (define c (+ a b)))

(define-syntax (doit stx)
  #`(quote (#,a #,b #,c)))

(doit)          @result{} (1 2 3)
@end example
@end deffn


@deffn Syntax set-cons! @meta{who} @meta{obj}
Expand to:

@example
(set! @meta{who} (cons @meta{obj} @meta{who}))
@end example
@end deffn


@deffn Syntax values->list @meta{expr}
Evaluate the expression and return its return values as a list.
Examples:

@example
(values->list 123)
@result{} (123)

(values->list (values 1 2 3))
@result{} (1 2 3)
@end example
@end deffn

@c page
@node iklib syntaxes properties
@subsection Syntactic binding properties


It is sometimes useful to attach properties to syntactic bindings; the
following @api{} does so.  The following functions will fail if the
argument @var{id} is not a bound identifier.

When writing a library making use of syntactic binding properties: we
must enable the option @code{visit-upon-loading} in the options clause
of the @code{library} form; @ref{iklib syntaxes libraries, Extended
@code{library} syntax}.  Without this option properties may not be
registered properly.


@defun syntactic-binding-putprop @var{id} @var{key} @var{value}
Like @func{putprop} for symbols, but set a property for the identifier
@var{id}.  @var{key} must be a symbol; @var{value} can be any values.
Return unspecified values.
@end defun


@defun syntactic-binding-getprop @var{id} @var{key}
Like @func{getprop} for symbols, but retrieve a property for the
identifier @var{id}.  @var{key} must be a symbol.  Return the property
value or @false{} if the property is not set.
@end defun


@defun syntactic-binding-remprop @var{id} @var{key}
Like @func{remprop} for symbols, but remove a property for the
identifier @var{id}; nothing happens if the property is not set.
@var{key} must be a symbol.  Return unspecified values.
@end defun


@defun syntactic-binding-property-list @var{id}
Like @func{property-list} for symbols, but retrieve the property list
for the identifier @var{id}.  Return the property list or null if no
property is set.
@end defun


We have to remember that when evaluating the syntax:

@example
(define-syntax @meta{lhs} @meta{rhs})
@end example

@noindent
the identifier @meta{lhs} is already bound when the expression
@meta{rhs} is evaluated to acquire the transformer function; the same
happens for:

@example
(letrec-syntax ((@meta{lhs} @meta{rhs}))
  @meta{body})
@end example

@noindent
but it does @strong{not} happen for:

@example
(let-syntax ((@meta{lhs} @meta{rhs}))
  @meta{body})
@end example

@noindent
when the expression @meta{rhs} is evaluated, the identifier @meta{lhs}
is still unbound.

So the following example will work:

@example
(define-syntax ciao
  (let ()
    (syntactic-binding-putprop #'ciao 'a 123)
    (lambda (stx) #t)))

(define-syntax (doit stx)
  (syntactic-binding-getprop #'ciao 'a))

(doit)          @result{} 123
@end example

@noindent
notice that here the syntax @func{ciao} is never used; the following
example will also work:

@example
(define-syntax (ciao stx)
  #t)

(define-syntax (doit stx)
  (syntactic-binding-getprop #'ciao 'a))

(begin-for-expand
  (syntactic-binding-putprop #'ciao 'a 123))

(doit)          @result{} 123
@end example

@noindent
and the following will work, too:

@example
(letrec-syntax
    ((ciao (let ()
             (syntactic-binding-putprop #'ciao 'a 123)
             (lambda (stx) #t))))
  (define-syntax (doit stx)
    (syntactic-binding-getprop #'ciao 'a))
  (doit))
@result{} 123
@end example

@noindent
to define a binding property for a syntax defined by @func{let-syntax}
we can do:

@example
(let-syntax ((ciao (lambda (stx) #t)))
  (define-syntax (doit stx)
    (syntactic-binding-getprop #'ciao 'a))
  (begin-for-expand
    (syntactic-binding-putprop #'ciao 'a 123))
  (doit))
@result{} 123
@end example

To define a binding property for a lexical variable bound by
@func{define}:

@example
(define ciao "ciao")

(define-syntax (doit stx)
  (syntactic-binding-getprop #'ciao 'a))

(begin-for-expand
  (syntactic-binding-putprop #'ciao 'a 123))

(doit)          @result{} 123
@end example

@noindent
and for one bound by @func{let}:

@example
(let ((ciao "ciao"))
  (define-syntax (doit stx)
    (syntactic-binding-getprop #'ciao 'a))
  (begin-for-expand
    (syntactic-binding-putprop #'ciao 'a 123))
  (doit))
@result{} 123
@end example

@c page
@node iklib syntaxes predaux
@subsection Predicate auxiliary functions


Predicate functions, both type predicates like @func{list?} and other
predicates, are used to validate procedure arguments and their return
values.  The predicates auxiliary functions @api{} assumes that it is
useful to associate to certain predicate procedures:

@itemize
@item
A procedure that validates a tuple of values and when failing: raises an
exception with condition object type
@condition{procedure-argument-violation}, @ref{iklib conditions procarg,
Procedure argument violations}.

@item
A procedure that validates a tuple of values and when failing: raises an
exception with condition object type
@condition{expression-return-value-violation}, @ref{iklib conditions
exprret, Expression return value violations}.
@end itemize

Such auxiliary functions are made available through syntactic binding
properties by just importing in the current lexical contour the
identifier bound to the predicate function.

As example, we can associate a procedure argument auxiliary function to
@func{list?} as follows:

@example
(define (list-procedure-argument who obj)
  (if (list? obj)
      obj
    (procedure-argument-violation who
      "expected list object as argument" obj)))

(begin-for-syntax
  (set-predicate-procedure-argument-validation! #'list?
    #'list-procedure-argument?))

((predicate-procedure-argument-validation list?) 'hey '(1 2 3))
@result{} (1 2 3)

((predicate-procedure-argument-validation list?) 'hey '#(1 2 3))
@error{} &procedure-argument-violation
@end example

@noindent
and we can associate a return value auxiliary function to @func{list?}
as follows:

@example
(define (list-return-value? who obj)
  (if (list? obj)
      obj
    (expression-return-value-violation who
      "expected list object as argument" obj)))

(begin-for-syntax
  (set-predicate-return-value-validation! #'list?
    #'list-return-value?))

((predicate-return-value-validation list?) 'hey '(1 2 3))
@result{} (1 2 3)

((predicate-return-value-validation list?) 'hey '#(1 2 3))
@error{} &expression-return-value-violation
@end example


@defun set-predicate-procedure-argument-validation! @var{pred-id} @var{valid-stx}
Specify that the predicate identifier @var{pred-id} is associated to the
procedure argument validation function resulting from the expansion and
evaluation of the syntax object @var{valid-stx}.  @var{valid-stx} is
stored as syntax object and it is expanded and evaluated at each use of
the validation function.
@end defun


@deffn Syntax predicate-procedure-argument-validation @meta{pred-id}
Expand into an expression representing the procedure argument validation
function associated to the predicate @meta{pred-id}.  If no validation
function is available: raise a syntax violation.
@end deffn


@defun set-predicate-return-value-validation! @var{pred-id} @var{valid-stx}
Specify that the predicate identifier @var{pred-id} is associated to the
return value validation function resulting from the evaluation of the
expansion and evaluation of the syntax object @var{valid-stx}.
@var{valid-stx} is stored as syntax object and it is expanded and
evaluated at each use of the validation function.
@end defun


@deffn Syntax predicate-return-value-validation @meta{pred-id}
Expand into an expression representing the return value validation
function associated to the predicate @meta{pred-id}.  If no validation
function is available: raise a syntax violation.
@end deffn

@c page
@node iklib syntaxes type-of
@subsection Determining the type of expressions


@deffn Syntax type-of @meta{expr}
This syntax is for interactive use only.  Fully expand the given
expression in the current lexical environment and return a structure of
type @objtype{retvals-signature} representing the types of the tuple of
returned values.  The expression is @strong{not} evaluated, only
expanded; this means that the expansion side effects are performed.

Example session at the @repl{}:

@example
vicare> (type-of (values))
$1 = #["retvals-signature" ()]

vicare> (type-of (values 1 2))
$1 = #["retvals-signature" (#'<fixnum> #'<fixnum>)]

vicare> (type-of 123)
$1 = #["retvals-signature" (#'<fixnum>)]

vicare> (type-of ((lambda (@{_ symbol@}) 'ciao)))
$1 = #["retvals-signature" (#'<symbol>)]
@end example
@end deffn


@defun print-identifier-info @var{id}
Given an identifier object: print on the current error port a report on
its properties as identifier; return unspecified values.
@end defun

@c page
@node iklib syntaxes expansion-of
@subsection Inspecting expansion results


@deffn Syntax expansion-of @meta{expr}
This syntax is mostly for interactive use.  Fully expand the given
expression in the current lexical environment and return a symbolic
expression representing the resulting invoke code.  The expression is
@strong{not} evaluated, only expanded; this means that the expansion
side effects are performed.

As a special case if @meta{expr} is recognised as a @func{define} or
@func{define*} syntax use:

@example
(define  . @meta{stuff})
(define* . @meta{stuff})
@end example

@noindent
the expansion will be performed as if @meta{expr} is:

@example
(internal-body (define  . @meta{stuff}) (void))
(internal-body (define* . @meta{stuff}) (void))
@end example

@noindent
and the definition extracted from the result and reformatted.

Example session at the @repl{}:

@example
vicare> (import (vicare expander tags))
vicare> (print-gensym #f)

vicare> (expansion-of (+ 1 2))
$1 = ((primitive +) (quote 1) (quote 2))

vicare> (expansion-of (lambda (a b) (+ a b)))
$1 = (lambda (a b) ((primitive +) a b))

vicare> (internal-body
          (define-syntax (doit stx)
            (syntax-case stx ()
              ((_ ?a ?b)
               #'(vector ?a ?b))))
          (expansion-of (doit 1 2)))
$1 = ((primitive vector) (quote 1) (quote 2))

vicare> (internal-body
          (define-struct alpha
            (a b c))
          (define O
            (alpha (1 2 3)))
          (expansion-of (slot-ref O a)))
$1 = (alpha-a O)

vicare> (expansion-of (define (fun a) (+ 1 a)))
$1 = (define fun (lambda (a) ((primitive +) (quote 1) a)))
@end example
@end deffn


@deffn Syntax visit-code-of @meta{macro-id}
This syntax is mostly for interactive use.  Given the identifier of a
locally defined macro keyword: expand into a quoted symbolic expression
representing the expanded macro transformer.

Example session at the @repl{}:

@example
vicare> (print-gensym #f)
vicare> (define-syntax syn (lambda (stx) #'(void)))
vicare> (visit-code-of syn)
$1 = (lambda (stx) #<syntax expr=(void))
@end example
@end deffn

@c page
@node iklib syntaxes optim-of
@subsection Inspecting optimisation results


@deffn Syntax optimisation-of @meta{expr}
This syntax is mostly for interactive use.  Fully expand the given
expression in the current lexical environment and apply the compiler's
optimisator to the resulting core language expression; return a symbolic
expression representing the resulting invoke code.  The expression is
@strong{not} evaluated, only expanded and optimised; this means that the
expansion side effects are performed.

@quotation
@strong{NOTE} Only expressions are expanded and optimised.  It makes no
sense to give a standalone @func{define} syntax to this macro; when a
standalone function definition is expanded and optimised: the function
is never called, so it is removed.
@end quotation

Example session at the @repl{}:

@example
vicare> (print-gensym #f)

vicare> (optimisation-of (+ 1 2))
$1 = 3
@end example
@end deffn

@c page
@node iklib syntaxes assembly-of
@subsection Inspecting assembly language results


@deffn Syntax assembly-of @meta{expr}
This syntax is mostly for interactive use.  Fully expand the given
expression in the current lexical environment and apply the compiler's
passes to the resulting core language expression as if to produce a code
object; return a list of sublists, each sublist representing assembly
language instructions for a code object.  The expression is @strong{not}
evaluated, only expanded and compiled to assembly; this means that the
expansion side effects are performed.

@quotation
@strong{NOTE} Only expressions are expanded and compiled.  It makes no
sense to give a standalone @func{define} syntax to this macro; when a
standalone function definition is expanded and optimised: the function
is never called, so it is removed.
@end quotation

@quotation
@strong{NOTE} At present the return value of this macro is not very
human friendly; some preprocessing and a specialised printer are needed.
@end quotation
@end deffn

@c page
@node iklib unwind-protect
@section The unwind--protection mechanism


Unwind--protection allows operations to be performed synchronously with
respect to the dynamic extent of a call to thunk; the mechanism is
sophisticated because there are multiple, sophisticated ways to exit the
dynamic extent of a function call.  The typical application is to
release resources, like input/output ports and database connections.
@ref{resources, Allocating and releasing resources}, for an overview of
resource management under @value{PRJNAME}.

To understand the unwind--protection mechanism we must understand the
concepts ``dynamic extent of a function call'' and ``dynamic
environment''.  @ref{scheme basic dynamic extent, Dynamic extent and the
dynamic environment}, for the meaning as defined by @rnrs{6}.
@ref{dynamic environment, Notes on the dynamic environment}, for further
explanations and examples.

@quotation
@strong{NOTE} The unwind protection mechanism may misbehave in some
cases, so do not trust it blindly (@pxref{iklib unwind-protect
problems}).
@end quotation

@menu
* iklib unwind-protect intro::       Introduction to the unwind
                                     protection mechanism.
* iklib unwind-protect syntaxes::    Unwind-protection syntaxes.
* iklib unwind-protect dynamic::     On the meaning of dynamic extent
                                     termination.
* iklib unwind-protect except 1::    Raising non-continuable exceptions
                                     from the thunk.
* iklib unwind-protect except 2::    Raising continuable exceptions
                                     from the thunk.
* iklib unwind-protect except 3::    Raising exceptions from the
                                     unwind handler.
* iklib unwind-protect loops::       Use with loop syntaxes.
* iklib unwind-protect returnable::  Use with returnable bodies.
* iklib unwind-protect coroutines::  Use with coroutines.
* iklib unwind-protect reenter::     Handling reentering continuations.
* iklib unwind-protect dyn-env::     Clean-up thunks and the dynamic
                                     environment.
* iklib unwind-protect problems::    Known problems.
@end menu

@c page
@node iklib unwind-protect intro
@subsection Introduction to the unwind--protection mechanism


The syntax @syntax{with-unwind-handler} implements the core mechanism;
@syntax{with-unwind-protection} is an alias for it.
@syntax{unwind-protect} offers a syntax similar to the one of the Common
Lisp macro with the same name.  The former is meant to be used as
follows:

@example
#!vicare
(import (vicare))

(let ((port (open-file-output-port "file.ext")))
  (with-unwind-handler
      (lambda (why)
        (close-output-port port))
    (lambda ()
      (put-bytevector port '#ve(ascii "ciao")))))

@end example

@noindent
and the latter as follows:

@example
#!vicare
(import (vicare))

(let ((port (open-file-output-port "file.ext")))
  (unwind-protect
      (put-bytevector port '#ve(ascii "ciao"))
    (close-output-port port)))
@end example

@noindent
first we allocate a resource (in this case the @var{port}); then we use
it in the body forms; finally we release it in the clean--up forms.

When using the mechanism:

@itemize
@item
We have to decide if we trust our code not to raise exceptions while evaluating the
in--guard and out--guard thunks of @func{dynamic-wind} calls.  These would be nasty
errors, because the dynamic environment would get corrupted and recovering correctly
might be impossible; so we must @strong{really} write and debug such in--guard and
out--guard thunks with care.

@item
We have to decide if we trust our code not to raise a second exception while serving
a first exception in an error handler.  Raising a continuable exception is fine only
if we actually continue.  Exceptions while handling exceptions are a hard problem to
solve in every language; the rough solution is to block exceptions raised by
exception handlers:

@lisp
(with-exception-handler
    (lambda (E)
      (with-blocked-exceptions
        (lambda ()
          (handle E))))
  (lambda ()
    (do-something-useful)))
@end lisp

@noindent
but it is not very satisfying.  Another possibility is:

@lisp
(define-condition-type &originally-raised
    &condition
  make-originally-raised-condition
  originally-raised-condition?
  (object originally-raised-object))

(with-exception-handler
    (lambda (E)
      (with-exception-handler
          (lambda (X)
            (raise-continuable
              (condition X
                (make-originally-raised-condition E))))
        (lambda ()
          (handle E))))
  (lambda ()
    (do-something-useful)))
@end lisp
@end itemize

If the bodacious answer to both the decisions is ``We trust'': we can nest at will
uses of @syntax{with-unwind-protection}:

@lisp
(define (outer)
  (with-unwind-protection
      (lambda (why)
        (outer-unwind-handler))
    (lambda ()
      (do-something-useful)
      (inner))))

(define (inner)
  (with-unwind-protection
      (lambda (why)
        (inner-unwind-handler))
    (lambda ()
      (do-some-other-useful-thing))))

(outer)
@end lisp

@noindent
@strong{beware}: unwind handlers are evaluated in the dynamic environment of the use
of @syntax{with-unwind-protection}.

Otherwise we must avoid error handlers to cause the execution flow to
cross an unwind protection boundary; we can do it by using compensations
and the standard @syntax{guard} syntax:

@lisp
(define (outer)
  (push-compensation-thunk
    (lambda ()
      (outer-unwind-handler)))
  (do-something-useful)
  (inner))

(define (inner)
  (push-compensation-thunk
    (lambda ()
      (inner-unwind-handler)))
  (do-some-other-useful-thing))

(with-compensations
  (with-blocked-exceptions
    (lambda ()
      (guard (E ((type-one-error? E)
                 (handle E))
                (else
                 (do-something-dammit!!!)))
        (outer)))))
@end lisp

@noindent
or by using the compensations and the @syntax{try} syntax defined by
@value{PRJNAME}:

@lisp
(define (outer)
  (push-compensation-thunk
    (lambda ()
      (outer-unwind-handler)))
  (do-something-useful)
  (inner))

(define (inner)
  (push-compensation-thunk
    (lambda ()
      (inner-unwind-handler)))
  (do-some-other-useful-thing))

(with-compensations
  (with-blocked-exceptions
    (lambda ()
      (try
          (outer)
        (catch E
          ((&type-one)
           (handle E))
          (else
           (do-something-dammit!!!)))))))
@end lisp

@noindent
@strong{beware}: compensation handlers are evaluated in the dynamic environment of
the use of @syntax{with-compensations}.

@c page
@node iklib unwind-protect syntaxes
@subsection Unwind--protection syntaxes


@deffn Syntax with-unwind-handler @meta{unwind-handler} @meta{thunk}
@deffnx Syntax with-unwind-protection @meta{unwind-handler} @meta{thunk}
These two syntaxes are aliases.  Call @meta{thunk} and then, when the
dynamic extent of the call @strong{terminates}, call the procedure
@meta{unwind-handler}.  When @meta{thunk} performs a normal return: the
return values of @meta{thunk} become the return values of
@func{with-unwind-handler}.

When called: @meta{unwind-handler} is applied to a Scheme symbol
representing the cause of the call: @samp{return}, @samp{escape},
@samp{exception}.  The argument @meta{unwind-handler} comes before the
argument @meta{thunk} for uniformity with @func{with-exception-handler},
@ref{stdlib exceptions exceptions, with-exception-handler}.

Notice that a function tail--call in @meta{thunk} is @strong{not} a
tail--call for @syntax{with-unwind-protection}.
@end deffn


@deffn Syntax unwind-protect @meta{body} @metao{cleanup} @meta{cleanup} ...
Simple wrapper for @syntax{with-unwind-protection} that provides a
syntax similar to that of Common Lisp's macro.  It is expanded to:

@example
(with-unwind-protection
    (lambda (dummy) @metao{cleanup} @meta{cleanup} ...)
  (lambda () @meta{body}))
@end example
@end deffn

@c page
@node iklib unwind-protect dynamic
@subsection On the meaning of dynamic extent termination


The concept of dynamic extent @dfn{termination} is defined by
@value{PRJNAME}'s unwind--protection mechanism and it is not a @rnrs{6}
concept.  In this discussion, we consider the syntax use:

@example
(with-unwind-protection @meta{unwind-handler} @meta{thunk})
@end example

@noindent
the procedure @meta{unwind-handler} is called when the dynamic extent of
the invocation of @meta{thunk} terminates; dynamic extent
@strong{termination} is different from dynamic extent @strong{exiting}
as determined by @func{dynamic-wind} (@pxref{dynamic-wind}).  When the
execution flow exits the dynamic extent of a function call: such extent
might also terminate, but not all the exits are also terminations.

The dynamic extent of a call to @meta{thunk} @strong{is} terminated, and
so @meta{unwind-handler} @strong{is} invoked, when:

@itemize
@item
@meta{thunk} performs a normal return.  @meta{unwind-handler} is applied
to the symbol @samp{return}.

@item
@meta{thunk} raises a continuable or non--continuable exception that is
intercepted by a use of @syntax{guard}, but only when a clause of
@syntax{guard} has a test expression returning non--false.

@lisp
(guard (E (@meta{test} @meta{expr}))
  (with-unwind-handler @meta{unwind-handler} @meta{thunk}))
@end lisp

This is what happens:

@enumerate
@item
The clause's @meta{test} expression is evaluated in the dynamic
environment of the use of @syntax{guard} and it returns non--false.

@item
@meta{unwind-handler} is applied to the symbol @samp{exception}, in the
dynamic environment of the use of @syntax{with-unwind-protection}, and
its return values discarded.

@item
The clause's @meta{expr} is evaluated in the dynamic environment of the
use of @syntax{guard} and its return values are returned to the
continuation of @syntax{guard}.
@end enumerate

@item
@meta{thunk} executes a use of the fluid syntaxes @syntax{break},
@syntax{continue} or @syntax{return}, as defined by the library
@library{vicare}, to escape from a form that encloses an
unwind--protection syntax.  @meta{unwind-handler} is applied to the
symbol @samp{escape}.

As bound by the loop syntaxes @syntax{while}, @syntax{until}, @dots{}
and the syntax @syntax{returnable}: these fluid syntaxes reinstate a
continuation at the beginning or outside of @syntax{while},
@syntax{until}, @dots{} and @syntax{returnable} and perform special
operations to terminate the dynamic extent of the call to @meta{thunk}
in an unwind--protection form.
@end itemize

@c ------------------------------------------------------------------------

The dynamic extent of a call to @meta{thunk} is @strong{not} terminated,
and so @meta{unwind-handler} is @strong{not} invoked, when:

@itemize
@item
@meta{thunk} raises a continuable exception by calling
@func{raise-continuable}, and such call performs a normal return to
@meta{thunk}.

@item
@meta{thunk} raises a continuable or non--continuable exception and an
exception handler terminates the process (for example by calling
@func{exit}).

@item
The unwind--protection syntax is used by a coroutine and @func{yield} is
called from within @meta{thunk} to hand control to another coroutine.

@item
An escape procedure is called from within @meta{thunk} to reinstate a
continuation outside @meta{thunk}, and the call to the escape procedure
is @strong{not} interfaced with the unwind--protection mechanism to
terminate the dynamic extent of the call to @meta{thunk}.
@end itemize

@c ------------------------------------------------------------------------

About the termination of the dynamic extent of @meta{thunk}, we must
acknowledge that:

@itemize
@item
There is @strong{no} guarantee that: after exiting, without terminating,
the dynamic extent of @meta{thunk} by reinstating a continuation, such
extent will be reentered later and continue to termination.

@item
If the dynamic extent of @meta{thunk} is terminated and an attempt to
reenter @meta{thunk} is performed: an exception is raised with compound
condition object containing a @condition{non-reinstatable} component
(@pxref{&non-reinstatable}).

@item
Obviously, if a call to @meta{unwind-handler} raises an exception: the
clean--up operations performed by @meta{unwind-handler} may fail, in
whole or in part, possibly leaving behind unreleased resources.

@item
If the call to @meta{thunk} raises an exception and a use of
@syntax{guard} intercepts it: if a test expression in a clause of
@syntax{guard} raises an exception, the @meta{unwind-handler} may not be
called.

While it is possible to @func{raise} any object: it is better to always
raise a condition object (possibly compound), so that the test
expressions in @syntax{guard} uses can just be condition object type
predicates; such predicates never raise exceptions.
@end itemize

@c ------------------------------------------------------------------------

If @meta{unwind-handler} raises an exception: such exception is blocked
and discarded.

@c page
@node iklib unwind-protect except 1
@subsection Raising non--continuable exceptions from the thunk


A non--continuable exception is raised with @func{raise}, which can be
applied to any object; the argument to @func{raise} becomes the ``raised
object''.  The purpose of raising a non--continuable exception is to
cause the application of a function, the current exception handler, to
the raised object; the exception handler is called in the dynamic
environment of the call to @func{raise}.

The execution flow is @strong{not} meant return to the caller of
@func{raise}, so the exception handler has only two options:

@enumerate
@item
Reinstate a previously saved continuation to jump out of the dynamic
environment in which the exception was raised.  The following example
shows the basic mechanism:

@example
(import (vicare))

(call/cc
    (lambda (escape)
      (with-exception-handler
          escape
        (lambda ()
          (raise 1)))))
@result{} 1
@end example

@noindent
Reinstating a continuation to jump out of the exception handler is what
the standard @syntax{guard} syntax does when it handles an exception;
@syntax{guard} does more than this.

@item
Raise the exception again, causing the invocation of the upper level
exception handler.  The following example shows the basic mechanism:

@example
(import (vicare))

(call/cc
    (lambda (escape)
      (with-exception-handler
          escape
        (lambda ()
          (with-exception-handler
              (lambda (E)
                (raise E))
            (lambda ()
              (raise 1)))))))
@result{} 1
@end example
@end enumerate

@c ------------------------------------------------------------------------

@unnumberedsubsec Handling exceptions by escaping

This is @strong{not} the correct way of interfacing with the
unwind--protection mechanism.  In the following example we see that
escaping from the exception handler skips the call to the
@meta{unwind-handler}.

@example
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(with-result
  (call/cc
      (lambda (escape)
        (with-exception-handler
            (lambda (E)
              (add-result 'exception-handler)
              (escape E))
          (lambda ()
            (with-unwind-protection
                (lambda (why)
                  (add-result 'cleanup))
              (lambda ()
                (add-result 'thunk-in)
                (raise 123)
                (add-result 'thunk-out))))))))
@result{} (123 (thunk-in exception-handler))
@end example

@c ------------------------------------------------------------------------

@unnumberedsubsec Handling exceptions with @syntax{guard}

This is the correct way of interfacing with the unwind--protection
mechanism.

In the following example: the @meta{thunk} raises a non--continuable
exception, which is catched by the @syntax{else} clause of a
@syntax{guard} use; this is equivalent to escaping from an exception
handler, but it does evaluate the @meta{unwind-handler}.  We can see the
forms evaluation order.

@example
#!vicare
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(with-result
  (guard (E (else
             (add-result 'guard-else)
             E))
    (with-unwind-protection
        (lambda (why)
          (add-result 'cleanup))
      (lambda ()
        (add-result 'thunk-in)
        (raise 2)
        (add-result 'thunk-out)
        1))))
@result{} (2 (thunk-in cleanup guard-else))
@end example

In the following example: the @meta{thunk} raises a non--continuable
exception, which is catched by the clause of a @syntax{guard} use; the
clause has test and expression.  We can see the forms evaluation order.

@example
#!vicare
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(with-result
  (guard (E ((begin
               (add-result 'guard-test)
               #t)
             (add-result 'guard-expr)
             E))
    (with-unwind-protection
        (lambda (why)
          (add-result 'cleanup))
      (lambda ()
        (add-result 'thunk-in)
        (raise 2)
        (add-result 'thunk-out)
        1))))
@result{} (2 (thunk-in guard-test cleanup guard-expr))
@end example

The following example with two nested @syntax{guard} uses and two nested
@func{dynamic-wind} calls, makes it even more clear the sequence of
forms evaluation.  The clause of the inner @syntax{guard} has test
expression returning @false{}, so the exception is re--raised with
@func{raise-continuable}.

@example
#!vicare
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(with-result
  (guard (E ((begin
               (add-result 'outer-guard-test)
               #t)
             (add-result 'outer-guard-expr)
             E))
    (guard (E ((begin
                 (add-result 'inner-guard-test)
                 #f)
               (add-result 'inner-guard-expr)
               E))
      (dynamic-wind
          (lambda ()
            (add-result 'outer-before))
          (lambda ()
            (with-unwind-protection
                (lambda (why)
                  (add-result 'cleanup))
              (lambda ()
                (dynamic-wind
                    (lambda ()
                      (add-result 'inner-before))
                    (lambda ()
                      (add-result 'thunk-in)
                      (raise 2)
                      (add-result 'thunk-out)
                      1)
                    (lambda ()
                      (add-result 'inner-after))))))
          (lambda ()
            (add-result 'outer-after))))))
@result{} (2 (outer-before inner-before thunk-in inner-after outer-after
       inner-guard-test
       outer-before inner-before inner-after outer-after
       outer-guard-test
       outer-before inner-before inner-after cleanup outer-after
       outer-guard-expr))
@end example

Let's describe the sequence of operations:

@table @code
@item outer-before inner-before thunk-in
Everything goes fine until the @meta{thunk} reaches @code{thunk-in}.

@item *
The @meta{thunk} raises an exception.  The exception handler of the
inner @syntax{guard} is applied to the raised object.

@item inner-after outer-after
The continuation of the inner @syntax{guard} use is reinstated, the
dynamic extent of the call to @meta{thunk} is exited: the dynamic
environment unwinds.

@item inner-guard-test
The clause test expression of the inner @syntax{guard} is evaluated in
the dynamic environment of the @syntax{guard} use: it returns @false{}.

@item outer-before inner-before
The continuation of the inner @syntax{guard} exception handler is
reinstated, the dynamic extent of the call to @meta{thunk} is reentered:
the dynamic environment is restored.

@item *
The exception is raised again by applying @func{raise-continuable} to
the same raised object.  The exception handler of the outer
@syntax{guard} is applied to the raised object.

@item inner-after outer-after
The continuation of the outer @syntax{guard} use is reinstated, the
dynamic extent of the call to @meta{thunk} is exited: the dynamic
environment unwinds.

@item outer-guard-test
The clause test expression of the outer @syntax{guard} is evaluated in
the dynamic environment of the outer @syntax{guard}: it returns @true{}.

@item outer-before inner-before
The continuation of the of the outer @syntax{guard} exception handler is
reinstated, the dynamic extent of the call to @meta{thunk} is entered:
the dynamic environment is restored.

@item inner-after cleanup outer-after
The continuation of the outer @syntax{guard} clause is reinstated, the
the dynamic extent of the call to @meta{thunk} is exited: the dynamic
environment unwinds.  While unwinding: the @meta{thunk} is found
terminated and the @meta{unwind-handler} is called in the dynamic
environment of the @syntax{with-unwind-protection} use.

@item outer-guard-expr
The clause expression of the outer @syntax{guard} is evaluated in the
dynamic environment of the outer @syntax{guard}.
@end table

That's Scheme!

@c page
@node iklib unwind-protect except 2
@subsection Raising continuable exceptions from the thunk


A continuable exception is raised with @func{raise-continuable} and it
is a way to resume the execution of a chunk of code after raising an
exception.  This example shows the basic mechanism:

@example
(import (rnrs))
(with-exception-handler
    (lambda (E)
      (+ E 2))
  (lambda ()
    (raise-continuable 1)))
@result{} 3
@end example

The handling of a continuable exception can be the same of the handling
of a non--continuable exception; in addition the exception handler is
allowed to return.  In the latter case the dynamic extent of the call to
@meta{thunk} is @strong{not} exited, so @meta{unwind-handler} is not
called.

The following example shows what happens when @meta{thunk} raises a
continuable exception:

@example
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(with-result
  (with-exception-handler
      (lambda (E)
        (add-result 'exception-handler)
        (+ E 2))
    (lambda ()
      (with-unwind-protection
          (lambda (why)
            (add-result 'cleanup))
        (lambda ()
          (add-result 'thunk-in)
          (begin0
              (raise-continuable 1)
            (add-result 'thunk-out)))))))
@result{} (3 (thunk-in exception-handler thunk-out cleanup))
@end example

@c page
@node iklib unwind-protect except 3
@subsection Raising exceptions from the unwind handler


When a thunk raises an exception and the current exception handler
raises another exception: the original exception is dropped if no
specific action is taken.  This is a common problem.  The following
example shows the mechanism.

@example
(import (vicare))

(call/cc
    (lambda (escape)
      (with-exception-handler
          escape
        (lambda ()
          (with-exception-handler
              (lambda (E)
                (raise 2))
            (lambda ()
              (raise 1)))))))
@result{} 2
@end example

What happens if @meta{unwind-handler} raises an exception?  It was
decided that such exceptions are to be blocked and discarded;
@meta{unwind-handler} procedures have to take care of themselves,
handling their own errors.  The following example shows the mechanism.

@example
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(with-result
  (guard (E (else
             (add-result 'guard-else)
             E))
    (with-unwind-protection
        (lambda (why)
          (add-result 'cleanup-in)
          (raise 2)
          (add-result 'cleanup-out))
      (lambda ()
        (add-result 'thunk-in)
        (raise 1)
        (add-result 'thunk-out)))))
@result{} (1 (thunk-in cleanup-in guard-else))
@end example

@c page
@node iklib unwind-protect loops
@subsection Use with loop syntaxes


The unwind--protection mechanism has special integration with the loop
syntaxes defined by @library{vicare}; if an unwind--protection syntax is
used in the body of a loop as defined by @syntax{do}, @syntax{while},
@syntax{until}, @syntax{for} and @syntax{break} or @syntax{continue} are
used in the body forms: the cleanup forms are evaluated correctly.  We
have to remember that @syntax{break} and @syntax{continue} are
implemented by escaping continuations.

This example shows breaking out of a @syntax{while} syntax; the body and
the unwind handler are evaluated only once; @func{exit} is never called.

@example
#!vicare
(import (vicare))
(define x 3)
(define y #f)
(while (positive? x)
  (with-unwind-protection
      (lambda (why)
        (set! y #t))
    (lambda ()
      (-- x)
      (break)
      (exit))))
x @result{} 2
y @result{} #t
@end example

This example shows using @syntax{continue} in a @syntax{while} syntax;
the body and the unwind handler are evaluated @math{3} times;
@func{exit} is never called.

@example
#!vicare
(import (vicare))
(define x 3)
(define y 0)
(while (positive? x)
  (with-unwind-protection
      (lambda (why)
        (++ y))
    (lambda ()
      (-- x)
      (continue)
      (exit))))
x @result{} 0
y @result{} 3
@end example

@c page
@node iklib unwind-protect returnable
@subsection Use with returnable bodies


The unwind--protection mechanism has special integration with the
@syntax{returnable} syntax defined by @library{vicare}; if an
unwind--protection syntax is used in the body of @syntax{returnable} and
@syntax{return} is used in the body forms: the unwind handler is
evaluated correctly.  We have to remember that @syntax{return} is
implemented by an escaping continuation.

@example
#!vicare
(import (vicare))
(define y #f)
(returnable
  (with-unwind-protection
      (lambda (why)
        (set! y #t))
    (lambda ()
      (return 1))))
@result{} 1
y @result{} #t
@end example

@c page
@node iklib unwind-protect coroutines
@subsection Use with coroutines


Using the unwind--protection mechanism with coroutines is fine;
coroutines use @func{yield} to save the current continuation, give
control to the next coroutine and come back later; this mechanism does
not cause the @meta{unwind-handler} evaluation.

The following sample code finishes with the given return values and
lines printed:

@example
(import (vicare))

(define (print template . args)
  (apply fprintf (current-error-port) template args)
  (yield))

(define a #f)
(define b #f)
(define c #f)

(concurrently
  (lambda ()
    (unwind-protect
        (begin
          (set! a 1.1)
          (print "unwind-protect sub 1.1: ~a\n" a)
          (set! a 1.2)
          (print "unwind-protect sub 1.2: ~a\n" a)
          (set! a 1.3)
          (print "unwind-protect sub 1.3: ~a\n" a))
      (set! a 1.4)))
  (lambda ()
    (unwind-protect
        (begin
          (set! b 2.1)
          (print "unwind-protect sub 2.1: ~a\n" b)
          (set! b 2.2)
          (print "unwind-protect sub 2.2: ~a\n" b)
          (set! b 2.3)
          (print "unwind-protect sub 2.3: ~a\n" b))
      (set! b 2.4)))
  (lambda ()
    (unwind-protect
        (begin
          (set! c 3.1)
          (print "unwind-protect sub 3.1: ~a\n" c)
          (set! c 3.2)
          (print "unwind-protect sub 3.2: ~a\n" c)
          (set! c 3.3)
          (print "unwind-protect sub 3.3: ~a\n" c))
      (set! c 3.4))))

(values a b c)
@result{} 1.4 2.4 3.4
@print{} unwind-protect sub 1.1: 1.1
@print{} unwind-protect sub 2.1: 2.1
@print{} unwind-protect sub 1.2: 1.2
@print{} unwind-protect sub 3.1: 3.1
@print{} unwind-protect sub 2.2: 2.2
@print{} unwind-protect sub 1.3: 1.3
@print{} unwind-protect sub 3.2: 3.2
@print{} unwind-protect sub 2.3: 2.3
@print{} unwind-protect sub 3.3: 3.3
@end example

@c page
@node iklib unwind-protect reenter
@subsection Handling reentering continuations


After the @meta{unwind-handler} is called: we do @strong{not} want the
execution flow to reenter the @meta{thunk} in the same dynamic extent.
After the dynamic extent of a call to @meta{thunk} terminates, and the
@meta{unwind-handler} is called: we are forbidden to reenter the
@meta{thunk}; if we try to reenter: an exception of type
@condition{non-reinstatable} is raised.

The first problem with reentering is that the code in the @meta{thunk}
expects invariants in the state of the process that are no longer true;
for example: if @meta{unwind-handler} closes an input/output port, the
@meta{thunk} still expects it to be open.

Reentering might happen, for example, when using the @syntax{amb}
operator in the @meta{thunk}, @libsref{amb, McCarthy's @syntax{amb}
operator}.  This means we must be careful to use @syntax{amb} in a
@meta{thunk} only when the whole search never crosses the unwind
protection contour.

The following example shows how calling an escape procedure created in
the @meta{thunk} of a @syntax{with-unwind-protection} causes the
exception to be raised:

@example
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(with-result
  (guard (E ((non-reinstatable-violation? E)
             (add-result 'violation)
             #t)
            (else E))
    (let ((rv (with-unwind-protection
                  (lambda (why)
                    (add-result 'cleanup))
                (lambda ()
                  (add-result 'body-in)
                  (begin0
                      (call/cc values)
                    (add-result 'body-out))))))
      (cond ((procedure? rv)
             (add-result 'reinstating)
             (rv 123))
            (else
             (add-result 'returning)
             rv)))))
@result{} (#t (body-in body-out cleanup reinstating violation))
@end example

@c page
@node iklib unwind-protect dyn-env
@subsection Clean--up thunks and the dynamic environment


As @rnrs{6} states:

@quotation
Some operations described in the report acquire information in addition
to their explicit arguments from the @emph{dynamic environment}.  For
example, @func{call/cc} accesses an implicit context established by
@func{dynamic-wind}, and the @func{raise} procedure accesses the current
exception handler.
@end quotation

@noindent
the typical example of values from the dynamic environment is
parameters, which indeed are implemented on top of @func{dynamic-wind}
(@pxref{iklib parameters}).  When using the unwind--protection
mechanism:

@example
(with-unwind-protection @meta{unwind-handler} @meta{thunk})
@end example

@noindent
the procedure @meta{unwind-handler} is called in the dynamic environment
of the use of @syntax{with-unwind-protection}.

For example, when escaping from @meta{thunk} with @syntax{return}:

@example
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(define parm
  (make-parameter #f))

(with-result
  (parametrise ((parm 'outer-parm))
    (returnable
      (parametrise ((parm 'inner-parm))
        (with-unwind-protection
            (lambda (why)
              (add-result 'cleanup-in)
              (add-result (parm))
              (add-result 'cleanup-out))
          (lambda ()
            (add-result 'thunk-in)
            (add-result (parm))
            (return 2)
            (add-result 'thunk-out)
            1))))))
@result{} (2 (thunk-in inner-parm
       cleanup-in inner-parm cleanup-out))
@end example

@noindent
we see that, even though @syntax{return} reinstates the continuation of
@syntax{returnable}: @meta{unwind-handler} gathers the parameter value from
inside the use of @syntax{returnable}.

Even more descriptive is the case of raising an exception from
@meta{thunk} and catching it with @syntax{guard}:

@example
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(define parm
  (make-parameter #f))

(with-result
  (parametrise ((parm 'outer-parm))
    (guard (E ((begin
                 (add-result 'guard-test-in)
                 (add-result (parm))
                 (add-result 'guard-test-out)
                 #t)
               (add-result 'guard-expr-in)
               (add-result (parm))
               (add-result 'guard-expr-out)
               E))
      (parametrise ((parm 'inner-parm))
        (with-unwind-protection
            (lambda (why)
              (add-result 'cleanup-in)
              (add-result (parm))
              (add-result 'cleanup-out))
          (lambda ()
            (add-result 'thunk-in)
            (add-result (parm))
            (raise 2)
            (add-result 'thunk-out)
            1))))))
@result{} (2 (thunk-in inner-parm
       guard-test-in outer-parm guard-test-out
       cleanup-in inner-parm cleanup-out
       guard-expr-in outer-parm guard-expr-out))
@end example

@noindent
both @meta{thunk} and @meta{unwind-handler} gather the inner value,
while the test and expression of the @syntax{guard} clause gather the
outer value, even though the execution order is intermixed.

Changing the environment inside @meta{thunk} does not affect
@meta{unwind-handler}:

@example
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(define parm
  (make-parameter #f))

(with-result
  (parametrise ((parm 'outer-parm))
    (with-unwind-protection
        (lambda (why)
          (add-result 'cleanup-in)
          (add-result (parm))
          (add-result 'cleanup-out))
      (lambda ()
        (parametrise ((parm 'inner-parm))
          (add-result 'thunk-in)
          (add-result (parm))
          (add-result 'thunk-out)
          1)))))
@result{} (1 (thunk-in inner-parm thunk-out
       cleanup-in outer-parm cleanup-out))

(with-result
  (returnable
    (parametrise ((parm 'outer-parm))
      (with-unwind-protection
          (lambda (why)
            (add-result 'cleanup-in)
            (add-result (parm))
            (add-result 'cleanup-out))
        (lambda ()
          (parametrise ((parm 'inner-parm))
            (add-result 'thunk-in)
            (add-result (parm))
            (return 2)
            (add-result 'thunk-out)
            1))))))
@result{} (2 (thunk-in inner-parm
       cleanup-in outer-parm cleanup-out))
@end example

@c page
@node iklib unwind-protect problems
@subsection Known problems


The unwind protection mechanism may misbehave in some cases.
Specifically the unwind handler may not be called in the following
cases:

@itemize
@item
An exception is raised by a thunk and, while handling it, a second
exception is raised.

@item
An exception is raised by the in--guard or out--guard thunks of a call
to @func{dynamic-wind}.
@end itemize

@c ------------------------------------------------------------------------

@unnumberedsubsec Raising exceptions from an exception handler

In the following example an exception is raised by an exception handler:
the unwind handler is called, but the original exception is lost.

@example
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(with-result
  (guard (E (else
             (add-result 'guard-else)
             E))
    (with-exception-handler
        (lambda (E)
          (add-result 'exception-handler)
          (raise 2))
      (lambda ()
        (with-unwind-protection
            (lambda (why)
              (add-result 'unwind-handler))
          (lambda ()
            (dynamic-wind
                (lambda ()
                  (add-result 'in-guard))
                (lambda ()
                  (add-result 'thunk-in)
                  (raise 1)
                  (add-result 'thunk-out))
                (lambda ()
                  (add-result 'out-guard)))))))))
@result{} (2 (in-guard
       thunk-in
       exception-handler
       out-guard
       in-guard out-guard unwind-handler
       guard-else))
@end example

@c ------------------------------------------------------------------------

@unnumberedsubsec Raising exceptions from a @syntax{guard}'s test

In the following example an exception is raised from a @syntax{guard}'s
test expression: the unwind handler is @strong{not} called and the
original exception is lost.

@example
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(with-result
  (guard (E (else
             (add-result 'outer-guard-else)
             E))
    (guard (E ((begin
                 (add-result 'inner-guard-test)
                 (raise 2))
               E))
      (with-unwind-protection
          (lambda (why)
            (add-result 'unwind-handler))
        (lambda ()
          (dynamic-wind
              (lambda ()
                (add-result 'in-guard))
              (lambda ()
                (add-result 'thunk-in)
                (raise 1)
                (add-result 'thunk-out))
              (lambda ()
                (add-result 'out-guard))))))))
@result{} (2 (in-guard
       thunk-in
       out-guard
       inner-guard-test
       outer-guard-else))
@end example

@c ------------------------------------------------------------------------

@unnumberedsubsec Raising exceptions from @func{dynamic-wind} guards

In the following example an exception is raised from a
@func{dynamic-wind}'s in--guard thunk: the unwind handler is
@strong{not} called and the original exception is lost.

@example
(with-result
  (guard (E (else
             (add-result 'guard-else)
             E))
    (dynamic-wind
        (let ((flag #f))
          (lambda ()
            (cond (flag
                   (add-result 'in-guard/raise)
                   (raise 2))
                  (else
                   (set! flag #t)
                   (add-result 'in-guard)))))
        (lambda ()
          (with-unwind-handler
              (lambda (E)
                (add-result 'unwind-handler))
            (lambda ()
              (add-result 'thunk-in)
              (raise 1))))
        (lambda ()
          (add-result 'out-guard)))))
@result{} (2 (in-guard
       thunk-in
       out-guard
       in-guard/raise
       guard-else))
@end example

@c page
@node iklib compensations
@section Compensation stacks


@cindex Compensation stacks
@cindex Stacks of compensation thunks
@cindex Releasing asynchronous resources
@cindex Asynchronous resources, releasing


Compensation stacks allow us to write code to allocate resources near
the code that releases them; @ref{resources, Allocating and releasing
resources}, for an overview of resource management under
@value{PRJNAME}.  Compensation stacks are described in:

@quotation
Westley Weimer, George C. Necula.  ``Finding and Preventing Run--Time
Error Handling Mistakes''.  In Proceedings of the @acronym{ACM}
Conference on Object--Oriented Programming, Systems, Languages, and
Applications, 2004.
@end quotation

@value{PRJNAME} implements compensation stacks on top of the unwind
protection mechanism, which allows operations to be performed
synchronously with respect to the dynamic extent of a call to thunk.
@ref{iklib unwind-protect, The unwind--protection mechanism}.


@menu
* iklib compensations usage::   Basic compensations usage.
* iklib compensations api::     Compensations @api{}.
@end menu

@c page
@node iklib compensations usage
@subsection Basic compensations usage


A @dfn{compensation} is a chunk of code that undoes a resource
allocation performed in another chunk, example:

@example
(define port
  (open-file-input-port "/tmp/proof.1"))
@end example

@noindent
must be ''compensated'' by:

@example
(close-port port)
@end example

@noindent
with the compensations stack such code can be written:

@example
(with-compensations
  (letrec
      ((port (compensate
                 (open-file-input-port "/tmp/proof.1")
               (with
                 (close-port port)))))
    (make-use-of port)))
@end example

@noindent
or:

@example
(with-compensations
  (define port
    (compensate
        (open-file-input-port "/tmp/proof.1")
      (with
        (close-port port))))
  (make-use-of port))
@end example

Compensation forms are embedded in a closure and pushed on a stack, so
that, in case of error, it is possible to evaluate them in
allocation--reversed order.

A form that makes use of a compensation stack looks like this:

@example
(with-compensations
  (compensate
      ALLOC-FORMS-1
    (with RELEASE-FORMS-1))
  (compensate
      ALLOC-FORMS-2
    (with RELEASE-FORMS-2))
  BODY-FORMS)
@end example

@noindent
both @func{with-compensations} and @func{compensate} are syntaxes.  If
no error occurs the order of evaluation is:

@example
ALLOC-FORMS-1
ALLOC-FORMS-2
BODY-FORMS
RELEASE-FORMS-2
RELEASE-FORMS-1
@end example

@noindent
if an error occurs in @code{BODY-FORMS}, the order of evaluation is:

@example
ALLOC-FORMS-1
ALLOC-FORMS-2
BODY-FORMS
RELEASE-FORMS-2
RELEASE-FORMS-1
@end example

@noindent
if an error occurs in @code{ALLOC-FORMS-2}, the order of evaluation is:

@example
ALLOC-FORMS-1
ALLOC-FORMS-2
RELEASE-FORMS-1
@end example

@noindent
if an error occurs in @code{ALLOC-FORMS-1}, the order of evaluation is:

@example
ALLOC-FORMS-1
@end example

@noindent
if an error occurs in @code{RELEASE-FORMS-1}, the order of evaluation is:

@example
ALLOC-FORMS-1
ALLOC-FORMS-2
BODY-FORMS
RELEASE-FORMS-2
RELEASE-FORMS-1
@end example

@noindent
if an error occurs in @code{RELEASE-FORMS-2}, the order of evaluation is:

@example
ALLOC-FORMS-1
ALLOC-FORMS-2
BODY-FORMS
RELEASE-FORMS-2
RELEASE-FORMS-1
@end example

So @func{with-compensations} tries to evaluate all the release forms,
despite errors.  Of course if an error occurs in the middle of a set of
forms:

@example
(first-form)   ;evaluated
(raise 'here)
(third-form)   ;not evaluated
@end example

@noindent
the forms before the error are evaluated, while the forms after the
error are not.

A variant of @func{with-compensations} exists to evaluate the
compensation forms only in case of error:

@example
(with-compensations/on-error
  (compensate
      ALLOC-FORMS-1
    (with RELEASE-FORMS-1))
  (compensate
      ALLOC-FORMS-2
    (with RELEASE-FORMS-2))
  BODY-FORMS)
@end example

@noindent
if no error occurs the order of evaluation is:

@example
ALLOC-FORMS-1
ALLOC-FORMS-2
BODY-FORMS
@end example

@noindent
while if an error occurs the evaluation is equal to the cases of
@func{with-compensations}.  The ``on error'' variant is useful in
constructors and initialisation functions, where we want to run the
compensations only if an error occurs; if no error is raised, we just
want the constructor to return.

@c page
@node iklib compensations api
@subsection Compensations @api{}


The compensations mechanism is built on top of the unwind protection
mechanism:

@itemize
@item
All the @meta{alloc} and @meta{body} forms end in the body of a thunk;
the compensations are evaluated when the dynamic extent of the call to
such thunk is terminated, as defined by the unwind protection mechanism.

@item
All the @meta{release} forms end in the body of a clean--up procedure;
such forms are evaluated in the @strong{dynamic environment of the
syntax use that allocates the compensations stack}.
@end itemize


@deffn Syntax with-compensations @metao{body} @meta{body} @dots{}
Allocate a new compensations stack, then evaluate all the @meta{body}
forms in the given order.  If no error occurs: call
@func{run-compensations}, reset the compensations stack to empty,
finally return the result value of the last @meta{body} form.

If the dynamic extent of the evaluation of the @meta{body} forms is
terminated: the accumulated compensations are evaluated in reverse
order.
@end deffn


@deffn Syntax with-compensations/on-error @metao{body} @meta{body} @dots{}
Allocate a new compensations stack, then evaluate all the @meta{body}
forms in the given order.  If no error occurs: reset the compensations
stack to empty, return the result value of the last @meta{body} form.

If the dynamic extent of the evaluation of the @meta{body} forms is
terminated by escaping from the body directly or by escaping from the
body while handling a raised a exception: the accumulated compensations
are evaluated in reverse order.
@end deffn


@defun run-compensations
Evaluate all the compensation thunks in the current stack, in last
in/first out order; compensation thunks are called in the current
dynamic environment.  If a compensation thunk raises an exception: the
exception is blocked and silently discarded.

This function should be called only inside the dynamic environment
prepared by @func{with-compensations} and similar syntaxes.  It can be
called multiple times: every time the compensation thunks are consumed
and removed from the stack.
@end defun


@deffn Syntax with-compensation-handler @meta{release-thunk} @meta{alloc-thunk}
First push @meta{release-thunk} on the current compensations stack,
@strong{then} evaluate @meta{alloc-thunk}.  Return the results of
evaluating @meta{alloc-thunk}.
@end deffn


@deffn Syntax compensate @metao{alloc} @meta{alloc} @dots{} (with @metao{release} @meta{release} @dots{})
@deffnx {Auxiliary Fluid Syntax} with
First evaluate all the @meta{alloc} expressions then, @strong{only} if
they perform a normal return: push one thunk holding all the
@meta{release} forms on the current compensations stack.  Return the
result of the last @meta{alloc} expression.
@end deffn


@deffn Syntax push-compensation @metao{release} @meta{release} @dots{}
Push a thunk holding the @meta{release} forms on the current
compensations stack.
@end deffn


@defun push-compensation-thunk @var{thunk}
Push the given thunk on the current compensations stack.
@end defun

@c page
@node iklib coroutines
@section Running coroutines


@value{PRJNAME} implements coroutines on top of Scheme continuations.
The implementation is a simple queue of escape procedures: whenever
coroutine yields control to the ``next'' coroutine, it enqueues an
escape function to its current continuation and causes the next escape
procedure to be invoked.

For discussions about other implementations of coroutines and
continuations see @vicareref{HFWCoro, references}.

@menu
* iklib coroutines examples::   Usage examples for coroutines.
* iklib coroutines basic::      Basic coroutine operations.
* iklib coroutines uid::        Coroutine unique identifiers.
* iklib coroutines suspend::    Suspending and resuming coroutines.
* iklib coroutines syntaxes::   Utility syntaxes for coroutines.
* iklib coroutines debug::      Debugging utilities for coroutines.
* iklib coroutines parallel::   Running parallel processes.
@end menu

@c page
@node iklib coroutines examples
@subsection Usage examples for coroutines


Coroutines are created by the function @func{coroutine}; a coroutine in
execution can yield control to the next coroutine with the function
@func{yield}.  It is possible to enter a loop that runs all the
coroutines until all of them are finished with the function
@func{finish-coroutines}.

All the examples in this section are to be considered as Scheme programs
after the prelude:

@example
#!r6rs
(import (vicare))

(set-port-buffer-mode! (current-output-port)
                       (buffer-mode line))
@end example

@noindent
which allows the intertwining of coroutines to be seen by displaying
strings on the current output port.

@c ------------------------------------------------------------

@subsubheading Two coroutines

The following example runs two coroutines and waits for them to finish:

@example
(coroutine
    (lambda ()
      (display "one 1\n")
      (yield)
      (display "one 2\n")
      (yield)
      (display "one 3\n")))

(coroutine
    (lambda ()
      (display "two 1\n")
      (yield)
      (display "two 2\n")
      (yield)
      (display "two 3\n")))

(finish-coroutines)
@end example

@noindent
the output is:

@example
one 1
two 1
one 2
two 2
one 3
two 3
@end example

We see that to exit a coroutine we just return from its start function.

@c ------------------------------------------------------------

@subsubheading The main routine and a subroutine

We can always consider the ordinary control flow of a program as a
coroutine, the @dfn{main routine}; so the following program produces
output similar to the one above:

@example
(coroutine
    (lambda ()
      (display "sub 1\n")
      (yield)
      (display "sub 2\n")
      (yield)
      (display "sub 3\n")))

;;This runs in the main routine.
(display "main 1\n")
(yield)
(display "main 2\n")
(yield)
(display "main 3\n")

(finish-coroutines)
@end example

@noindent
the output is:

@example
sub 1
main 1
sub 2
main 2
sub 3
main 3
@end example

@c ------------------------------------------------------------

@subsubheading Main routine alone

It is perfectly all right to call @func{yield} and
@func{finish-coroutines} from the main routine even when there are no
subroutines:

@example
(display "main 1\n")
(yield)
(display "main 2\n")
(yield)
(display "main 3\n")
(finish-coroutines)
@end example

@noindent
the output of this program is just:

@example
main 1
main 2
main 3
@end example

@c ------------------------------------------------------------

@subsubheading Finishing coroutines

It is possible to call @func{finish-coroutines} from any coroutine, but
we must be careful because if we let the main routine exit before all
the routines are finished some computation will not take place.  In the
following program the subroutine has more steps than the main routine:

@example
(coroutine
    (lambda ()
      (display "sub 1\n")
      (yield)
      (display "sub 2\n")
      (yield)
      (display "sub 3\n")
      (yield)
      (display "sub 4\n")
      (yield)
      (display "sub 5\n")
      (finish-coroutines)))

;; This runs in the main routine.
(display "main 1\n")
(yield)
(display "main 2\n")
(yield)
(display "main 3\n")
@end example

@noindent
and its output is:

@example
sub 1
main 1
sub 2
main 2
sub 3
main 3
@end example

@noindent
we see that @samp{sub 4} and @samp{sub 5} are not displayed.

@c ------------------------------------------------------------

@subsubheading Finish coroutines as exit hook

It can be useful to register @func{finish-coroutines} as exit hook, so
that upon exiting the process all the pending coroutines are correctly
terminated.

@example
(coroutine
    (lambda ()
      (display "one 1\n")
      (yield)
      (display "one 2\n")
      (yield)
      (display "one 3\n")))

(coroutine
    (lambda ()
      (display "two 1\n")
      (yield)
      (display "two 2\n")
      (yield)
      (display "two 3\n")))

(exit-hooks (cons finish-coroutines (exit-hooks)))
(exit)
@end example

@c page
n@node iklib coroutines basic
@subsection Basic coroutine operations


@defun coroutine @var{thunk}
Create a new coroutine having @var{thunk} as function and enter it;
return unspecified values.
@end defun


@defun yield
Register the current continuation as coroutine, then run the next
coroutine; return unspecified values.
@end defun


@defun finish-coroutines
@defunx finish-coroutines @var{exit-loop?}
Loop running the next coroutine until there are no more; return
unspecified values.

When the argument @var{exit-loop?} is used: it must be a thunk.  Before
entering the next coroutine @var{exit-loop?} is called: if it returns
non-false the loop exits, if it returns @false{} the loop continues.
@end defun

@c page
@node iklib coroutines uid
@subsection Coroutine unique identifiers


@defun coroutine-uid
Return a gensym acting as unique identifier for the current coroutine.
This symbol is bound to an internal data structure.
@end defun


@defun coroutine-uid? @var{obj}
Return @true{} if @var{obj} is a unique coroutine identifier; otherwise
return @false{}.
@end defun

@c page
@node iklib coroutines suspend
@subsection Suspending and resuming coroutines


@defun suspend-coroutine
Suspend the current coroutine by yielding control to the next one.  The
continuation of the current coroutine is @strong{not} enqueued to be
reinstated later.
@end defun


@defun resume-coroutine @var{uid}
Given the unique identifier of a suspended coroutine: resume it by
enqueueing the current continuation and yielding control to the
suspended coroutine.
@end defun


@defun suspended-coroutine? @var{uid}
Return @true{} if @var{uid} is the unique identifier of a suspended
coroutine; otherwise return @false{}.  It is an error if @var{uid} is
not the @uid{} of a coroutine.
@end defun

@c page
@node iklib coroutines syntaxes
@subsection Utility syntaxes for coroutines


@deffn Syntax concurrently @metao{thunk} @meta{thunk} @dots{}
Evaluate the given thunks each in its own coroutine.  Return unspecified
values when all the coroutines are finished.
@end deffn


@deffn Syntax monitor @meta{max-coroutines-count} @meta{thunk}
Allow only a maximum number of coroutines to concurrently enter the
evaluation of @meta{thunk}.

The argument @meta{max-coroutines-count} must be an expression
evaluating to a positive integer representing the maximum number of
coroutines.  It is evaluated only once.

The argument @meta{thunk} must be an expression evaluating to a thunk.
It is evaluated only once.
@end deffn

@c page
@node iklib coroutines debug
@subsection Debugging utilities for coroutines


@defun reset-coroutines!
Reset the internal state of the coroutine mechanism, discarding all the
enqueued coroutines.  This function should not be used.
@end defun


@defun dump-coroutines
Print, on the current error port, a symbolic expression listing the
currently enqueued coroutine continuation procedures.  This is strictly
for debugging purposes.
@end defun

@c page
@node iklib coroutines parallel
@subsection Running parallel processes


@cindex Running parallel processes, coroutines
@cindex Coroutines, running parallel processes
@cindex Processes, running in parallel


The following example program shows how to run a parallel, child process
waiting for its termination in a coroutine; it assumes that
@value{PRJNAME} has been installed with the @posix{} extensions.

@smallexample
#!vicare
(import (vicare)
  (prefix (vicare posix) px.)
  (prefix (vicare platform constants) const.))

(define (parent-proc child-pid child-stdin child-stdout child-stderr)
  (with-unwind-protection
      (lambda (why)
        (close-output-port child-stdin)
        (close-input-port  child-stdout)
        (close-input-port  child-stderr))
    (lambda ()
      (let loop ((status (px.waitpid child-pid const.WNOHANG)))
        (cond ((not status)
               ;;Child still running.
               (yield)
               (loop (px.waitpid child-pid const.WNOHANG)))
              ((px.WIFEXITED status)
               ;;Child exited.
               (values status
                       (read-all child-stdout)
                       (get-string-all child-stderr)))
              (else
               (error #f
                 "child process exited abnormally" status)))))))

(define (child-thunk)
  (guard (E (else
             (print-condition E)
             (exit 1)))
    (px.close-ports-in-close-on-exec-mode)
    (write '(1 2 3) (console-output-port))
    (write '(4 5 6) (console-output-port))
    (flush-output-port (console-output-port))
    (put-string (console-error-port) "done\n")
    (flush-output-port (console-error-port))
    (exit 0)))

(define (read-all port)
  (let ((obj (read port)))
    (if (eof-object? obj)
        '()
      (cons obj (read-all port)))))

(coroutine
    (lambda ()
      (px.flush-ports-in-close-on-exec-mode)
      (receive (status out err)
          (px.fork-with-textual-ports parent-proc child-thunk)
        (printf "out: ~s\n" out)
        (printf "err: ~a\n" err)
        (flush-output-port (current-output-port)))))

(finish-coroutines)
@end smallexample

@c page
@node iklib conditions
@section Additional condition types


@menu
* iklib conditions spos::       Scheme source code position.
* iklib conditions eagain::     Reporting @code{EAGAIN} exceptions.
* iklib conditions errno::      Reporting @code{errno} exceptions.
* iklib conditions procarg::    Procedure argument violations.
* iklib conditions exprret::    Expression return value violations.
* iklib conditions non-reinst:: Non-reinstatable continuations.
* iklib conditions misc::       Miscellaneous primitives.
@end menu

@c page
@node iklib conditions spos
@subsection Scheme source code position


The following bindings are exported by the library @library{vicare}.


@deftp {Condition Type} &source-position
Condition type used to represent a position in Scheme source code read
from a textual input port; it is derived from @condition{condition}.  It
has the following fields:

@table @code
@item port-id
A Scheme string representing the port identifier, for example the file
name.

@item byte
An exact non--negative zero--based integer representing the byte offset
of the position in the source.

@item character
An exact non--negative zero--based integer representing the character
offset of the position in the source.

@item line
An exact non--negative one--based integer representing the line offset
of the position in the source.

@item column
An exact non--negative one--based integer representing the column offset
of the position in the source.
@end table
@end deftp


@defun make-source-position-condition @var{port-id} @var{character}
Build and return a new condition object of type
@condition{source-position}.
@end defun


@defun source-position-condition? @var{obj}
Return true if @var{obj} is a condition object with type
@condition{source-position}.
@end defun


@defun source-position-port-id @var{spos}
@defunx source-position-character @var{spos}
Accessors for the fields of condition objects of type
@condition{source-position}.
@end defun

@c page
@node iklib conditions eagain
@subsection Reporting @code{EAGAIN} exceptions


The following bindings are exported by the library @library{vicare}.


@deftp {Condition Type} &i/o-eagain
Used to signal that a system call returned with @code{errno} set to
@code{EAGAIN}.  It is derived from @condition{i/o}.
@end deftp


@defun make-i/o-eagain
Return a new condition object of type @condition{i/o-eagain}.
@end defun


@defun i/o-eagain-error? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{i/o-eagain}.
@end defun

@c page
@node iklib conditions errno
@subsection Reporting @code{errno} exceptions


The following bindings are exported by the library @library{vicare}.


@deftp {Condition Type} &errno
Condition object type representing system errors described by an encoded
@code{errno} value; it is derived from @condition{condition}.
@end deftp


@defun make-errno-condition @var{errno}
Build and return a new @condition{errno} condition object holding the
given encoded @code{errno} value.
@end defun


@defun errno-condition? @var{obj}
Return @true{} if @var{obj} is an instance of @condition{errno}.
@end defun


@defun condition-errno @var{obj}
Accessor for the encoded @code{errno} value in @var{obj}, which must be
an instance of @condition{errno}.
@end defun

@c page
@node iklib conditions procarg
@subsection Procedure argument violations


@deftp {Condition Type} &procedure-argument-violation
Condition object type representing invalid values handed as arguments to
a procedure; it is derived from @condition{assertion}.
@end deftp


@defun make-procedure-argument-violation
Build and return a new condition object of type
@condition{procedure-argument-validation}.
@end defun


@defun procedure-argument-violation? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{procedure-argument-validation}; otherwise return @false{}.
@end defun


@defun procedure-argument-violation @var{who} @var{message} @var{irritant} @dots{}
Raise a compound condition object as non--continuable exception with
component types: @condition{who}, @condition{message},
@condition{irritants}, @condition{procedure-argument-validation}.
@end defun

@c page
@node iklib conditions exprret
@subsection Expression return value violations


@deftp {Condition Type} &expression-return-value-violation
Condition object type representing invalid values returned from an
expression; it is derived from @condition{assertion}.
@end deftp


@defun make-expression-return-value-violation
Build and return a new condition object of type
@condition{expression-return-value-validation}.
@end defun


@defun expression-return-value-violation? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{expression-return-value-validation}; otherwise return
@false{}.
@end defun


@defun expression-return-value-violation @var{who} @var{message} @var{irritant} @dots{}
Raise a compound condition object as non--continuable exception with
component types: @condition{who}, @condition{message},
@condition{irritants}, @condition{expression-return-value-validation}.
@end defun

@c page
@node iklib conditions non-reinst
@subsection Non--reinstatable continuations


@anchor{&non-reinstatable}
@deftp {Condition Type} &non-reinstatable
Condition object type representing an attempt to reinstate a
continuation in an invalid context; it is derived from
@condition{violation}.
@end deftp


@defun make-non-reinstatable-violation
Build and return a new condition object of type
@condition{non-reinstatable}.
@end defun


@defun non-reinstatable-violation? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{non-reinstatable}; otherwise return @false{}.
@end defun


@defun non-reinstatable-violation @var{who} @var{message} @var{irritant} @dots{}
Raise a compound condition object with components: @condition{who},
@condition{message}, @condition{irritants},
@condition{non-reinstatable}.
@end defun

@c page
@node iklib conditions misc
@subsection Miscellaneous primitives


@defun compound-condition? @var{obj}
Return @true{} if @var{obj} is a compound condition object; otherwise
return @false{}.

@lisp
(compound-condition? (make-error))
@result{} #f

(compound-condition? (condition (make-error)
                                (make-warning)))
@result{} #t

(compound-condition? "ciao")
@result{} #f
@end lisp
@end defun


@defun condition-and-rtd? @var{obj} @var{rtd}
Return @true{} if @var{obj} is either a simple condition object of type
@var{rtd} or a compound condition object containing a simple condition
object of type @var{rtd}; otherwise return @false{}.  @var{rtd} must be
the record--type descriptor of a condition object type.

@example
(condition-and-rtd? (make-error)
                    (record-type-descriptor &error))
@result{} #t

(condition-and-rtd? (condition (make-error)
                               (make-warning))
                    (record-type-descriptor &error))
@result{} #t

(condition-and-rtd? "ciao"
                    (record-type-descriptor &error))
@result{} #f
@end example
@end defun


@deffn Syntax condition-is-a? @meta{expr} @meta{tag}
Return @true{} if the result of evaluating @meta{expr} is either a
simple condition object of type @var{tag} or a compound condition object
containing a simple condition object of type @var{tag}; otherwise return
@false{}.  @meta{tag} must an identifier representing the name of a
condition object type.

@example
(condition-is-a? (make-error) &error)
@result{} #t

(condition-is-a? (condition (make-error)
                            (make-warning))
                 &error)
@result{} #t

(condition-is-a? "ciao" &error)
@result{} #f
@end example
@end deffn

@c page
@node iklib reader
@section Reader


@menu
* iklib reader mode::           Textual input port modes.
* iklib reader bv::             Additional bytevector syntaxes.
* iklib reader chars::          Custom named characters.
* iklib reader stx::            Miscellaneous additional syntaxes.
* iklib reader fun::            Additional reader functions.
@end menu

@c page
@node iklib reader mode
@subsection Textual input port modes


@deffn {Reader Syntax} {#!vicare}
@deffnx {Reader Syntax} {#!ikarus}
@value{PRJNAME} extends Scheme's lexical syntax (@rnrs{6} Chapter 4) in
a variety of ways including:

@itemize
@item
End--of--file marker, @code{#!eof}.

@item
Would--block object, @code{#!would-block}.

@item
Unbound object, @code{#!unbound}.

@item
@acronym{BWP} object, @code{#!bwp}.

@item
Gensym syntax, @code{#@{gensym@}}.

@item
Shared structures graph notation: @code{#nn=}, @code{#nn#}.

@item
Special symbols: @code{++}, @code{--}.

@item
Special symbol @code{|}, which is a standalone vertical bar.

@item
Special symbols beginning with @code{+g} and @code{-g}, to allow reading
symbols starting with @code{+greek-pi} and @code{-greek-pi}.

@item
Brace lists @code{@{ ... @}} are read as @code{(brace ...)}, @ref{iklib
syntaxes misc, brace}.
@end itemize

The syntax extensions are made available by default on all input ports,
until the token @code{#!r6rs} is read; thus, reading the token
@code{#!r6rs} disables all extensions to the lexical syntax on the
specific port, and the token @code{#!vicare} enables them again.

When writing code that is intended to be portable across different
Scheme implementations, we should add the token @code{#!r6rs} to the top
of every script and library that we write; this allows @value{PRJNAME}
to alert us when using non--portable features.  When writing code that's
intended to be @value{PRJNAME}--specific, we should add the token
@code{#!vicare} in order to get an immediate error when the code is run
under other implementations.

The comment @code{#!ikarus} is accepted for backwards compatibility with
Ikarus Scheme.
@end deffn


@deffn Procedure port-mode @var{input-port}
Accept an input port as argument and return a symbol among: @code{r6rs},
@code{vicare}.  All input ports start under @code{vicare} mode and thus
accept @value{PRJNAME}--specific reader extensions.  When the token
@code{#!r6rs} is read from a port: its mode changes to @code{r6rs}.

@example
> (port-mode (current-input-port))
vicare
> #!r6rs (port-mode (current-input-port))
r6rs
> #!vicare (port-mode (current-input-port))
vicare
@end example
@end deffn


@deffn Procedure set-port-mode! @var{input-port} @var{mode}
Modifiy the lexical syntax accepted by subsequent calls to @func{read}
on the input port.  The mode is a symbol among @code{r6rs} and
@code{vicare}.  The effect of setting the port mode is similar to that
of reading the token @code{#!r6rs} or @code{#!vicare} from that port.

@example
> (set-port-mode! (current-input-port) 'r6rs)
> (port-mode (current-input-port))
r6rs
@end example
@end deffn

@c page
@node iklib reader bv
@subsection Additional bytevector syntaxes


The following syntaxes are available only when the input port mode is
set to @code{vicare}.


@deffn {Reader Syntax} {#vs8(@var{byte} ...)}
Read a bytevector as @code{#vu8(@var{octect} ...)} would do, but allow
@var{byte} to be in the range @math{[-128, 127]}.
@end deffn


@deffn {Reader Syntax} {#vu16l(@var{word} ...)}
@deffnx {Reader Syntax} {#vu16b(@var{word} ...)}
@deffnx {Reader Syntax} {#vu16n(@var{word} ...)}
Read a bytevector of 16-bit unsigned words stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vs16l(@var{word} ...)}
@deffnx {Reader Syntax} {#vs16b(@var{word} ...)}
@deffnx {Reader Syntax} {#vs16n(@var{word} ...)}
Read a bytevector of 16-bit signed words stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vu32l(@var{word} ...)}
@deffnx {Reader Syntax} {#vu32b(@var{word} ...)}
@deffnx {Reader Syntax} {#vu32n(@var{word} ...)}
Read a bytevector of 32-bit unsigned words stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vs32l(@var{word} ...)}
@deffnx {Reader Syntax} {#vs32b(@var{word} ...)}
@deffnx {Reader Syntax} {#vs32n(@var{word} ...)}
Read a bytevector of 32-bit signed words stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vu64l(@var{word} ...)}
@deffnx {Reader Syntax} {#vu64b(@var{word} ...)}
@deffnx {Reader Syntax} {#vu64n(@var{word} ...)}
Read a bytevector of 64-bit unsigned words stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vs64l(@var{word} ...)}
@deffnx {Reader Syntax} {#vs64b(@var{word} ...)}
@deffnx {Reader Syntax} {#vs64n(@var{word} ...)}
Read a bytevector of 64-bit signed words stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vf4l(@var{flonum} ...)}
@deffnx {Reader Syntax} {#vf4b(@var{flonum} ...)}
@deffnx {Reader Syntax} {#vf4n(@var{flonum} ...)}
Read a bytevector of single--precision flonums stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vf8l(@var{flonum} ...)}
@deffnx {Reader Syntax} {#vf8b(@var{flonum} ...)}
@deffnx {Reader Syntax} {#vf8n(@var{flonum} ...)}
Read a bytevector of double--precision flonums stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vc4l(@var{cflonum} ...)}
@deffnx {Reader Syntax} {#vc4b(@var{cflonum} ...)}
@deffnx {Reader Syntax} {#vc4n(@var{cflonum} ...)}
Read a bytevector of single--precision cflonums stored in little, big
and native endianness, real part first.
@end deffn


@deffn {Reader Syntax} {#vc8l(@var{cflonum} ...)}
@deffnx {Reader Syntax} {#vc8b(@var{cflonum} ...)}
@deffnx {Reader Syntax} {#vc8n(@var{cflonum} ...)}
Read a bytevector of double--precision cflonums stored in little, big
and native endianness, real part first.
@end deffn


@deffn {Reader Syntax} {#ve(@var{encoding} @var{data})}
Read a bytevector in some encoding which is supposed to be easy to type
for human beings.  @var{encoding} is a symbol representing the encoding
format, @var{data} is a datum to convert to bytevector.  At present the
following encodings are supported:

@table @code
@item ascii
Convert the Scheme string @var{data} to a bytevector using the function
@func{string->ascii}.

@item latin1
Convert the Scheme string @var{data} to a bytevector using the function
@func{string->latin1}.

@item utf8
Convert the Scheme string @var{data} to a bytevector using the function
@func{string->utf8}.

@item utf16be
Convert the Scheme string @var{data} to a bytevector using the function
@func{string->utf16be}.

@item utf16le
Convert the Scheme string @var{data} to a bytevector using the function
@func{string->utf16le}.

@item utf16n
Convert the Scheme string @var{data} to a bytevector using the function
@func{string->utf16n}.

@item hex
Convert the Scheme string @var{data} to a bytevector using the function
@func{string-hex->bytevector}.

@item base64
Convert the Scheme string @var{data} to a bytevector using the function
@func{string-base64->bytevector}.

@item percent-encoding
Convert the Scheme string @var{data} to a bytevector using the function
@func{string->percent-encoding}.
@end table
@end deffn

@c page
@node iklib reader chars
@subsection Custom named characters


The following syntaxes are available only when the input port mode is
set to @code{vicare}.


@deffn {Reader Syntax} {#!(char-names (@meta{name} . @meta{char}) ...)}
Add new custom named characters to the internal table for the current
reading operation.  Each @meta{name} must be a Scheme identifier
starting with a @meta{constituent} character as defined by @rnrs{6};
each @meta{char} must be a Scheme character.

@example
#!(char-names
    (lambda . #\x0EBB))
@end example
@end deffn


@deffn {Reader Syntax} {#\@{@meta{name}@}}
Reader syntax for standalone custom named characters.  @meta{name} must
be an identifier previously defined with the @code{char-names} comment
list defined above.

@example
#\@{lambda@}            @result{} #\xEBB
@end example
@end deffn


@deffn {Reader Syntax} {\@{@meta{name}@}}
Reader syntax for custom named characters embedded in strings.
@meta{name} must be an identifier previously defined with the
@code{char-names} comment list defined above.

@example
"\@{lambda@}"           @result{} "\xEBB;"
@end example
@end deffn

@c page
@node iklib reader stx
@subsection Miscellaneous additional syntaxes


The following syntaxes are available only when the input port mode is
set to @code{vicare}.


@deffn {Reader Syntax} {|@var{symbol}|}
The vertical bars can be used to specify symbols whose name does not
comply with the @rnrs{6} specifications; this syntax is available only
when the port mode is @code{#!vicare}.  Examples:

@example
(define port (open-string-input-port "|123|"))
(set-port-mode! port 'vicare)
(define sym (read port))

(symbol? sym)           @result{} #t
(symbol->string sym)    @result{} "123"
@end example

@noindent
backslash sequences are allowed in bar symbols:

@example
(define port (open-string-input-port "|123-\x41;\x42;\x43;|"))
(set-port-mode! port 'vicare)
(define sym (read port))

(symbol? sym)           @result{} #t
(symbol->string sym)    @result{} "123-\x41;\x42;\x43;"
@end example

@noindent
notice that the sequence of characters @code{|ciao|hello|} is split into
@code{ciao}, @code{hello}, @code{|} and the ending vertical bar would
cause an error if read:

@example
(define port (open-string-input-port "|ciao|hello|"))
(set-port-mode! port 'vicare)

(read port)             @result{} ciao
(read port)             @result{} hello
(port-eof? port)        @result{} #f
(get-char port)         @result{} #\|
(port-eof? port)        @result{} #t
@end example
@end deffn


@deffn {Reader Syntax} {#@{unique-name@}}
@deffnx {Reader Syntax} {#@{pretty-name unique-name@}}
@c @deffnx {Reader Syntax} {#:pretty-name}
@value{PRJNAME}'s @func{read} and @func{write} procedures extend the lexical
syntax of Scheme by the ability to read and write gensyms using one of
these three forms.

@code{#@{unique-name@}} constructs, at read time, a gensym whose unique
name is the one specified.  If a gensym with the same unique name
already exists in the system's symbol table, that gensym is returned.

@example
> '#@{some-long-name@}
#@{g0 |some-long-name|@}
> (gensym? '#@{some-long-unique-name@})
#t
> (eq? '#@{another-unique-name@} '#@{another-unique-name@})
#t
@end example

The two--part @code{#@{pretty-name unique-name@}} gensym syntax is
similar to the syntax shown above with the exception that if a new
gensym is constructed (that is, if the gensym did not already exist in
the symbol table), the pretty name of the constructed gensym is set to
@code{pretty-name}.

@example
> '#@{foo unique-identifier@}
#@{foo |unique-identifier|@}
> '#@{unique-identifier@}
#@{foo |unique-identifier|@}
> '#@{bar unique-identifier@}
#@{foo |unique-identifier|@}
@end example

@ignore
The @code{#:pretty-name} form constructs, at read time, a gensym whose
pretty name is @code{pretty-name} and whose unique name is fresh.  This
form guarantees that the resulting gensym is not @func{eq?} to any other
symbol in the system.

@example
> '#:foo
#@{foo |j=qTGlEwS/Zlp2Dj|@}
> (eq? '#:foo '#:foo)
#f
@end example
@end ignore
@end deffn


@deffn {Reader Syntax} {#:@var{symbol}}
Read a keyword object using @var{symbol} as symbol.  @var{symbol} must
be a symbol object as defined by @rnrs{6}.  @ref{iklib keywords, Keyword
objects}.
@end deffn


@deffn {Reader Syntax} {#!eof}
The end--of--file marker, @code{#!eof}, is an extension to the @rnrs{6}
syntax.  The primary utility of the @code{#!eof} marker is to stop the
reader (e.g. @func{read} and @func{get-datum}) from reading the rest of
the file.

@example
(import (vicare))
<some code>
(display "goodbye\n")

#!eof
<some junk>
@end example

The @code{#!eof} marker also serves as a datum in @value{PRJNAME}, much
like @true{} and @false{}, when it is found inside other expressions.

@example
> (eof-object)
#!eof
> (read (open-input-string ""))
#!eof
> (read (open-input-string "#!eof"))
#!eof
> (quote #!eof)
#!eof
> (eof-object? '#!eof)
#t
> #!r6rs #!eof
Unhandled exception
Condition components:
  1. &error
  2. &who: tokenize
  3. &message: "invalid syntax: #!e"
> #!vicare #!eof
$
@end example
@end deffn


@deffn {Reader Syntax} #ci @var{form}
@deffnx {Reader Syntax} #cs @var{form}
Switch between case sensitive and case insensitive identifiers; the
default for @rnrs{6} source code is case sensitive.  When @code{#ci} is
read: the next form read has case insensitive identifiers.  When
@code{#cs} is read: the next form read has case sensitive identifiers.

@example
#ci(1 2 3)              @result{} (1 2 3)
#cs(1 2 3)              @result{} (1 2 3)

#ci(1 A 3)              @result{} (1 a 3)
#cs(1 A 3)              @result{} (1 A 3)

#ci CIAO #cs CIAO       @result{} ciao CIAO
#ci CIAO CIAO           @result{} ciao CIAO

#ci(A #csB C)           @result{} (a B c)
#ci(A #cs B C)          @result{} (a B c)
@end example
@end deffn

@c page
@node iklib reader fun
@subsection Additional reader functions


The following bindings are exported by the library @library{vicare}.


@defun get-annotated-datum @var{port}
Like @func{get-datum}, but rather than returning a datum return a
hierarchy of @code{annotation} objects with the same hierarchy of the
datum and embedding the datum itself.
@end defun


@defun annotation? @var{obj}
Return @true{} if @var{obj} is an @code{annotation} object, else return
@false{}.
@end defun


@defun annotation-expression @var{ann}
Accessor for the @code{expression} field of an @code{annotation} object.
Return a list, vector, identifier, what--have--you that may contain
further annotations.
@end defun


@defun annotation-stripped @var{ann}
Accessor for the @code{stripped} field of an @code{annotation} object.
The same symbolic expression of the @code{expression} field with no
annotations.
@end defun


@defun annotation-textual-position @var{ann}
Accessor for the @code{textual-position} field of an @code{annotation}
object.  A condition object of type @condition{source-position}
representing the position of the expression in the source code.
@end defun


@defun annotation-source @var{ann}
A pair whose car is the port identifier and whose cdr is the offset of
the character.
@end defun

@c page
@node iklib expander
@section Interface to the expander


@menu
* iklib expander syntax::           Inspecting syntax objects.
* iklib expander transformers::     Syntax transformers facilities.
* iklib expander expand::           Expander facilities.
* iklib expander export specs::     Additional export specifications.
* iklib expander import specs::     Additional import specifications.
* iklib expander local import::     Local library imports.
* iklib expander extended export::  Extended library exports.
* iklib expander fluids::           Fluid syntaxes.
* iklib expander utils::            Utility functions for writing macro.
* iklib expander clauses::          Syntax clauses helpers.
* iklib expander ctv::              Compile-time values.
* iklib expander parameters::       Expand--time parameters.
* iklib expander synonym::          Synonym transformers.
@end menu

@c page
@node iklib expander syntax
@subsection Inspecting syntax objects


Under @value{PRJNAME}, a syntax object is the instance of a data
structure.  The following bindings are exported by the library
@library{vicare}.


@defun syntax-object? @var{stx}
Return @true{} if @var{stx} is a syntax object, else return @false{}.
@end defun


@defun syntax-object-expression @var{stx}
@defunx syntax-object-marks @var{stx}
@defunx syntax-object-ribs @var{stx}
@defunx syntax-object-source-objects @var{stx}
Field accessors for the syntax object structure type, to be used for
debugging purposes.
@end defun

@c page
@node iklib expander transformers
@subsection Syntax transformers facilities


The following bindings are exported by the library @library{vicare}.


@defun make-variable-transformer @var{func}
Defined by @rnrs{6}.  Build and return a ``special'' value that, when
used as right--hand side of a syntax definition, is recognised by the
expander as a variable transformer as opposed to a normal transformer or
a compile-time value.

@func{func} must be the transformer function.
@end defun


@defun variable-transformer? @var{obj}
Return @true{} if @var{obj} is recognised by the expander as a variable
transformer as opposed to a normal transformer or a compile--time value;
otherwise return @false{}.
@end defun


@defun variable-transformer-procedure @var{var-trasf}
If @var{var-trasf} is recognised by the expander as a variable
transformer: return the actual transformer function, otherwise raise an
assertion violation.
@end defun

@c page
@node iklib expander expand
@subsection Expander facilities


@menu
* iklib expander expand library:: Expanding libraries.
* iklib expander expand program:: Expanding programs.
* iklib expander expand form::    Expanding forms.
@end menu

@c page
@node iklib expander expand library
@subsubsection Expanding libraries


@defun expand-library @var{sexp}
@defunx expand-library @var{sexp} @var{filename}
@defunx expand-library @var{sexp} @var{filename} @var{verify-libname}
Expand the symbolic expression @var{sexp} representing a library and
register the result in the internal library manager.  @var{sexp} must be
a symbolic expression @code{(library . ---)}.

The optional @var{filename} must be @false{} or a string representing
the source file from which the library was loaded; it is used for
information purposes.  When not given defaults to @false{}.

The optional argument @var{verify-libname} must be a procedure accepting
a @rnrs{6} library name as argument and returning unspecified values; it
is meant to perform some validation upon the library name components and
raise an exception if something is wrong; otherwise it should just
return.

Return @math{12} values:

@table @var
@item uid
A gensym uniquely identifying this library.

@item libname
A @rnrs{6} library name.

@item import-libdesc*
A list of library descriptors representing the libraries that need to be
imported for the invoke code.

@item visit-libdesc*
A list of library descriptors representing the libraries that need to be
imported for the visit code.

@item invoke-libdesc*
A list of library descriptors representing the libraries that need to be
invoked to make available the values of the imported variables.

@item invoke-code
A symbolic expression representing the code to be evaluated to create
the top--level @func{define} bindings and evaluate the trailing init
expressions.

@item visit-code -
A symbolic expression representing the code to be evaluated to create
the expand--time code.

@item export-subst
A subst representing the top--level bindings.

@item export-env
A list representing the bindings exported by the library.

@item guard-code
A predicate expression in the core language representing the
@func{stale-when} tests from the body of the library.

@item guard-libdesc*
A list of library descriptors representing the libraries that need to be
invoked for the @func{stale-when} code.

@item option*
A list of symbolic expressions representing options from the
@clause{options} clause of the @func{library} form.
@end table
@end defun


@defun expand-library->sexp @var{sexp}
This function is for debugging purposes.  Expand the library form
@var{sexp} and return the return values of @func{expand-library} in an
alist with the following symbols as keys:

@example
uid libname
import-libdesc* visit-libdesc* invoke-libdesc*
invoke-code visit-code
export-subst export-env
guard-code guard-libdesc*
option*
@end example
@end defun


We can toy with the library expander using the following code:

@example
#!r6rs
(import (vicare))
(print-gensym #f)
(debug-print (expand-library->sexp @meta{sexp}))
@end example

@noindent
where @meta{sexp} is the @func{library} symbolic expression.  For
example, expanding the library:

@example
(library (ciao)
  (export var fun mac ctv)
  (import (vicare))
  (define var 1)
  (define (fun)
    2)
  (define-syntax (mac stx)
    3)
  (define-syntax ctv
    (make-compile-time-value
     (+ 4 5))))
@end example

@noindent
yields the @code{invoke-code}:

@example
(library-letrec*
    ((lex.var loc.lex.var '1)
     (lex.fun loc.lex.fun (annotated-case-lambda fun (() '2))))
  ((primitive void)))
@end example

@noindent
the @code{visit-code}:

@example
(begin
  (set! loc.lab.mac
        (annotated-case-lambda
            (#'lambda (#'stx) #'3)
          ((lex.stx) '3)))
  (set! loc.lab.ctv
        (annotated-call
            (make-compile-time-value (+ 4 5))
          (primitive make-compile-time-value)
          (annotated-call (+ 4 5) (primitive +) '4 '5))))
@end example

@noindent
the @code{export-subst}:

@example
((ctv . lab.ctv)
 (mac . lab.mac)
 (fun . lab.fun)
 (var . lab.var))
@end example

@noindent
the @code{export-env}:

@example
((lab.var global        . loc.lex.var)
 (lab.fun global        . loc.lex.fun)
 (lab.mac global-macro  . loc.lab.mac)
 (lab.ctv global-ctv    . loc.lab.ctv))
@end example

Another example, for the library:

@example
(library (ciao (1 2))
  (export doit)
  (import (vicare))
  (stale-when (< 1 2)
    (define a 123))
  (stale-when (< 2 3)
    (define b 123))
  (define (doit)
    123))
@end example

@noindent
the @code{guard-code} is:

@example
(if (if '#f
        '#t
       (annotated-call (< 1 2) (primitive <) '1 '2))
    '#t
  (annotated-call (< 2 3) (primitive <) '2 '3))
@end example

@c page
@node iklib expander expand program
@subsubsection Expanding programs


@defun expand-top-level @var{sexp}
Expand an @rnrs{6} program whose symbolic expression is @var{sexp}.
Return @math{5} values:

@table @var
@item invoke-lib*
A list of @code{library} structs representing the libraries that need to
be invoked to run the code.

@item invoke-code
The fully expanded code from the body of the program.

@item macro*
A list of sublists representing the macros defined in the program.

@item export-subst
A subst representing the top--level bindings.

@item export-env
A list representing the bindings exported by the program.
@end table
@end defun


@defun expand-top-level->sexp @var{sexp}
This function is for debugging purposes.  Expand the program form
@var{sexp} and return the return values of @func{expand-top-level} in an
alist with the following symbols as keys:

@example
invoke-lib* invoke-code
macro*
export-subst export-env
@end example
@end defun


We can toy with the library expander using the following code:

@example
#!r6rs
(import (vicare))
(print-gensym #f)
(debug-print (expand-top-level->sexp @meta{sexp}))
@end example

@noindent
where @meta{sexp} is the program symbolic expression.  For example,
expanding the program:

@example
(import (vicare))
(define var 1)
(define-syntax (mac stx)
  2)
(display var)
@end example

@noindent
yields the @code{invoke-code}:

@example
(library-letrec*
    ((lex.var   loc.lex.var   '1)
     (lex.dummy loc.lex.dummy
        (begin
          (annotated-call (display var)
             (primitive display) lex.var)
          ((primitive void)))))
  ((primitive void)))
@end example

@noindent
the @code{macro*}:

@example
((loc.lab.mac #<procedure> . (annotated-case-lambda
                                 (#'lambda (#'stx) #'2)
                               ((lex.stx) '2))))
@end example

@noindent
where the procedure is the result of compiling and evaluating the
expanded code; the @code{export-subst} (with many entries removed):

@example
((flmod          . g2374)
 (flonum->string . g990)
 (flsquare       . g743)
 ...
 (var            . lab.var)
 (mac            . lab.mac))
@end example

@noindent
the @code{export-env}:

@example
((lab.var global       . loc.lex.var)
 (lab.mac global-macro . loc.lab.mac))
@end example

@c page
@node iklib expander expand form
@subsubsection Expanding forms


@defun expand-form-to-core-language @var{sexp} @var{env}
Interface to the internal expression expander, it is the expansion
engine used by @rnrs{6}'s @func{eval} function.

@var{sexp} must be a symbolic expression representing a Scheme form;
@var{env} must be an evaluation environment.

Return two values: the result of the expansion as symbolic expression in
the core language; a list of libraries that must be invoked before
evaluating the returned expression.

Example:

@example
(import (vicare))

(receive (code libs)
     (expand-form-to-core-language
        '(define (doit x)
           (if (null? x)
               #f
             (doit (cdr x))))
        (environment '(vicare)))
  code)
@result{} (set! loc.doit
     (annotated-case-lambda doit
       ((lex.x)
        (if (annotated-call (null? x)
              (primitive null?) lex.x)
            '#f
        (annotated-call (doit (cdr x))
          loc.doit
          (annotated-call (cdr x) (primitive cdr) lex.x))))))
@end example
@end defun

@c page
@node iklib expander export specs
@subsection Additional export specifications


@deffn {Export Spec} prefix (@meta{internal} ...) @meta{prefix}
Prepend the specified prefix to the selected internal symbols and add
the result to the export list.  This clause is forbidden when running
with the command line option @option{--strict-r6rs}.

@example
(library (demo)
  (export
    (prefix (these those) yeah.))
  (import (rnrs))
  (define (these) "these")
  (define (those) "those"))
@end example
@end deffn


@deffn {Export Spec} deprefix (@meta{internal} ...) @meta{prefix}
Remove the specified prefix from the selected internal symbols and add
the result to the export list.  This clause is forbidden when running
with the command line option @option{--strict-r6rs}.

@example
(library (demo)
  (export
    (deprefix (yeah.this yeah.that) yeah.))
  (import (rnrs))
  (define (yeah.this) "this")
  (define (yeah.that) "that"))
@end example
@end deffn


@deffn {Export Spec} suffix (@meta{internal} ...) @meta{suffix}
Append the specified suffix to the selected internal symbols and add the
result to the export list.  This clause is forbidden when running with
the command line option @option{--strict-r6rs}.

@example
(library (demo)
  (export
    (suffix (these those) _yeah))
  (import (rnrs))
  (define (these) "these")
  (define (those) "those"))
@end example
@end deffn


@deffn {Export Spec} desuffix (@meta{internal} ...) @meta{suffix}
Remove the specified suffix from the selected internal symbols and add
the result to the export list.  This clause is forbidden when running
with the command line option @option{--strict-r6rs}.

@example
(library (demo)
  (export
    (desuffix (this_yeah that_yeah) _yeah))
  (import (rnrs))
  (define (this_yeah) "this")
  (define (that_yeah) "that"))
@end example
@end deffn

@c page
@node iklib expander import specs
@subsection Additional import specifications


@deffn {Import Spec} deprefix @meta{import-spec} @meta{prefix}
Similar to the import specification @code{prefix}, but remove a prefix
rather than add it.  This clause is forbidden when running with the
command line option @option{--strict-r6rs}.

@example
(import (rnrs)
  (rnrs eval))

(eval '(str.length "ciao")
      (environment
       '(prefix
         (deprefix (only (rnrs)
                         string-length
                         string-append)
                   string-)
         str.)))
@result{} 4
@end example
@end deffn


@deffn {Import Spec} suffix @meta{import-spec} @meta{suffix}
Similar to the import specification @code{prefix}, but append a suffix
rather than a prefix.  This clause is forbidden when running with the
command line option @option{--strict-r6rs}.
@end deffn


@deffn {Import Spec} desuffix @meta{import-spec} @meta{suffix}
Similar to the import specification @code{deprefix}, but remove a suffix
rather than a prefix.  This clause is forbidden when running with the
command line option @option{--strict-r6rs}.
@end deffn

@c page
@node iklib expander local import
@subsection Local library imports


@cindex @clause{import}, local library imports
@cindex Local library imports, @clause{import}
@cindex Importing alternative libraries, @clause{import}
@cindex @clause{import}, importing alternative libraries
@cindex Conditionally importing libraries, @clause{import}
@cindex @clause{import}, conditionally importing libraries


Local @func{import} forms are useful for the following reasons:

@enumerate
@item
They minimize the namespace clutter that usually occurs when many
libraries are imported at the top level.

@item
They limit the scope of the import and thus help modularize a library's
dependencies.

@item
They allow conditional importing of libraries, and so importing
alternative libraries according to some expand--time test.
@end enumerate

Let's suppose we are constructing a large library and at some point we
realize that a procedure needs to make use of some other library to
performing a specific task; importing that library at top level makes it
available for the entire library.  Consequently, even if that library is
no longer used anywhere in the code (say when the code that uses it is
deleted), it becomes very hard to delete the import without first
examiniming the entire library body for potential usage leaks.  By
locally importing a library into the appropriate scope, we gain the
ability to delete the @func{import} form when the procedure that was
using it is deleted.


@deffn Syntax import @meta{import-spec} ...
This syntax can be used anywhere definitions can occur:

@enumerate
@item
In a script body.

@item
At library's top--level.

@item
In internal definitions context.
@end enumerate

The syntax of the local @func{import} form is similar to the
@func{import} that appears at the top of a library or a script form, and
carries with it the same restrictions:

@itemize
@item
No identifier name may be imported twice unless it denotes the same
identifier.

@item
No identifier may be both imported and defined.

@item
Imported identifiers are immutable.
@end itemize

Each @meta{import-spec} can be as defined by @rnrs{6} or a symbol
representing the name of a module; notice that module import
specifications can be only symbols, @strong{without} prefixes, renaming
and the features allowed for libraries.
@end deffn


In the following example we import a library in the body of a function:

@example
;;; file "alpha.sls"
(library (alpha)
  (export doit)
  (import (vicare))
  (define (doit)
    (fprintf (current-error-port) "From alpha!\n")))

;;; file "beta.sls"
(library (beta)
  (export doit)
  (import (vicare))
  (define (doit)
    (fprintf (current-error-port) "From beta!\n")))

;;; file "program.sps"
(import (vicare)
  (alpha))
(define (do-that)
  (import (beta))
  (doit))
(doit)
(do-that)
@print{} From alpha!
@print{} From beta!
@end example

In the following example we import bindings from a module in the body of
a function:

@example
(import (vicare))

(define (doit)
  (fprintf (current-error-port) "From body!\n"))

(module do-stuff
  (doit)
  (define (doit)
    (fprintf (current-error-port) "From module!\n")))

(define (do-that)
  (import do-stuff)
  (doit))

(doit)
(do-that)
@print{} From body!
@print{} From module!
@end example

In the following example: if @ansrfi{13} is available, import
@func{string-concatenate} from it; otherwise define a custom version of
the function.

@example
#!r6rs
(import (vicare)
  (srfi :0))

(cond-expand
 ((srfi :13)
  (import (only (srfi :13)
                string-concatenate)))
 (else
  (define (string-concatenate strs)
    (receive (port getter)
        (open-string-output-port)
      (for-each-in-order (lambda (str)
                           (display str port))
        strs)
      (getter)))))

(display (string-concatenate '("a" "b" "c")))
(newline)
(flush-output-port (current-output-port))
@end example

@c page
@node iklib expander extended export
@subsection Extended library exports


@value{PRJNAME} allows the @func{export} syntax to appear at the top
level of a library among the definitions, not only as third form of a
@func{library} form.


@deffn Syntax export @meta{export-spec} ...
Export the specified bidings from the current library or module.  When
@func{export} appears at the top level of a library: it exports the
specified bindings from the library.  When @func{export} appears in the
body of a module: it exports the specified bindings from the module
(@strong{not} from the enclosing library).
@end deffn


Here is an example of library exporting a binding with a @func{export}
at the end:

@example
;;; file "alpha.sls"
(library (alpha)
  (export red)
  (import (vicare))
  (define (blue)
    'blue)
  (define (red)
    'red)
  (export blue))

;;; file "program.sps"
(import (vicare)
  (alpha))
(pretty-print (red)  (current-error-port))
(pretty-print (blue) (current-error-port))
@end example

Here is an example of module exporting a binding with @func{export}:

@example
(import (vicare))

(module (green)
  (define (green) 'green)
  (define (yellow) 'yellow)
  (export yellow))

(list (green) (yellow)) @result{} (green yellow)
@end example

@c page
@node iklib expander fluids
@subsection Fluid syntaxes


Fluid syntaxes are macro bindings that can be temporarily redefined
while expanding a sequence of forms:

@example
(import (vicare))

(define-fluid-syntax ciao
  (identifier-syntax "ciao"))

ciao    @result{} "ciao"

(fluid-let-syntax ((ciao (identifier-syntax "hello")))
  ciao) @result{} "hello"

(fluid-let-syntax ((ciao (identifier-syntax "ohayo")))
  ciao) @result{} "ohayo"

ciao    @result{} "ciao"
@end example


@deffn Syntax define-fluid-syntax @meta{keyword} @meta{expr}
Like @func{define-syntax} define a new syntax binding the transformer to
@meta{keyword}, but mark @meta{keyword} as fluid so that later it can be
rebound by @func{fluid-let-syntax} or @func{define-fluid-override}.
@end deffn


@deffn Syntax fluid-let-syntax ((@meta{keyword} @meta{expr}) ...) @metao{body} @meta{body}
Similar, but not equal, to @func{let-syntax}; rather than defining new
@meta{keyword} bindings, temporarily rebind the keywords to new
transformers while expanding the @meta{body} forms.  The given
@meta{keyword} must be already bound to fluid syntaxes defined by
@func{define-fluid-syntax}.

There are two differences between @func{fluid-let-syntax} and
@func{let-syntax}: @func{fluid-let-syntax} must appear in expression
context only; the internal @meta{body} forms are @strong{not} spliced in
the enclosing body.
@end deffn


@deffn Syntax define-fluid-override @meta{keyword} @meta{expr}
Temporarily rebind the @meta{keyword} to a new transformer while
expanding the body forms in which this syntax is used.  The given
@meta{keyword} must be already bound to a fluid syntaxe defined by
@func{define-fluid-syntax}.
@end deffn

@c page
@node iklib expander utils
@subsection Utility functions for writing macro


@menu
* iklib expander utils intro::    Introduction to utility functions.
* iklib expander utils id::       Identifiers processing: generic functions.
* iklib expander utils records::  Generating identifiers for records @api{}.
* iklib expander utils structs::  Generating identifiers for structs @api{}.
* iklib expander utils pairs::    Pairs processing.
* iklib expander utils vectors::  Vectors processing.
* iklib expander utils unwrap::   Unwrapping syntax objects.
* iklib expander utils inspect::  Inspecting syntax objects.
* iklib expander utils compar::   Comparing syntax objects.
@end menu

@c page
@node iklib expander utils intro
@subsubsection Introduction to utility functions


Some functions accept an optional argument @var{synner}: when used, it
must be a function accepting 1 or 2 arguments, the first argument being
a string error message and the optional second argument being a subform;
@var{synner} must raise a compound condition object with components:
@condition{who}, @condition{message}, @condition{syntax}.  The
@var{synner} argument is meant to be used as follows:

@example
(define-syntax (my-macro stx)
  (define (synner message subform)
    (syntax-violation 'my-macro message stx subform))
  (syntax-case stx ()
    (pattern body)
    (_
     (synner "invalid syntax" #f))))
@end example

@c page
@node iklib expander utils id
@subsubsection Identifiers processing: generic functions


@defun identifier-bound? @var{id}
Return @true{} if the identifier @var{id} is lexically bound; otherwise
return @false{}.

@example
(import (vicare))

(identifier-bound? #'woppa-woppa-woppa)
@result{} #f

(let ((ciao 123))
  (define-syntax (doit stx)
    (identifier-bound? #'ciao))
  (doit))
@result{} #t

(let ((ciao 123))
  (define-syntax (doit stx)
    (syntax-case stx ()
      ((_ ?id)
       (identifier-bound? #'?id))))
  (doit ciao))
@result{} #t

(let ()
  (define ciao 123)
  (define-syntax (doit stx)
    (syntax-case stx ()
      ((_ ?id)
       (identifier-bound? #'?id))))
  (doit ciao))
@result{} #t

(let ()
  (let-syntax ((ciao (identifier-syntax 123)))
    (define-syntax (doit stx)
      (syntax-case stx ()
        ((_ ?id)
         (identifier-bound? #'?id))))
    (doit ciao)))
@result{} #t
@end example
@end defun


@defun identifier->string @var{id}
Return a string representing the name of the identifier @var{id}.
@end defun


@defun string->identifier @var{ctx} @var{str}
Build and return a new identifier, in the same lexical context of
@var{ctx}, having the string @var{str} as name.
@end defun


@defun identifier-prefix @var{prefix} @var{id}
Build and return a new identifier, in the same lexical context of the
identifier @var{id}, whose string name is the concatenation of
@var{prefix} and @var{id}.  @var{prefix} can be a string, symbol or
identifier.

@example
(import (vicare))

(bound-identifier=? (identifier-prefix "this-" #'that)
                    #'this-that)
@result{} #t
@end example
@end defun


@defun identifier-suffix @var{id} @var{suffix}
Build and return a new identifier, in the same lexical context of the
identifier @var{id}, whose string name is the concatenation of @var{id}
and @var{suffix}.  @var{suffix} can be a string, symbol or identifier.

@example
(import (vicare))

(bound-identifier=? (identifier-suffix #'this "-that")
                    #'this-that)
@result{} #t
@end example
@end defun


@defun identifier-append @var{ctx} @var{item} @dots{}
Build and return a new identifier, in the same lexical context of the
identifier @var{ctx}, whose string name is the concatenation of the
arguments @var{item}.  Each @var{item} can be a string, symbol or
identifier.

@example
(import (vicare))

(bound-identifier=? (identifier-append #'this "-that" '-those)
                    #'this-that-those)
@result{} #t
@end example
@end defun


@defun identifier-format @var{ctx} @var{template} @var{item} @dots{}
Build and return a new identifier, in the same lexical context of the
identifier @var{ctx}, whose string name is the result of formatting the
string @var{template} with the arguments @var{item}.  @var{template} can
be a string including the same escape sequences of @func{format} from
@library{vicare} (@pxref{iklib printing, format}).  Each @var{item} can
be a string, symbol or identifier.

@example
(import (vicare))

(bound-identifier=?
 (identifier-format #'here "~a-~a-~a" #'this "that" 'those)
 #'this-that-those)
@result{} #t
@end example
@end defun


@defun duplicate-identifiers? @var{ids}
@defunx duplicate-identifiers? @var{ids} @var{identifier=}
Search the list of identifiers @var{ids} for duplicate identifiers; at
the first duplicate found, return it; return @false{} if no duplications
are found.

The optional argument @var{identifier=} must be the predicate function
used to compare identifiers; when not given it defaults to
@func{free-identifier=?}.
@end defun


@defun delete-duplicate-identifiers @var{ids}
@defunx delete-duplicate-identifiers @var{ids} @var{identifier=}
Given the list of identifiers @var{ids} remove the duplicate identifiers
and return a proper list of unique identifiers.

The optional argument @var{identifier=} must be the predicate function
used to compare identifiers; when not given it defaults to
@func{free-identifier=?}.
@end defun


@defun identifier-memq @var{id} @var{ids}
@defunx identifier-memq @var{id} @var{ids} @var{identifier=}
Search the list of identifiers @var{ids} for one that matches @var{id}
and return the sublist starting with it; return @false{} if @var{id} is
not present.

The optional argument @var{identifier=} must be the predicate function
used to compare identifiers; when not given it defaults to
@func{free-identifier=?}.
@end defun


@deffn Syntax with-implicits ((@meta{ctx} @meta{symbol} ...) ...) . @meta{body}
Wrapper for @func{with-syntax} which defines the identifiers
@meta{symbol} with the same context of @meta{ctx}.  @meta{ctx} must be
an expression evaluating to an identifier; it is evaluated only once.
@meta{symbol} must be Scheme symbols.

For example:

@example
(syntax-case stx ()
  ((id)
   (identifier? #'id)
   (with-implicits ((#'id x y))
     #'(list x y))))
@end example

@noindent
is equivalent to:

@example
(syntax-case stx ()
  ((id)
   (identifier? #'id)
   (with-syntax ((x (datum->syntax #'id 'x))
                 (y (datum->syntax #'id 'y)))
     #'(list x y))))
@end example

@quotation
@strong{NOTE} This macro is derived from the one documented in the Chez
Scheme User's Guide.
@end quotation
@end deffn

@c page
@node iklib expander utils records
@subsubsection Generating identifiers for records @api{}


@defun identifier-record-constructor @var{type-id}
Assume @var{type-id} is an identifier representing the name of a
@rnrs{6} record type: build and return a new identifer, in the same
lexical context of @var{type-id}, representing the default constructor
name for such record type.

@example
(import (vicare))

(bound-identifier=?
 (identifier-record-constructor #'alpha)
 #'make-alpha)
@result{} #t
@end example
@end defun


@defun identifier-record-predicate @var{type-id}
Assume @var{type-id} is an identifier representing the name of a
@rnrs{6} record type: build and return a new identifer, in the same
lexical context of @var{type-id}, representing the default predicate
name for such record type.

@example
(import (vicare))

(bound-identifier=?
 (identifier-record-predicate #'alpha)
 #'alpha?)
@result{} #t
@end example
@end defun


@defun identifier-record-field-accessor @var{type-id} @var{field-name}
Assume @var{type-id} is an identifier representing the name of a
@rnrs{6} record type: build and return a new identifer, in the same
lexical context of @var{type-id}, representing the default accessor name
for the field @var{field-name} of such record type.  @var{field-name}
can be a string, symbol or identifier.

@example
(import (vicare))

(bound-identifier=?
 (identifier-record-field-accessor #'alpha "one")
 #'alpha-one)
@result{} #t
@end example
@end defun


@defun identifier-record-field-mutator @var{type-id} @var{field-name}
Assume @var{type-id} is an identifier representing the name of a
@rnrs{6} record type: build and return a new identifer, in the same
lexical context of @var{type-id}, representing the default mutator name
for the field @var{field-name} of such record type.  @var{field-name}
can be a string, symbol or identifier.

@example
(import (vicare))

(bound-identifier=?
 (identifier-record-field-mutator #'alpha "one")
 #'alpha-one-set!)
@result{} #t
@end example
@end defun

@c page
@node iklib expander utils structs
@subsubsection Generating identifiers for structs @api{}


@defun identifier-struct-constructor @var{type-id}
Assume @var{type-id} is an identifier representing the name of a Vicare
struct type: build and return a new identifer, in the same lexical
context of @var{type-id}, representing the default constructor name for
such struct type.

@example
(import (vicare))

(bound-identifier=?
 (identifier-struct-constructor #'alpha)
 #'make-alpha)
@result{} #t
@end example
@end defun


@defun identifier-struct-predicate @var{type-id}
Assume @var{type-id} is an identifier representing the name of a Vicare
struct type: build and return a new identifer, in the same lexical
context of @var{type-id}, representing the default predicate name for
such struct type.

@example
(import (vicare))

(bound-identifier=?
 (identifier-struct-predicate #'alpha)
 #'alpha?)
@result{} #t
@end example
@end defun


@defun identifier-struct-field-accessor @var{type-id} @var{field-name}
Assume @var{type-id} is an identifier representing the name of a Vicare
struct type: build and return a new identifer, in the same lexical
context of @var{type-id}, representing the default accessor name for the
field @var{field-name} of such struct type.  @var{field-name} can be a
string, symbol or identifier.

@example
(import (vicare))

(bound-identifier=?
 (identifier-struct-field-accessor #'alpha "one")
 #'alpha-one)
@result{} #t
@end example
@end defun


@defun identifier-struct-field-mutator @var{type-id} @var{field-name}
Assume @var{type-id} is an identifier representing the name of a Vicare
struct type: build and return a new identifer, in the same lexical
context of @var{type-id}, representing the default mutator name for the
field @var{field-name} of such struct type.  @var{field-name} can be a
string, symbol or identifier.

@example
(import (vicare))

(bound-identifier=?
 (identifier-struct-field-mutator #'alpha "one")
 #'set-alpha-one!)
@result{} #t
@end example
@end defun

@c page
@node iklib expander utils pairs
@subsubsection Pairs processing


@defun syntax-car @var{stx}
@defunx syntax-car @var{stx} @var{synner}
Expect @var{stx} to be a syntax object holding pair; return a syntax
object representing the car of @var{stx}.

@example
(import (vicare))

(bound-identifier=? (syntax-car #'(display . write))
                    #'display)
@result{} #t
@end example
@end defun


@defun syntax-cdr @var{stx}
@defunx syntax-cdr @var{stx} @var{synner}
Expect @var{stx} to be a syntax object holding pair; return a syntax
object representing the cdr of @var{stx}.

@example
(import (vicare))

(bound-identifier=? (syntax-cdr #'(display . write))
                    #'write)
@result{} #t
@end example
@end defun


@defun syntax->list @var{stx}
@defunx syntax->list @var{stx} @var{synner}
Expect @var{stx} to be a syntax object holding a proper list of items;
return a proper list holding the individual item syntax objects.

@example
(import (vicare))

(for-all (lambda (obj1 obj2)
           (if (identifier? obj2)
               (bound-identifier=? obj1 obj2)
             (equal? obj1 obj2)))
  (syntax->list #'(display 123 write))
  (list #'display 123 #'write))
@result{} #t
@end example
@end defun


@defun identifiers->list @var{stx}
@defunx identifiers->list @var{stx} @var{synner}
Expect @var{stx} to be a syntax object holding a proper list of
identifiers; return a proper list holding the individual identifiers.

@example
(import (vicare))

(for-all bound-identifier=?
  (identifiers->list #'(display write))
  (list #'display #'write))
@result{} #t
@end example
@end defun


@defun all-identifiers? @var{stx}
Return @true{} if @var{stx} is a syntax object representing the empty
list or a proper list of identifiers, otherwise return @false{}.
@end defun

@c page
@node iklib expander utils vectors
@subsubsection Vectors processing


@defun syntax->vector @var{stx}
@defunx syntax->vector @var{stx} @var{synner}
Expect @var{stx} to be a syntax object holding a vector of items; return
a proper list holding the individual item syntax objects.

@example
(import (vicare))

(vector-for-all
    (lambda (obj1 obj2)
      (if (identifier? obj2)
          (bound-identifier=? obj1 obj2)
        (equal? obj1 obj2)))
  (syntax->vector #'#(display 123 write))
  (vector #'display 123 #'write))
@result{} #t
@end example
@end defun

@c page
@node iklib expander utils unwrap
@subsubsection Unwrapping syntax objects


@defun syntax-unwrap @var{stx}
Given a syntax object @var{stx} decompose it and return the
corresponding symbolic expression holding datums and identifiers.  Take
care of returning a proper list when the input is a syntax object
holding a proper list.
@end defun

@c page
@node iklib expander utils inspect
@subsubsection Inspecting syntax objects


@c @defun quoted-syntax-object? @var{stx}
@c Given a syntax object: return @true{} if it is a list whose car is one
@c among the identifiers @func{quote}, @func{quasiquote}, @func{syntax},
@c @func{quasisyntax}; return @false{} otherwise.
@c @end defun

@c page
@node iklib expander utils compar
@subsubsection Comparing syntax objects


@defun syntax=? @vari{stx} @varii{stx}
Recursively visit the internals of the given syntax objects and return
@true{} if they are equal; return @false{} otherwise.  Identifiers are
compared with @func{free-identifier=?}.
@end defun


@defun {identifier=symbol?} @var{id} @var{sym}
Return true if the symbol @var{sym} is equal to the symbol name of the
identifier @var{id}.
@end defun

@c page
@node iklib expander clauses
@subsection Syntax clauses helpers


When writing definition macros similar to @func{define-record-type} it
is quite useful to include in the syntax ``clauses'' that optionally
specify the behaviour of the defined thing.  A list of clauses is a
syntax object with the format:

@example
((@meta{identifier} @meta{thing} ...) ...)
@end example

@noindent
in which @meta{identifier} is meant to be an auxiliary syntax (as
defined by @func{define-auxiliary-syntaxes} or @func{define-syntax}) and
the optional @meta{thing} arguments can represent any symbolic
expression.  The functions documented in this section help in validating
and processing such clauses.

@menu
* iklib expander clauses intro::    Introduction to clauses functions.
* iklib expander clauses utils::    Syntax clauses utilities.
* iklib expander clauses constr::   Syntax clauses constraints.
* iklib expander clauses objects::  Clause specification objects.
@end menu

@c page
@node iklib expander clauses intro
@subsubsection Introduction to clauses functions


Some functions accept an optional argument @var{synner}: when used, it
must be a function accepting 1 or 2 arguments, the first argument being
a string error message and the optional second argument being a subform;
@var{synner} must raise a compound condition object with components:
@condition{who}, @condition{message}, @condition{syntax}.  The
@var{synner} argument is meant to be used as follows:

@example
(define-syntax (my-macro stx)
  (define (synner message subform)
    (syntax-violation 'my-macro message stx subform))
  (syntax-case stx ()
    (pattern body)
    (_
     (synner "invalid syntax" #f))))
@end example

@c page
@node iklib expander clauses utils
@subsubsection Syntax clauses utilities


@defun syntax-clauses-unwrap @var{clauses}
@defunx syntax-clauses-unwrap @var{clauses} @var{synner}
Scan the syntax object @var{clauses} expecting it to represent a list of
clauses; return a new syntax object representing @var{clauses} fully
unwrapped.  The function @var{synner} is invoked if the structure of
@var{clauses} is invalid.
@end defun


@defun syntax-clauses-filter @var{keywords} @var{unwrapped-clauses}
Given a fully unwrapped syntax object @var{unwrapped-clauses} holding a
list of clauses (for example the return value of
@func{syntax-clauses-unwrap}) select the ones having @meta{identifier}
being @func{free-identifier=?} to an identifier in the list
@var{keywords} and return the selected clauses in a fully unwrapped
syntax object holding the list of them; return null if no matching
clause is found.
@end defun


@defun syntax-clauses-remove @var{keywords} @var{unwrapped-clauses}
Given a fully unwrapped syntax object @var{unwrapped-clauses} holding a
list of clauses (for example the return value of
@func{syntax-clauses-unwrap}) remove the ones having @meta{identifier}
being @func{free-identifier=?} to an identifier in the list
@var{keywords} and return the selected clauses in a fully unwrapped
syntax object holding the list of them; return null if no matching
clause is found.
@end defun


@defun syntax-clauses-partition @var{keywords} @var{unwrapped-clauses}
Given a fully unwrapped syntax object @var{unwrapped-clauses} holding a
list of clauses (for example the return value of
@func{syntax-clauses-unwrap}) partition it into: a list of clauses
having @meta{identifier} being @func{free-identifier=?} to an identifier
in the list @var{keywords}, a list of non--matching clauses.  Return the
two lists.

This function can be used to check that a list of clauses only contains
clauses with selected identifiers.
@end defun


@defun syntax-clauses-collapse @var{unwrapped-clauses}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}): collapse the
clauses having equal @meta{identifier} into a single clause and return
the resulting unwrapped syntax object.  Example:

@example
(syntax-clauses-collapse ((#'fields #'a #'b #'c)
                          (#'fields #'d #'e #'f)))
@result{} ((#'fields #'a #'b #'c #'d #'e #'f))
@end example
@end defun

@c page
@node iklib expander clauses constr
@subsubsection Syntax clauses constraints


@defun syntax-clauses-verify-at-least-once @var{keywords} @var{unwrapped-clauses}
@defunx syntax-clauses-verify-at-least-once @var{keywords} @var{unwrapped-clauses} @var{synner}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}) verify that
all the identifiers in the list @var{keywords} are present at least once
as clause identifiers.  If successful return unspecified values, else
call @var{synner} or raise a @condition{syntax} violation exception.
@end defun


@defun syntax-clauses-verify-at-most-once @var{keywords} @var{unwrapped-clauses}
@defunx syntax-clauses-verify-at-most-once @var{keywords} @var{unwrapped-clauses} @var{synner}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}) verify that
all the identifiers in the list @var{keywords} are present at most once
as clause identifiers.  If successful return unspecified values, else
call @var{synner} or raise a @condition{syntax} violation exception.
@end defun


@defun syntax-clauses-verify-exactly-once @var{keywords} @var{unwrapped-clauses}
@defunx syntax-clauses-verify-exactly-once @var{keywords} @var{unwrapped-clauses} @var{synner}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}) verify that
all the identifiers in the list @var{keywords} are present exactly once
as clause identifiers.  If successful return unspecified values, else
call @var{synner} or raise a @condition{syntax} violation exception.
@end defun


@defun syntax-clauses-verify-mutually-inclusive @var{keywords} @var{unwrapped-clauses}
@defunx syntax-clauses-verify-mutually-inclusive @var{keywords} @var{unwrapped-clauses} @var{synner}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}) verify that if
one of the identifiers in the list @var{keywords} is present at least
once as clause identifier, then all the others are present too.  If
successful return unspecified values, else call @var{synner} or raise a
@condition{syntax} violation exception.
@end defun


@defun syntax-clauses-verify-mutually-exclusive @var{keywords} @var{unwrapped-clauses}
@defunx syntax-clauses-verify-mutually-exclusive @var{keywords} @var{unwrapped-clauses} @var{synner}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}) verify that if
one of the identifiers in the list @var{keywords} is present at least
once as clause identifier, then all the others are @strong{not} present.
If successful return unspecified values, else call @var{synner} or raise
a @condition{syntax} violation exception.
@end defun

@c page
@node iklib expander clauses objects
@subsubsection Clause specification objects


Clause specification objects are opaque objects, disjoint from all the
other Scheme object types, representing the constraints enforceable on a
syntax clause.


@defun make-syntax-clause-spec @var{keyword} @var{min-occur} @var{max-occur} @var{min-args} @var{max-args} @var{mutually-inclusive} @var{mutually-exclusive}
@defunx make-syntax-clause-spec @var{keyword} @var{min-occur} @var{max-occur} @var{min-args} @var{max-args} @var{mutually-inclusive} @var{mutually-exclusive} @var{custom-data}
Build and return a new syntax clause specification object.  The
arguments are:

@table @var
@item keyword
An identifier representing the keyword for this clause.

@item min-occur
A non--negative real number representing the allowed minimum number of
occurrences for this clause.  @samp{0} means the clause is optional;
@samp{1} means the clause is mandatory.

@item max-occur
A non--negative real number representing the allowed maximum number of
occurrences for this clause.  @samp{0} means the clause is forbidden;
@samp{1} means the clause must appear at most once; @samp{+inf.0} means
the clause can appear any number of times.

@item min-args
A non--negative real number representing the allowed minimum number of
arguments for this clause.  @samp{0} means the clause can have no
arguments; @samp{1} means the clause must have at least one argument.

@item max-args
A non--negative real number representing the allowed maximum number of
arguments for this clause.  @samp{0} means the clause has no arguments;
@samp{1} means the clause must have at most one arguments; @samp{+inf.0}
means the clause can have any number of arguments.

@item mutually-inclusive
A list identifiers representing clauses keywords that must appear along
with this one.

@item mutually-exclusive
A list identifiers representing clauses keywords that must not appear
along with this one.

@item custom-data
Optional free value available for the user.  It is initialised to
@false{}.
@end table
@end defun


@defun syntax-clause-spec? @var{obj}
Return @true{} if @var{obj} is a syntax clause specification object,
otherwise return @false{}.
@end defun


@defun syntax-clause-spec-keyword @var{spec}
@defunx syntax-clause-spec-min-number-of-occurrences @var{spec}
@defunx syntax-clause-spec-max-number-of-occurrences @var{spec}
@defunx syntax-clause-spec-min-number-of-arguments @var{spec}
@defunx syntax-clause-spec-max-number-of-arguments @var{spec}
@defunx syntax-clause-spec-mutually-inclusive @var{spec}
@defunx syntax-clause-spec-mutually-exclusive @var{spec}
@defunx syntax-clause-spec-custom-data @var{spec}
Accessors for the fields of syntax clause specification objects.
@end defun


@defun syntax-clauses-single-spec @var{spec} @var{unwrapped-clauses}
@defunx syntax-clauses-single-spec @var{spec} @var{unwrapped-clauses} @var{synner}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}) verify if
there are clauses conforming to the given specification @var{spec}.

If successful return a (possibly empty) vector of vectors of syntax
objects; else call @var{synner} or raise a @condition{syntax} exception.
The length of the returned vector is the number of clauses from
@var{unwrapped-clauses} conforming to @var{spec}.  Each nested vector
represents the cdr of a clause matching @var{spec}:

@itemize
@item
If a clause has no arguments: the corresponding nested vector is empty.

@item
If a clause has @math{1} argument: the corresponding nested vector has
@math{1} item being the syntax object representing the argument.

@item
If a clause has @math{N} arguments: the corresponding nested vector has
@math{N} items being the syntax objects representing the arguments.
@end itemize

Examples:

@example
(import (vicare))

(syntax-clauses-single-spec
   (make-syntax-clause-spec #'b 1 1 1 1 '() '())
   (syntax-clauses-unwrap #'((a 123)
                             (b 456)
                             (d 789))))
@result{} #(#(456))

(syntax-clauses-single-spec
   (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
   (syntax-clauses-unwrap #'((a 123)
                             (b)
                             (d 789))))
@result{} #(#())

(syntax-clauses-single-spec
   (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
   (syntax-clauses-unwrap #'((a 123)
                             (b 4 5 6)
                             (d 789))))
@result{} #(#(4 5 6))

(syntax-clauses-single-spec
   (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
   (syntax-clauses-unwrap #'((a 123)
                             (b 4)
                             (b 5)
                             (b 6)
                             (d 789))))
@result{} #(#(4) #(5) #(6))

(syntax-clauses-single-spec
   (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
   (syntax-clauses-unwrap #'((a 123)
                             (b 4 4.1)
                             (b 5 5.1)
                             (d 789))))
@result{} #(#(4 4.1) #(5 5.1))

(syntax-clauses-single-spec
   (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
   (syntax-clauses-unwrap #'((a 123)
                             (b 4 ciao 6)
                             (d 789))))
@result{} #(#(4 #<syntax-object expr=ciao> 6))
@end example
@end defun


@defun syntax-clauses-fold-specs @var{combine} @var{knil} @var{specs} @var{unwrapped-clauses}
@defunx syntax-clauses-fold-specs @var{combine} @var{knil} @var{specs} @var{unwrapped-clauses} @var{synner}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}) verify that
the clauses conform to the given @var{specs}, which must be a list of
syntax clause specification objects.

Combine the clause arguments with the given @var{knil} in a
@func{fold-left} fashion, if successful return the resulting @var{knil};
if an invalid clause is found call @var{synner} or raise a
@condition{syntax} object.

The operation is conceptually as follows:

@example
(fold-left
    (lambda (knil spec)
      (let ((args (syntax-clauses-single-spec spec
                     @var{unwrapped-clauses} @var{synner})))
        (if (fxzero? (vector-length args))
            knil
          (@var{combine} knil spec args))))
  @var{knil}
  @var{specs})
@end example

@noindent
notice that @var{combine} is called only if a clause from @var{specs} is
present in @var{unwrapped-clauses}; @var{combine} must return the new
value for @var{knil}.
@end defun


@defun syntax-clauses-validate-specs @var{list-of-specs}
Given a list of @objtype{syntax-clause-spec} objects: perform some
validations among them.  If successful return @var{list-of-specs}
itself, otherwise raise an assertion violation.

The following checks are performed:

@itemize
@item
For every identifier listed in the @code{mutually-inclusive} field of
every @objtype{syntax-clause-spec}: check that such identifier is equal,
according to @func{free-identifier=?}, to an identifier in the
@code{keyword} field of another @objtype{syntax-clause-spec} object.

@item
For every identifier listed in the @code{mutually-exclusive} field of
every @objtype{syntax-clause-spec}: check that such identifier is equal,
according to @func{free-identifier=?}, to an identifier in the
@code{keyword} field of another @objtype{syntax-clause-spec} object.
@end itemize
@end defun

@c page
@node iklib expander ctv
@subsection Compile--time values


It is sometimes useful to precompute a value at expand--time and push it
on the lexical environment to be later retrieved.  Here is an example of
simple compile--time value (@acronym{CTV}) computation, retrieval and
insertion in which the value is a self--evaluating fixnum:

@example
(import (vicare))

(define-syntax obj1
  (make-compile-time-value (+ 1 2 3)))

(define-syntax get-obj1
  (lambda (stx)
    (lambda (ctv-retriever)
      (ctv-retriever #'obj1))))

(get-obj1) @expansion{} 6
@end example

@noindent
here is an example of simple compile--time value computation, retrieval
and insertion in which the value is a non--self--evaluating vector:

@example
(import (vicare))

(define-syntax obj2
  (make-compile-time-value (vector 1 2 3)))

(define-syntax get-obj2
  (lambda (stx)
    (lambda (ctv-retriever)
      #`(quote #,(ctv-retriever #'obj2)))))

(get-obj2) @expansion{} (quote #(1 2 3))
@end example

@noindent
we see that to produce a compile--time value we define a syntax bound to
the result of @func{make-compile-time-value}.

We can use a compile--time value in the body of a transformer function;
whenever a syntax transformer function returns a function: such function
is called by the expander with a single argument being a compile--time
value retriever; if the retriever is applied to an identifier bound to a
@acronym{CTV}: it returns the value itself or @false{} if the identifier
is not bound to a @acronym{CTV}.  Once we have the @acronym{CTV}
retriever: we can retrieve all the @acronym{CTV} objects currently on
the lexical environment.


@defun make-compile-time-value @var{obj}
Build and return a ``special'' object that is recognised by the expander
as holding @var{obj} as a precomputed compile--time object.
@end defun


@defun compile-time-value? @var{obj}
Return @true{} if @var{obj} is a ``special'' object that is recognised
by the expander as holding a precomputed compile--time object.
@end defun


@defun compile-time-value-object @var{ctv}
Given a ``special'' object that is recognised by the expander as holding
a precomputed compile--time object: return the actual value.
@end defun

@c ------------------------------------------------------------

@subsubheading What compile--time values are @strong{not} for


We have to understand that the real use of compile--time values is not
actually to precompute values and put them in compiled code; for this we
can just use @func{define-inline-constant}, which in the end defines a
``normal'' syntax transformer as the following:

@example
(import (vicare))

(define-syntax obj1
  (let ((const (vector 1 2 3)))
    (lambda (stx)
      (syntax-case stx ()
        (?id
         (identifier? #'?id)
         #`(quote #,const))))))

obj1    @expansion{} (quote #(1 2 3))
@end example

@c ------------------------------------------------------------

@subsubheading What compile--time values are for


Let's say we define a record type in a library (it must go in a library
so that we can import it and use it at expand--time in the body of
transformers):

@example
(library (ctv-demo)
  (export that make-that)
  (import (vicare))
  (define-record-type that
    (fields a b c)))
@end example

@noindent
now we can instantiate a struct @code{that} and push the instance on the
lexical environment bound to the identifier @code{it}:

@example
(import (vicare)
  (for (proof)
    expand))

(define-syntax it
  (make-compile-time-value
   (make-that 1 2 3)))
@end example

@noindent
later we retrieve the struct instance, through the identifier @code{it},
and use its fields to produce the output of a syntax use:

@example
(define-syntax get-it
  (lambda (stx)
    (lambda (ctv-retriever)
      (let ((S (ctv-retriever #'it)))
        (with-syntax
            ((A (record-type-field-ref that a S))
             (B (record-type-field-ref that b S))
             (C (record-type-field-ref that c S)))
          #'(quote #(A B C)))))))

(get-it)        @expansion{} (quote #(1 2 3))
@end example

@c page
@node iklib expander parameters
@subsection Expand--time parameters


Fluid syntaxes and compile--time values can be used to implement a sort
of expand--time parameters, @ref{iklib parameters, Parameters}.  The
following example shows the mechanism by defining a ``parameter''
@samp{parm}:

@example
(import (vicare))

(define-syntax (show-it stx)
  (lambda (ctv-retriever)
    (fprintf (current-error-port)
             "parm ~a: ~a\n"
             (cadr (syntax->datum stx))
             (ctv-retriever #'parm))
    #f))

(define-fluid-syntax parm
  (make-compile-time-value #f))

(show-it "1, expect #f")
(fluid-let-syntax ((parm (make-compile-time-value #t)))
  (show-it "2, expect #t")
  (fluid-let-syntax ((parm (make-compile-time-value #f)))
    (show-it "3, expect #f"))
  (show-it "4, expect #t"))
(show-it "5, expect #f")
@end example

@noindent
the output of the program is:

@example
parm 1, expect #f: #f
parm 5, expect #f: #f
parm 2, expect #t: #t
parm 3, expect #f: #f
parm 4, expect #t: #t
@end example

@noindent
Using the @api{} described here, the example can be rewritten:

@example
(import (vicare))

(define-syntax (show-it stx)
  (fprintf (current-error-port)
           "parm ~a: ~a\n"
           (cadr (syntax->datum stx))
           (syntax-parameter-value #'parm))
  #f)

(define-syntax-parameter parm #f)

(show-it "1, expect #f")
(syntax-parametrise ((parm #t))
  (show-it "2, expect #t")
  (syntax-parametrise ((parm #f))
    (show-it "3, expect #f"))
  (show-it "4, expect #t"))
(show-it "5, expect #f")
@end example


@deffn Syntax define-syntax-parameter @meta{parm-id} @meta{expr}
Define a new syntax parameter bound to the identifier @meta{parm-id}.
The parameter is initialised to the result of evaluating the
compile--time expression @meta{expr}.
@end deffn


@deffn Syntax syntax-parametrise ((@meta{parm-id} @meta{expr}) @dots{}) @metao{body} @meta{body} @dots{}
Bind one or more syntax parameters to new compile--time values and while
the body forms are expanded.  The arguments @meta{parm-id} must be
identifiers previously bound to compile--time values by
@func{define-syntax-parameter}.  The arguments @meta{expr} must be
expressions.
@end deffn


@defun syntax-parameter-value @var{parm-id}
Return the syntax parameter value bound to @var{parm-id}, which must be
an identifier previously bound by @func{define-syntax-parameter}.  This
function must be called only from the extent of a macro expansion; in
practice: only by a macro transformer.
@end defun

@c page
@node iklib expander synonym
@subsection Synonym transformers


Synonym transformers allow the creation of multiple identifiers which
resolve to the same syntactic binding.  Usage examples:

@example
(import (vicare))

(define a 1)

(define-syntax b
  (make-synonym-transformer #'a))

(list a b)      @result{} (1 1)

(define-syntax c
  (make-synonym-transformer #'b))

(list a b c)    @result{} (1 1 1)

(define-syntax d
  (make-synonym-transformer #'b))

(set! c 2)

(list a b c d)  @result{} (2 2 2 2)
@end example

Circular references are detected and cause a syntax violation to be
raised.

If the identifier @vari{id} is bound to a synonym transformer with
source identifier @varii{id}: the two identifiers resolve to the same
syntactic binding but are @strong{not} @func{free-identifier=?}.  To
create an identifier that is @func{free-identifier=?} to another we have
to use @func{define-alias}.


@defun make-synonym-transformer @var{id}
Build and return a ``special'' value that, when used as right--hand side
of a syntax definition, is recognised by the expander as a synonym
transformer as opposed to a normal transformer, variable transformer or
a compile--time value.  @var{id} must be the source identifier.
@end defun


@defun synonym-transformer? @var{obj}
Return @true{} if @var{obj} is recognised by the expander as a synonym
transformer as opposed to a normal transformer, variable transformer or
a compile--time value; otherwise return @false{}.
@end defun


@defun synonym-transformer-identifier @var{obj}
If @var{obj} is recognised by the expander as a synonym transformer:
return the source identifier, otherwise raise an exception.
@end defun

@c page
@node iklib shared
@section Shared structures graph notation


This feature of the reader is derived from the @srfi{} 38 ``External
Representation for Data With Shared Structure'':

@center @url{http://srfi.schemers.org/srfi-38/srfi-38.html}

This graph notation allows the reader to build symbolic expressions with
graph structure including cycles.  @strong{Shared structures must always
be used inside quoted datums}; if we create a cycle in a symbolic
expression passed as code to the expander: the result will be an
infinite loop.  Graph notation is available only when the textual input
port is configured in @code{#!vicare} mode.

Graph notation extends the @rnrs{6} syntax with these additional cases:

@example
<lexeme>                -> <r6rs lexeme>
                         | <defining datum>
                         | <defined datum>
<defining datum>        -> #<indexnum>=<r6rs lexeme>
<defined datum>         -> #<indexnum>#
<indexnum>              -> <digit>+
@end example

@noindent
where @code{<r6rs lexeme>} is the lexeme definition in @rnrs{6}.


@deffn Parameter print-graph
@deffnx Parameter print-graph #t
@deffnx Parameter print-graph #f
The graph notation is a way of marking and referencing parts of a data
structure and, consequently, creating shared and cyclic data structures
at read time instead of resorting to explicit mutation at run time.  The
@code{#n=} marks the following data structure with mark @var{n}, where
@var{n} is a nonnegative integer.  The @code{#n#} references the data
structure marked @var{n}.  Marks can be assigned and referenced in any
order but each mark must be assigned to exactly once in an expression.

@example
> (let ([x '#0=(1 2 3)])
    (eq? x '#0#))
#t
> (let ([x '#0#] [y '#0=(1 2 3)])
    (eq? x y))
#t
> (eq? (cdr '(12 . #1#)) '#1=(1 2 3))
#t
> (let ([x '#1=(#1# . #1#)])
    (and (eq? x (car x))
         (eq? x (cdr x))))
#t
@end example

The @func{print-graph} parameter controls how the writers (e.g.
@func{pretty-print} and @func{write}) handle shared and cyclic data
structures.  In @value{PRJNAME}, all writers detect cyclic data structures and
they all terminate on all input, cyclic or otherwise.

If the value of @func{print-graph} is set to @false{} (the default),
then the writers do not attempt to detect shared data structures.  Any
part of the input that is shared is printed as if no sharing is present.
If the value of @func{print-graph} is set to @true{}, all sharing of
data structures is marked using the @code{#n=} and @code{#n#} notation.

@example
> (parameterize ([print-graph #f])
    (let ([x (list 1 2 3 4)])
      (pretty-print (list x x x))))
((1 2 3 4) (1 2 3 4) (1 2 3 4))

> (parameterize ([print-graph #t])
    (let ([x (list 1 2 3 4)])
      (pretty-print (list x x x))))
(#0=(1 2 3 4) #0# #0#)

> (parameterize ([print-graph #f])
    (let ([x (list 1 2)])
      (let ([y (list x x x x)])
        (set-car! (last-pair y) y)
        (pretty-print (list y y)))))
(#0=((1 2) (1 2) (1 2) #0#) #0#)

> (parameterize ([print-graph #t])
    (let ([x (list 1 2)])
      (let ([y (list x x x x)])
        (set-car! (last-pair y) y)
        (pretty-print (list y y)))))
(#0=(#1=(1 2) #1# #1# #0#) #0#)
@end example
@end deffn

@c page
@node iklib environment
@section Environments


@cindex Environment, interaction


The following bindings are exported by the library @library{vicare}.


@defun environment? @var{env}
Return @true{} if @var{env} is an environment object.
@end defun


@defun interaction-environment
@defunx interaction-environment @var{env}
When called with no arguments: return an environment object representing
the environment active at the @repl{}; to be used as argument for
@func{eval}.

When called with the argument @var{env}, which must be an environment
object: set @var{env} as interaction environment.
@end defun


@defun new-interaction-environment
@defunx new-interaction-environment @var{libname}
Build and return a new interaction environment object.  When no argument
is given: the returned environment is initialised by importing the
library @library{vicare}.  When @var{libname} is used it must be a
library name specification: the returned environment is initialised with
the specified library.
@end defun


Notice that it is possible to use interaction environments to have
persistent bindings:

@example
(begin
  (eval '(begin
           (define a 1)
           (define b 2))
        (interaction-environment))
  (eval '(list a b)
        (interaction-environment)))
@result{} (1 2)

(begin
  (eval '(define c 3)
        (interaction-environment))
  (eval 'c
        (interaction-environment)))
@result{} 3

(let ((env (new-interaction-environment)))
  (eval '(begin
           (define a 1)
           (define b 2))
        env)
  (eval '(list a b)
        env))
@result{} (1 2)
@end example

@noindent
and it is also possible to import additional libraries:

@example
(eval '(import (nausicaa))
       (interaction-environment))
@end example


@defun environment-symbols @var{env}
Return a list of symbols representing the names of the bindings from
@var{env}, which must be an environment.  The name in position @math{i}
in the returned list is associated to the label in position @math{i} in
the list returned by @func{environment-labels}.

For example, the following program prints all the bindings in the
library @library{vicare language-extensions}:

@example
#!r6rs
(import (vicare))
(for-each pretty-print
  (environment-symbols
   (environment '(vicare language-extensions))))
(flush-output-port (current-output-port))
@end example
@end defun


@defun environment-labels @var{env}
Return a list of symbols representing the labels of the bindings from
the given non--interaction environment.  The label in position @math{i}
in the returned list is associated to the name in position @math{i} in
the list returned by @func{environment-symbols}.
@end defun


@defun environment-libraries @var{env}
Return the list of @code{library} records representing the libraries
forming the non--interaction environment @var{env}.
@end defun


@defun environment-binding @var{sym} @var{env}
Search the symbol @var{sym} in the non--interaction environment
@var{env}; if @var{sym} is the public name of a binding in @var{env}
return 2 values: the label associated to the binding, the list of values
representing the binding.  If @var{sym} is not present in @var{env}
return false and false.

@example
(environment-binding 'display (environment '(vicare)))
@result{} #@{g870 |/1tY778AJ%G&f2UX|@} (core-prim . display)
@end example
@end defun

@c page
@node iklib cafe
@section Cafe


The following bindings are exported by the library @library{vicare}.


@defun new-cafe
@defunx new-cafe @var{eval}
Start a new read--eval--print loop (@repl{}) inside the current cafe (if
one exists).  It prompts the user for an expression, evaluates it,
prints the result back, and repeats the process.  If @func{new-cafe} is
called with an argument, @var{eval}, then that argument must be a
procedure that takes a single argument; the @var{eval} procedure will be
used to evaluate the expressions.

Every time a new cafe is started, the prompt is changed to reflect the
depth of the current cafe (i.e. how many eof objects is takes to exit
the outermost cafe).

When the readline interface is not used, input and output performed by
the cafe can be changed by the @func{console-input-port} and
@func{console-output-port} parameters; when readline support is
available and used, the @repl{} input is performed through a readline
input port.

If an error occurs during reading, evaluating, or printing an
expression, then the error message is printed to the error--port and the
operations of the cafe resume as normal.

To exit from a cafe we can write the @eof{} object.
@end defun

@c page
@node iklib structs
@section Structures and type descriptors


A data structure is like a lightweight record as defined by @rnrs{6}.
@ref{objects structs} for more informations on the internals of data
structures.

@menu
* iklib structs rtd::           Structure type descriptors.
* iklib structs using::         Using data structures.
* iklib structs inspect::       Inspecting data structures.
* iklib structs fields::        Accessing and mutating fields.
@end menu

@c page
@node iklib structs rtd
@subsection Structure type descriptors


The following bindings are exported by the library @library{vicare}.


@deffn Syntax define-struct @meta{name} (@meta{field} ...)
@deffnx Syntax define-struct (@meta{name} @meta{constructor} @meta{predicate}) (@meta{field} ...)
Define a new data structure type.  This macro is embedded in the
expander.

@meta{name} must be a symbol representing the name of the structure; it
is used to build names for the constructor, predicate, field accessors
and mutators.  When @meta{constructor} is used: it must be an identifier
representing the name of the constructor.  When @meta{predicate} is
used: it must be an identifier representing the name of the predicate.
The @meta{field} values must be symbols representing the names of the
fields; they are used to build names for the accessors and mutators.

The following definition:

@example
(define-struct color
  (red green blue))
@end example

@noindent
expands to the definition of the following bindings:

@table @code
@item color
When the identifier representing the record type name is used in macro
keyword position with the syntax:

@example
(@meta{name} (@meta{expr} ...))
@end example

@noindent
the form is expanded to the application of the constructor to the
results of evaluating the @meta{expr} arguments:

@example
(color (1 2 3)) @result{} #["color" 1 2 3]
@end example

@item make-color @var{red} @var{green} @var{blue}
A structure constructor accepting as much arguments as there are fields.
The constructor makes use of the @func{$struct} low level operation.

@item color? @var{obj}
A predicate to distinguish between references to @code{color} structures
and other values.  This predicate makes use of the @func{$struct/rtd?}
low level operation.

@item color-red @var{stru}
@itemx color-green @var{stru}
@itemx color-blue @var{stru}
Accessor functions for the fields of the structure.  These accessors
make use of the @func{$struct/rtd?} low level operation to validate the
argument and if successful they use @func{$struct-ref} to extract the
value; if the argument is of invalid type: an assertion violation is
raised.

@item set-color-red! @var{stru} @var{red}
@itemx set-color-green! @var{stru} @var{green}
@itemx set-color-blue! @var{stru} @var{blue}
Mutator functions for the fields of the structure.  These mutators make
use of the @func{$struct/rtd?} low level operation to validate the
argument @var{stru} and if successful they use @func{$struct-set!} to
set the value; if the argument @var{stru} is of invalid type: an
assertion violation is raised.

@item $color-red @var{stru}
@itemx $color-green @var{stru}
@itemx $color-blue @var{stru}
Unsafe accessor syntaxes for the fields of the structure.  These
accessors do not validate the arguments and expand directly to a use of
@func{$struct-ref} to extract the value; if the argument is invalid: the
behaviour is undefined.

@item $set-color-red! @var{stru} @var{red}
@itemx $set-color-green! @var{stru} @var{green}
@itemx $set-color-blue! @var{stru} @var{blue}
Unsafe mutator syntaxes for the fields of the structure.  These mutators
do not validate the arguments and expand directly to a use of
@func{$struct-set!} to set the value; if the argument @var{stru} is
invalid: the behaviour is undefined.
@end table
@end deffn


@defun make-struct-type @var{name} @var{fields}
@defunx make-struct-type @var{name} @var{fields} @var{uid}
Build and return a new structure type descriptor.  @var{name} must be a
string representing the type name.  @var{fields} must be a list of
symbols representing the field names.

The optional @var{uid} argument must be a symbol uniquely identifying
this type; when not supplied, a symbol is automatically generated.  The
@func{$symbol-value} field of @var{uid} is set to the newly created
@rtd{}; if @var{uid} already has a symbol value: such value must be a
struct descriptor equal to the newly created @rtd{}.
@end defun


@deffn Syntax struct-type-descriptor @meta{name}
Evaluate to the type descriptor of the data structure @meta{name}, which
must be the first argument to a previous use of @func{define-struct}.
@end deffn


@deffn Syntax struct-type-and-struct? @meta{type-name} @meta{stru}
Return @true{} if @meta{stru} is an expression evaluating to a struct
instance of type @meta{type-name}; otherwise return @false{}.  This
syntax allows to test the type of a record instance through the type
name identifier, without the need to export the predicate identifier out
of libraries.
@end deffn


@defun struct-type-descriptor? @var{obj}
Return @true{} if @var{obj} is a Vicare struct type descriptor,
otherwise return @false{}.  This predicate returns @false{} when applied
to @rnrs{6} record type descriptors.
@end defun


@defun struct-type-name @var{rtd}
Return a string represnting the name of structures of type @var{rtd}.
@end defun


@defun struct-type-symbol @var{rtd}
Return a symbol uniquely identifying the data structure type @var{rtd}.
@end defun


@defun struct-type-field-names @var{rtd}
Return a list of symbols representing the names of fields in structures
of type @var{rtd}.
@end defun


@defun struct-type-destructor @var{rtd}
Return @false{} or a procedure being the destructor for instances of
@var{rtd}.  The destructor is registered in a structure type descriptor
with @func{set-rtd-destructor!}.
@end defun

@c ------------------------------------------------------------

@defun set-rtd-printer! @var{rtd} @var{printer}
Select the procedure @var{printer} as printer for data structures of
type @var{rtd}; return unspecified values.  The printer accepts @math{3}
arguments: the structure to be printed, the port to which write a string
represention of the structure with @func{display}, a function to be
optionally applied to the field values to print them.
@end defun


@defun default-struct-printer @var{stru}
The default struct printer function; the string produced by this printer
is configured with the parameter @func{default-struct-printer-details}.
It can be used as @var{printer} argument in calls to
@func{set-rtd-printer!}.
@end defun


@deffn Parameter default-struct-printer-details
When set to true: @func{default-struct-printer} will produce a detailed
description of the structure; otherwise only minimum informations are
included.  This parameter is inisialised to @false{}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Automatic finalisation of structures

@cindex Automatic finalisation of structures
@cindex Structures, automatic finalisation
@cindex Structures, destructors
@cindex Data structures, automatic finalisation
@cindex Data structures, destructors
@cindex Finalisation of data structures
@cindex Destructors for data structures

@defun set-rtd-destructor! @var{rtd} @var{destructor}
Select the procedure @var{destructor} as destructor for data structures
of type @var{rtd}; return unspecified values.  The destructor accepts a
single argument being the structure instance to finalise; the destructor
can return unspecified values.

After a destructor is registered in @var{rtd}: new instances of this
structure type are registered, upon creation, into an internal guardian,
@ref{iklib guardians} for details; whenever such structures are garbage
collected: the guardian applies @var{destructor} to them.

Exceptions raised by @var{destructor} are catched with @func{guard} and
discarded: destructor functions should take care of exceptions by
themselves.
@end defun


@deffn Parameter struct-guardian-logger
Select data structure destruction logging mode for debugging purposes.
When a structure is finalised by the garbage collector, using the
destructor registered in the @rtd{}:

@itemize
@item
If this parameter is set to @false{}: no additional actions are
performed.

@item
If this parameter is set to @true{}: the function
@func{struct-guardian-log} is used to log the operations to the textual
output port returned by @code{current-error-port}.

@item
If this parameter is set to a procedure: such procedure is used to log
the operations in a user selected way.
@end itemize

See the documentation of @func{struct-guardian-log} for the calling
protocol of the logger functions.
@end deffn


@defun struct-guardian-log @var{struct} @var{exception} @var{action}
Built in logger function to be used to log data structure finalisation
operations by the garbage collector.  @var{struct} is the structure to
be finalised; @var{exception} is @false{} or an object raised by the
structure destructor; @var{action} is one of the symbols:
@code{before-destruction}, @code{after-destruction}, @code{exception}.

When this function is used as value for the parameter
@func{struct-guardian-logger}:

@itemize
@item
The function is called whenever a data structure is registered for
destruction with @var{action} set to the symbol @code{registration} and
@var{exception} set to @false{}.

@item
The function is called just before the structure is finalised with
@var{action} set to the symbol @code{before-destruction} and
@var{exception} set to @false{}.

@item
The function is called right after the structure has been finalised with
@var{action} set to the symbol @code{after-destruction} and
@var{exception} set to @false{}.

@item
If an exception is raised by the destructor: such exception is catched
and this function is called with @var{action} set to @code{exception}
and @var{exception} set to the raised object.
@end itemize

The current implementation is the following:

@smallexample
(define (struct-guardian-log S E action)
  (case action
    ((registration)
     (fprintf (current-error-port)
              "*** Vicare debug: struct guardian: registered struct:\n\
               ***\t~s\n" S))
    ((before-destruction)
     (fprintf (current-error-port)
       "*** Vicare debug: struct guardian: before destruction:\n\
        ***\t~s\n" S))
    ((after-destruction)
     (fprintf (current-error-port)
       "*** Vicare debug: struct guardian: after destruction:\n\
        ***\t~s\n" S))
    ((exception)
     (fprintf (current-error-port)
       "*** Vicare debug: struct guardian: exception:\n\
        ***\t~s\n\
        ***\t~s\n" S E))
    (else
     (assertion-violation 'struct-guardian-log
       "invalid action in struct destruction process" S action))))
@end smallexample
@end defun

@c page
@node iklib structs using
@subsection Using data structures


The following bindings are exported by the library @library{vicare}.


@defun struct-constructor @var{rtd}
Return a constructor function for data structures of type @var{rtd}.
The constructor accepts as many arguments as fields defined by @var{rtd}
and returns a new structure instance.
@end defun


@defun struct-predicate @var{rtd}
Return a predicate function for structures of type @var{rtd}.
@end defun


@defun struct-field-accessor @var{rtd} @var{index/name}
@defunx struct-field-mutator @var{rtd} @var{index/name}
Return an accessor or mutator function for the field at @var{index/name}
of data structures of type @var{rtd}.  @var{index/name} can be a field
index or a symbol representing a field name.

@example
(define-struct color
  (red green blue))

(define stru
  (make-color 1 2 3))

((struct-field-accessor (type-descriptor color) 'red)
 stru)
@result{} 1

((struct-field-accessor (type-descriptor color) 0)
 stru)
@result{} 1
@end example
@end defun

@c page
@node iklib structs inspect
@subsection Inspecting data structures


The following bindings are exported by the library @library{vicare}.


@defun struct? @var{stru}
@defunx struct? @var{stru} @var{rtd}
When no @var{rtd} argument is given: return true if @var{stru} is a data
structure.  When @var{rtd} is given: return true if @var{stru} is a data
structure and it is of type @var{rtd}, which must be a struct type
descriptor.
@end defun


@defun struct-rtd @var{stru}
Return the @var{rtd} of the data structure @var{stru}.  Notice that this
function works with both Vicare's structs and @rnrs{6} records.
@end defun


@defun struct-length @var{stru}
Return the number of fields in the data structure @var{stru}.  Notice
that this function works with both Vicare's structs and @rnrs{6}
records.
@end defun


@defun struct-name @var{stru}
Return a string representing the name of the data structure @var{stru}.
Notice that this function works with both Vicare's structs and @rnrs{6}
records.
@end defun


@defun struct-printer @var{stru}
Return the procedure being the printer function for the data structure
@var{stru}.
@end defun


@defun struct-ref @var{stru} @var{index}
Return the value of field at @var{index} in the data structure
@var{stru}.
@end defun


@defun struct-set! @var{stru} @var{index} @var{value}
Store @var{value} in the field at @var{index} in the data structure
@var{stru}.
@end defun


@defun struct=? @vari{obj} @varii{obj}
Return true if @vari{obj} and @varii{obj} are two structures having the
same @rtd{} and equal field values according to @func{eqv?}.
@end defun


@defun struct-reset @var{stru}
Reset to void all the fields of a structure.
@end defun

@c page
@node iklib structs fields
@subsection Accessing and mutating fields


@deffn Syntax struct-type-field-ref @meta{type-name} @meta{field-name} @meta{stru}
@deffnx Syntax struct-type-field-set! @meta{type-name} @meta{field-name} @meta{stru} @meta{new-value}
Expand to an expression which accesses or mutates the field whose name
is @meta{field-name} in the struct @meta{stru} of type @meta{type-name}.
These syntaxes allow access to the fields of a struct through the type
name identifier, without the need to export accessor and mutator
identifiers out of libraries.
@end deffn


@deffn Syntax $struct-type-field-ref @meta{type-name} @meta{field-name} @meta{stru}
@deffnx Syntax $struct-type-field-set! @meta{type-name} @meta{field-name} @meta{stru} @meta{new-value}
Expand to an unsafe expression which accesses or mutates the field whose
name is @meta{field-name} in the struct @meta{stru} of type
@meta{type-name}.  These syntaxes allow unsafe access to the fields of a
struct through the type name identifier, without the need to export
unsafe accessor and mutator identifiers out of libraries.
@end deffn

@c page
@node iklib records
@section Extensions to @rnrs{6} records


@menu
* iklib records definitions::   Defining record types.
* iklib records predicates::    Record predicates.
* iklib records fields::        Accessing and mutating fields.
* iklib records final::         Automatic finalisation of records.
* iklib records misc::          Miscellaneous functions.
@end menu

@c page
@node iklib records definitions
@subsection Defining record types


@deffn Syntax define-record-type @meta{name-spec} @meta{record-clause} @dots{}
Defined by @rnrs{6}.  Define a new @rnrs{6} record type; @ref{stdlib
records syntactic layer, define-record-type}.

Additionally, as Vicare extension, when the identifier representing the
record type name is used in macro keyword position with the syntax:

@example
(@meta{name} (@meta{expr} ...))
@end example

@noindent
the form is expanded to the application of the default constructor to
the results of evaluating the @meta{expr} arguments:

@example
(define-record-type color
  (fields red green blue))

(color (1 2 3))
@result{} #[r6rs-record: color red=1 green=2 blue=3]
@end example
@end deffn

@c page
@node iklib records predicates
@subsection Record predicates


@defun record-and-rtd? @var{record} @var{rtd}
Return @true{} if @var{record} is a record instance of @var{rtd} or a
record instance of a subtype of @var{rtd}; otherwise return @false{}.
@end defun


@deffn Syntax record-type-and-record? @meta{type-name} @meta{record}
Return @true{} if @meta{record} is an expression evaluating to a record
instance of type @meta{type-name} or a record instance of a subtype of
@meta{type-name}; otherwise return @false{}.  This syntax allows to test
the type of a record instance through the type name identifier, without
the need to export the predicate identifier out of libraries.
@end deffn

@c page
@node iklib records fields
@subsection Accessing and mutating fields


@defun record-accessor @var{rtd} @var{index/name}
@defunx record-accessor @var{rtd} @var{index/name} @var{accessor-who}
As defined by @rnrs{6}, this function accepts only two arguments and the
second is a relative field index; @ref{stdlib records procedural layer,
record-accessor}.  @value{PRJNAME} extends this function.

The argument @var{index/name} can be either a relative field index, as
specified by @rnrs{6}, or a symbol representing a field name.  In the
second case @var{rtd} and its parents are searched for the first
matching field specification, so fields of the sub--types take
precedence.

The optional third argument @var{accessor-who} must be a symbol
representing the name of the returned accessor function; it is used for
descriptive error reporting.

Here is an example with the field name argument being a symbol:

@example
(import (vicare))
(define-record-type alpha
  (fields a b c))
(define alpha-rtd
  (record-type-descriptor alpha))
(define R
  (make-alpha 1 2 3))
((record-accessor alpha-rtd 'a) R)      @result{} 1
((record-accessor alpha-rtd 'b) R)      @result{} 2
((record-accessor alpha-rtd 'c) R)      @result{} 3
@end example

@noindent
and another example with record type inheritance; notice that both the
record types have a field named @samp{C} and the sub--type takes
precedence:

@example
(import (vicare))
(define-record-type alpha
  (fields a b C))
(define-record-type beta
  (parent alpha)
  (fields C d e))
(define beta-rtd
  (record-type-descriptor beta))
(define R
  (make-beta 1 2 3 4 5 6))
((record-accessor beta-rtd 'a) R)       @result{} 1
((record-accessor beta-rtd 'b) R)       @result{} 2
((record-accessor beta-rtd 'C) R)       @result{} 4
((record-accessor beta-rtd 'd) R)       @result{} 5
((record-accessor beta-rtd 'e) R)       @result{} 6
@end example
@end defun


@defun record-mutator @var{rtd} @var{index/name}
@defunx record-mutator @var{rtd} @var{index/name} @var{mutator-who}
As defined by @rnrs{6}, this function accepts only two arguments and the
second is a relative field index; @ref{stdlib records procedural layer,
record-mutator}.  @value{PRJNAME} extends this function.

The argument @var{index/name} can be either a relative field index, as
specified by @rnrs{6}, or a symbol representing a field name.  In the
second case @var{rtd} and its parents are searched for the first
matching field specification, so fields of the sub--types take
precedence.

The optional third argument @var{mutator-who} must be a symbol
representing the name of the returned mutator function; it is used for
descriptive error reporting.

Here is an example with the field name argument being a symbol:

@example
(import (vicare))
(define-record-type alpha
  (fields a b c))
(define alpha-rtd
  (record-type-descriptor alpha))
(define R
  (make-alpha 1 2 3))
((record-mutator alpha-rtd 'a) R 19)
((record-mutator alpha-rtd 'b) R 29)
((record-mutator alpha-rtd 'c) R 39)
((record-accessor alpha-rtd 'a) R)      @result{} 1
((record-accessor alpha-rtd 'b) R)      @result{} 2
((record-accessor alpha-rtd 'c) R)      @result{} 3
@end example

@noindent
and another example with record type inheritance; notice that both the
record types have a field named @samp{C} and the sub--type takes
precedence:

@example
(import (vicare))
(define-record-type alpha
  (fields a b C))
(define-record-type beta
  (parent alpha)
  (fields C d e))
(define beta-rtd
  (record-type-descriptor beta))
(define R
  (make-beta 1 2 3 4 5 6))
((record-mutator beta-rtd 'a) R 19)
((record-mutator beta-rtd 'b) R 29)
((record-mutator beta-rtd 'C) R 49)
((record-mutator beta-rtd 'd) R 59)
((record-mutator beta-rtd 'e) R 69)
((record-accessor beta-rtd 'a) R)       @result{} 19
((record-accessor beta-rtd 'b) R)       @result{} 29
((record-accessor beta-rtd 'C) R)       @result{} 49
((record-accessor beta-rtd 'd) R)       @result{} 59
((record-accessor beta-rtd 'e) R)       @result{} 69
@end example
@end defun


@defun unsafe-record-accessor @var{rtd} @var{index/name}
@defunx unsafe-record-accessor @var{rtd} @var{index/name} @var{accessor-who}
Like @func{record-accessor}, but return an unsafe field accessor that
will not validate its arguments.
@end defun


@defun unsafe-record-mutator @var{rtd} @var{index/name}
@defunx unsafe-record-mutator @var{rtd} @var{index/name} @var{mutator-who}
Like @func{record-mutator}, but return an unsafe field mutator that will
not validate its arguments.
@end defun


@deffn Syntax record-type-field-ref @meta{type-name} @meta{field-name} @meta{record}
@deffnx Syntax record-type-field-set! @meta{type-name} @meta{field-name} @meta{record} @meta{new-value}
Expand to an expression which accesses or mutates the field whose name
is @meta{field-name} in the record @meta{record} of type
@meta{type-name}.  These syntaxes allow access to the fields of a record
through the type name identifier, without the need to export accessor
and mutator identifiers out of libraries.

@example
(import (vicare))

(define-record-type alpha
  (field (mutable a)))

(define-record-type beta
  (parent alpha)
  (field (mutable b)))

(define A
  (make-alpha 1))

(define B
  (make-beta 1 11))

(record-type-field-ref  alpha a A)       @result{} 1
(record-type-field-set! alpha a A 2)
(record-type-field-ref  alpha a A)       @result{} 2

(record-type-field-ref  alpha a B)       @result{} 1
(record-type-field-set! alpha a B 2)
(record-type-field-ref  alpha a B)       @result{} 2

(record-type-field-ref  beta b B)        @result{} 11
(record-type-field-set! beta b B 22)
(record-type-field-ref  beta b B)        @result{} 22
@end example

If @meta{field-name} does not select a field of @meta{type-name}: the
parent record--types of @meta{type-name} are searched for the first
matching field.
@end deffn


@deffn Syntax $record-type-field-ref @meta{type-name} @meta{field-name} @meta{record}
@deffnx Syntax $record-type-field-set! @meta{type-name} @meta{field-name} @meta{record} @meta{new-value}
Expand to an unsafe expression which accesses or mutates the field whose
name is @meta{field-name} in the record @meta{record} of type
@meta{type-name}.  These syntaxes allow unsafe access to the fields of a
record through the type name identifier, without the need to export
unsafe accessor and mutator identifiers out of libraries.

These syntaxes are usable only when the @func{define-record-type} syntax
used to define @meta{type-name} has been expanded in extended Vicare
mode; if @value{EXECUTABLE} was run with the option
@option{--strict-r6rs} use of these syntaxes raises a syntax violation
exception.

@example
(import (vicare))

(define-record-type alpha
  (field (mutable a)))

(define A
  (make-alpha 1))

($record-type-field-ref  alpha a A)      @result{} 1
($record-type-field-set! alpha a A 2)
($record-type-field-ref  alpha a A)      @result{} 2
@end example

If @meta{field-name} does not select a field of @meta{type-name}: the
parent record--types of @meta{type-name} are searched for the first
matching field.
@end deffn

@c page
@node iklib records final
@subsection Automatic finalisation of records


@cindex Automatic finalisation of records
@cindex Records, automatic finalisation
@cindex Records, destructors
@cindex Data records, automatic finalisation
@cindex Data records, destructors
@cindex Finalisation of data records
@cindex Destructors for data records


It is possible to automatically apply a destructor function whenever an
@rnrs{6} record is reclaimed by the garbage collector.

@example
#!r6rs
(import (vicare))

(define-record-type <alpha>
  (fields a b c))

(record-destructor-set! (record-type-descriptor <alpha>)
                        (lambda (S)
                          (pretty-print (list 'finalising S)
                                        (current-error-port))))

(pretty-print (make-<alpha> 1 2 3) (current-error-port))
@print{} #[r6rs-record: <alpha> a=1 b=2 c=3]

(collect)
@print{} (finalising #[r6rs-record: <alpha> a=1 b=2 c=3])
@end example

The following bindings are exported by the library @library{vicare}.


@defun record-destructor-set! @var{rtd} @var{destructor}
Select the procedure @var{destructor} as destructor for @rnrs{6} record
instances of type @var{rtd}; return unspecified values.  The destructor
accepts a single argument being the record instance to finalise; the
destructor can return unspecified values.

After a destructor is registered in @var{rtd}: new instances of this
record type are registered, upon creation, into an internal guardian,
@ref{iklib guardians} for details; whenever such records are garbage
collected: the guardian applies @var{destructor} to them.

Exceptions raised by @var{destructor} are catched with @func{guard} and
discarded: destructor functions should take care of exceptions by
themselves.
@end defun


@defun record-destructor @var{rtd}
Return the current destructor for @var{rtd}: @false{} or a function.
@end defun


@deffn Parameter record-guardian-logger
Select record instance destruction logging mode for debugging purposes.
When a record is finalised by the garbage collector, using the
destructor registered in the @rtd{}:

@itemize
@item
If this parameter is set to @false{}: no additional actions are
performed.

@item
If this parameter is set to @true{}: the function
@func{record-guardian-log} is used to log the operations to the textual
output port returned by @code{current-error-port}.

@item
If this parameter is set to a procedure: such procedure is used to log
the operations in a user selected way.
@end itemize

See the documentation of @func{record-guardian-log} for the calling
protocol of the logger functions.
@end deffn


@defun record-guardian-log @var{record} @var{exception} @var{action}
Built in logger function to be used to log record instance finalisation
operations by the garbage collector.  @var{record} is the record to be
finalised; @var{exception} is @false{} or an object raised by the record
destructor; @var{action} is one of the symbols:
@code{before-destruction}, @code{after-destruction}, @code{exception}.

When this function is used as value for the parameter
@func{record-guardian-logger}:

@itemize
@item
The function is called whenever a record is registered for destruction
with @var{action} set to the symbol @code{registration} and
@var{exception} set to @false{}.

@item
The function is called just before the record is finalised with
@var{action} set to the symbol @code{before-destruction} and
@var{exception} set to @false{}.

@item
The function is called right after the record has been finalised with
@var{action} set to the symbol @code{after-destruction} and
@var{exception} set to @false{}.

@item
If an exception is raised by the destructor: such exception is catched
and this function is called with @var{action} set to @code{exception}
and @var{exception} set to the raised object.
@end itemize

The current implementation is the following:

@smallexample
(define (record-guardian-log S E action)
  (case action
    ((registration)
     (fprintf (current-error-port)
       "*** Vicare debug: record guardian: registered record:\n\
        ***\t~s\n" S))
    ((before-destruction)
     (fprintf (current-error-port)
       "*** Vicare debug: record guardian: before destruction:\n\
        ***\t~s\n" S))
    ((after-destruction)
     (fprintf (current-error-port)
       "*** Vicare debug: record guardian: after destruction:\n\
        ***\t~s\n" S))
    ((exception)
     (fprintf (current-error-port)
       "*** Vicare debug: record guardian: exception:\n\
        ***\t~s\n\
        ***\t~s\n" S E))
    (else
     (assertion-violation 'record-guardian-log
       "invalid action in record destruction process" S action))))
@end smallexample
@end defun

@c page
@node iklib records misc
@subsection Miscellaneous functions


The following bindings are exported by the library @library{vicare}.


@defun record-reset @var{record}
Reset to void all the fields of a record, whatever its type.
@end defun

@c page
@node iklib promises
@section Delay, force and promises


The following bindings are exported by the library @library{vicare}.


@defun promise? @var{obj}
Return @true{} if @var{obj} is a promise object returned by
@func{delay}, else return @false{}.
@end defun

@c page
@node iklib characters
@section Additional character functions


The following bindings are exported by the library @library{vicare}.


@defun char-in-ascii-range? @var{obj}
Evaluate to @true{} if @meta{obj} is a character and its Unicode code
point is in the range @math{[0, 127]}.
@end defun


@defun fixnum-in-character-range? @var{obj}
Return @true{} if @var{obj} is a fixnum and its value is in one of the
ranges acceptable by Unicode code points; otherwise return @false{}.
@end defun

@c page
@node iklib keywords
@section Keyword objects


Keyword objects are struct instances embedding a Scheme symbol; keyword
objects are a disjoint type; keyword objects are @strong{not} interned.

Keyword objects can be compared with @func{eq?}, @func{eqv?} and
@func{equal?}; a keyword object is @func{eq?} only to itself.  Keyword
objects can also be compared with the @func{keyword=?} predicate which
is faster than @func{eqv?} and @func{equal?} and slower than @func{eq?}
for symbols.

The reader supports a special syntax to read keyword objects, @ref{iklib
reader stx, Miscellaneous additional syntaxes}.

The following bindings are exported by the library @library{vicare}.


@defun symbol->keyword @var{symbol}
@defunx keyword->symbol @var{keyword}
Convert between a symbol and a keyword.
@end defun


@defun keyword->string @var{keyword}
Return the string representation of a keyword.
@end defun


@defun keyword? @var{obj}
Return @true{} if @var{obj} is a keyword object, else return @false{}.
@end defun


@defun keyword=? @vari{keyword} @varii{keyword}
The arguments @vari{keyword} and @varii{keyword} must be keyword
objects, otherwise an exception is raised.  Return @true{} if the
arguments are equal.  A keyword object is equal to itself; two distinct
keyword objects are equal if they have the same symbol.
@end defun


@defun keyword-hash @var{keyword}
Return an exact integer suitable to be used as hash value for
@var{keyword} used as key for hashtables.
@end defun

@c page
@node iklib lists
@section Additional list functions


@menu
* iklib lists weak::            Weak pairs.
* iklib lists queue::           Queues of items.
* iklib lists misc::            Miscellaneous functions.
@end menu

@c page
@node iklib lists weak
@subsection Weak pairs


Weak references do not cause the referenced value to be considered used
by the garbage collector.  The following bindings are exported by the
library @library{vicare}.


@defun weak-cons @var{A} @var{D}
Like @func{cons} build and return a new pair, but holding weak
references to @var{A}; notice that the reference to @var{D} is not weak.
This function allows to build a non--weak list spine holding weak
references to values.
@end defun


@defun weak-pair? @var{obj}
Return true if @var{obj} is a weak pair.
@end defun


@defun bwp-object
Return the @acronym{BWP} object.  @acronym{BWP} stands for ``broken weak
pointer''.
@end defun


@defun bwp-object? @var{obj}
Return true if @var{obj} is a weak reference to a value which has been
already garbage collected.  Example:

@example
vicare> (define x (weak-cons (cons 1 2) #f))
vicare> x
((1 . 2) . #f)
vicare> (bwp-object? (car x))
#f
vicare> (collect)
vicare> x
 (#!bwp . #f)
vicare> (bwp-object? (car x))
#t
@end example
@end defun

@c page
@node iklib lists queue
@subsection Queues of items


Queues are object containers that allow constructing a first-in
first-out sequence.  The following bindings are exported by the library
@library{vicare}.


@defun make-queue-procs
@defunx make-queue-procs @var{init-values}
Build a queue of items and return @math{3} values:

@enumerate
@item
A predicate thunk returning @true{} if the queue is empty.

@item
A function which, applied to a single argument, enqueues it as last
item.

@item
A thunk extracting and returning the first item from the queue.  If the
queue is empty an error is raised.
@end enumerate

The optional @var{init-values} must be null or the list of initial
values.

Usage examples:

@example
#!r6rs
(import (vicare))

(let-values (((empty? enqueue! dequeue!)
              (make-queue-procs)))
  (empty?))
@result{} #t

(let-values (((empty? enqueue! dequeue!)
              (make-queue-procs)))
  (enqueue! 1)
  (empty?))
@result{} #f

(let-values (((empty? enqueue! dequeue!)
              (make-queue-procs)))
  (enqueue! 1)
  (empty?)      @result{} #f
  (dequeue!)    @result{} 1
  (empty?))
@result{} #t

(let-values (((empty? enqueue! dequeue!)
              (make-queue-procs)))
  (enqueue! 1)
  (enqueue! 2)
  (enqueue! 3)
  (dequeue!)    @result{} 1
  (dequeue!)    @result{} 2
  (dequeue!)    @result{} 3
  (empty?))
@result{} #t
@end example
@end defun

@c page
@node iklib lists misc
@subsection Miscellaneous functions


The following bindings are exported by the library @library{vicare}.


@defun make-list @var{len}
@defunx make-list @var{len} @var{fill}
Build and return a new list of @var{len} elements.  @var{fill} is used
to initialise the the list pairs; when not given: it defaults to the
return value of @code{(void)}.
@end defun


@defun last-pair @var{pair}
Return the last pair in the non--empty, finite list @var{pair}.

@example
(last-pair '(a b c))    @result{} (c)
@end example
@end defun


@defun for-each-in-order @var{proc} @varo{list} @var{list} ...
Like @func{for-each} from @rsixlibrary{base} but guarantees that
@var{proc} is applied starting from the head of the lists.
@end defun


@defun map1 @var{proc} @var{ell}
Like @func{map} from @rsixlibrary{lists} for a single list argument, but
it is meant to be faster.  It does not check for circular list; it
processes the input list from head to tail (in order).
@end defun


@defun for-each1 @var{proc} @var{ell}
Like @func{for-each} from @rsixlibrary{lists} for a single list
argument, but it is meant to be faster.  It does not check for circular
list; it processes the input list from head to tail (in order).
@end defun


@defun for-all1 @var{proc} @var{ell}
Like @func{for-all} from @rsixlibrary{lists} for a single list argument,
but it is meant to be faster.  It does not check for circular list; it
processes the input list from head to tail (in order).
@end defun


@defun exists1 @var{proc} @var{ell}
Like @func{exists} from @rsixlibrary{lists} for a single list argument,
but it is meant to be faster.  It does not check for circular list; it
processes the input list from head to tail (in order).
@end defun

@c page
@node iklib bytevectors
@section Additional bytevector functions


The description of bytevectors uses the term @emph{byte} for an exact
integer object in the inclusive interval @math{(-128, @dots{}, 127)} and
the term @emph{octet} for an exact integer object in the inclusive
interval @math{(0, @dots{}, 255)}.  A byte corresponds to its two's
complement representation as an octet.

@menu
* iklib bytevectors sub::       Building subbytevectors.
* iklib bytevectors conv::      Converting bytevectors.
* iklib bytevectors valpred::   Validation predicates for bytevector.
* iklib bytevectors generic::   Generic bytevector operations.
@end menu

@c page
@node iklib bytevectors sub
@subsection Building subbytevectors


The following bindings are exported by the library @library{vicare}.


@defun subbytevector-u8 @var{bv} @var{start}
@defunx subbytevector-u8 @var{bv} @var{start} @var{end}
Build and return a new bytevector holding the bytes in @var{bv} from
index @var{start} (inclusive) to index @var{end} (exclusive).  The start
and end indexes must be such that:

@example
0 <= @var{start} <= @var{end} <= (bytevector-length @var{bv})
@end example
@end defun


@defun subbytevector-u8/count @var{bv} @var{start} @var{count}
Build and return a new bytevector holding @var{count} bytes in @var{bv}
from index @var{start} (inclusive).  The start index and the byte count
must be such that:

@example
0 <= @var{start} <= @var{start} + @var{count} <= (bytevector-length @var{bv})
@end example
@end defun


@defun subbytevector-s8 @var{bv} @var{start}
@defunx subbytevector-s8 @var{bv} @var{start} @var{end}
Build and return a new bytevector holding the bytes in @var{bv} from
index @var{start} (inclusive) to index @var{end} (exclusive).  The start
and end indexes must be such that:

@example
0 <= @var{start} <= @var{end} <= (bytevector-length @var{bv})
@end example
@end defun


@defun subbytevector-s8/count @var{bv} @var{start} @var{count}
Build and return a new bytevector holding @var{count} bytes in @var{bv}
from index @var{start} (inclusive).  The start index and the byte count
must be such that:

@example
0 <= @var{start} <= @var{start} + @var{count} <= (bytevector-length @var{bv})
@end example
@end defun

@c page
@node iklib bytevectors conv
@subsection Converting bytevectors


These conversion functions work like @func{bytevector->u8-list} and
@func{u8-list->bytevector}.  The following bindings are exported by the
library @library{vicare}.


@defun {bytevector->s8-list} @var{bytevector}
@defunx {s8-list->bytevector} @var{list}
Convert between a list of signed bytes and a bytevector.
@end defun


@defun s16l-list->bytevector @var{list}
@defunx s16b-list->bytevector @var{list}
@defunx s16n-list->bytevector @var{list}
@defunx u16l-list->bytevector @var{list}
@defunx u16b-list->bytevector @var{list}
@defunx u16n-list->bytevector @var{list}
@defunx bytevector->s16l-list @var{bytevector}
@defunx bytevector->s16b-list @var{bytevector}
@defunx bytevector->s16n-list @var{bytevector}
@defunx bytevector->u16l-list @var{bytevector}
@defunx bytevector->u16b-list @var{bytevector}
@defunx bytevector->u16n-list @var{bytevector}
Convert between a list of signed or unsigned 16-bit words and a
bytevector in which the words are stored in little, big or native
endianness.
@end defun


@defun s32l-list->bytevector @var{list}
@defunx s32b-list->bytevector @var{list}
@defunx s32n-list->bytevector @var{list}
@defunx u32l-list->bytevector @var{list}
@defunx u32b-list->bytevector @var{list}
@defunx u32n-list->bytevector @var{list}
@defunx bytevector->s32l-list @var{bytevector}
@defunx bytevector->s32b-list @var{bytevector}
@defunx bytevector->s32n-list @var{bytevector}
@defunx bytevector->u32l-list @var{bytevector}
@defunx bytevector->u32b-list @var{bytevector}
@defunx bytevector->u32n-list @var{bytevector}
Convert between a list of signed or unsigned 32-bit words and a
bytevector in which the words are stored in little, big or native
endianness.
@end defun


@defun s64l-list->bytevector @var{list}
@defunx s64b-list->bytevector @var{list}
@defunx s64n-list->bytevector @var{list}
@defunx u64l-list->bytevector @var{list}
@defunx u64b-list->bytevector @var{list}
@defunx u64n-list->bytevector @var{list}
@defunx bytevector->s64l-list @var{bytevector}
@defunx bytevector->s64b-list @var{bytevector}
@defunx bytevector->s64n-list @var{bytevector}
@defunx bytevector->u64l-list @var{bytevector}
@defunx bytevector->u64b-list @var{bytevector}
@defunx bytevector->u64n-list @var{bytevector}
Convert between a list of signed or unsigned 64-bit words and a
bytevector in which the words are stored in little, big or native
endianness.
@end defun


@defun f4l-list->bytevector @var{list}
@defunx f4b-list->bytevector @var{list}
@defunx f4n-list->bytevector @var{list}
@defunx bytevector->f4l-list @var{bytevector}
@defunx bytevector->f4b-list @var{bytevector}
@defunx bytevector->f4n-list @var{bytevector}
Convert between a list of single--precision flonums and a bytevector in
which the flonums are stored in little, big or native endianness.
@end defun


@defun f8l-list->bytevector @var{list}
@defunx f8b-list->bytevector @var{list}
@defunx f8n-list->bytevector @var{list}
@defunx bytevector->f8l-list @var{bytevector}
@defunx bytevector->f8b-list @var{bytevector}
@defunx bytevector->f8n-list @var{bytevector}
Convert between a list of double--precision flonums and a bytevector in
which the flonums are stored in little, big or native endianness.
@end defun


@defun c4l-list->bytevector @var{list}
@defunx c4b-list->bytevector @var{list}
@defunx c4n-list->bytevector @var{list}
@defunx bytevector->c4l-list @var{bytevector}
@defunx bytevector->c4b-list @var{bytevector}
@defunx bytevector->c4n-list @var{bytevector}
Convert between a list of single--precision cflonums and a bytevector in
which the cflonums are stored in little, big or native endianness, real
part first.
@end defun


@defun c8l-list->bytevector @var{list}
@defunx c8b-list->bytevector @var{list}
@defunx c8n-list->bytevector @var{list}
@defunx bytevector->c8l-list @var{bytevector}
@defunx bytevector->c8b-list @var{bytevector}
@defunx bytevector->c8n-list @var{bytevector}
Convert between a list of double--precision cflonums and a bytevector in
which the flonums are stored in little, big or native endianness, real
part first.
@end defun


@defun octets-encoded-bytevector? @var{bytevector}
Return @true{} if @var{bytevector} is a bytevector object.
@end defun


@defun ascii-encoded-bytevector? @var{bytevector}
Return @true{} if @var{bytevector} can be interpreted as an @ascii{}
encoded string, otherwise return @false{}.  An octet @var{chi} is
considered an @ascii{} code point if:

@example
(<= #x00 chi #x7F)      @result{} #t
@end example
@end defun


@defun latin1-encoded-bytevector? @var{bytevector}
Return @true{} if @var{bytevector} can be interpreted as a Latin1
encoded string, otherwise return @false{}.  An octet @var{chi} is
considered a Latin1 code point if:

@example
(or (<= #x00 chi #x1F)
    (<= #x20 chi #x7E)
    (<= #xA0 chi #xFF))
@result{} #t
@end example
@end defun


@defun hex->bytevector @var{bytevector}
@defunx bytevector->hex @var{bytevector}
Convert to and from a Scheme bytevector containing octets and a Scheme
bytevector containing the @ascii{} hexadecimal representation of the
octets.

The input hex bytevector contains the uppercase or lowercase hexadecimal
representation of the octets.  The output hex bytevector contains the
uppercase hexadecimal representation of octets.

If an error occurs in the conversion: the return value is @false{}.
@end defun


@defun base64->bytevector @var{bytevector}
@defunx bytevector->base64 @var{bytevector}
Convert to and from a Scheme bytevector containing octets and a Scheme
bytevector containing the @ascii{} Base64 representation of the octets.

If an error occurs in the conversion: the return value is @false{}.
@end defun


@defun uri-encode @var{bytevector}
@defunx uri-decode @var{bytevector}
@defunx percent-encode @var{bytevector}
@defunx percent-decode @var{bytevector}
Encode or decode a bytevector according to @rfc{} 3986 @acronym{URI}
percent encoding; return a bytevector.  All the octets are encoded
except the ones having the following @ascii{} representation:

@example
ABCDEFGHIJKLMNOPQRSTUVWXYZ
abcdefghijklmnopqrstuvwxyz
0123456789
-._~
@end example
@end defun


@defun normalise-uri-encoding @var{bytevector}
@defunx normalise-percent-encoding @var{bytevector}
Given a bytevector encoded according to to @rfc{} 3986 @acronym{URI}
percent encoding: return an encoded and normalised bytevector, octets
that are encoded but should not are decoded.
@end defun


@defun uri-encoded-bytevector? @var{bv}
@defunx percent-encoded-bytevector? @var{bv}
Return @true{} if the argument is a correctly percent--encoded
bytevector according to @rfc{} 3986.  This means every octet represents
either one of the following characters in @ascii{} encoding:

@example
ABCDEFGHIJKLMNOPQRSTUVWXYZ
abcdefghijklmnopqrstuvwxyz
0123456789
-._~
@end example

@noindent
or it is part of a percent--encoded sequence defined by the following
grammar:

@example
pct-encoded   = "%" HEXDIG HEXDIG
HEXDIG        = [0-9a-fA-F]
@end example
@end defun

@c page
@node iklib bytevectors valpred
@subsection Validation predicates for bytevector


@defun list-of-bytevectors? @var{obj}
Return @true{} if OBJ is null or a proper list of bytevectors; otherwise
return @false{}.
@end defun


@defun bytevector-length? @var{obj}
Return @true{} if @var{obj} is valid as bytevector length: it is a
non--negative fixnum; otherwise return @false{}.
@end defun


@defun bytevector-index? @var{obj}
Return @true{} if @var{obj} is a Scheme object valid as bytevector
index: it is a non--negative fixnum; otherwise return @false{}.  Before
being used, @var{obj} needs further validation against a specific
bytevector and word size.
@end defun


@defun bytevector-word-size? @var{obj}
Return @true{} if @var{obj} is valid as word size to be accessed in a
bytevector; otherwise return @false{}.  @var{obj} must be further
validated for a specific bytevector word start offset.
@end defun


@defun bytevector-word-count? @var{obj}
Return @true{} if @var{obj} is valid as word count for bytevector items,
either a byte count, 16-bit words count, 32-bit words count, @dots{};
otherwise return @false{}.  @var{obj} must be further validated for the
specific bytevector and word size with which it is to be used.
@end defun


@defun bytevector-index-for-word? @var{bv} @var{idx} @var{word-size-in-bytes}
Return @true{} if: @var{bv} is a bytevector, @var{idx} is a
non--negative fixnum, @var{word-size-in-bytes} is a non--negative
fixnum, @var{idx} is a valid index in @var{bv} to reference a word whose
size is @var{word-size-in-bytes}; otherwise return @false{}.  This
validation is for getter and setter indexes.
@end defun


@defun bytevector-index-for-word8? @var{bv} @var{idx}
@defunx bytevector-index-for-word16? @var{bv} @var{idx}
@defunx bytevector-index-for-word32? @var{bv} @var{idx}
@defunx bytevector-index-for-word64? @var{bv} @var{idx}
Specialised variants of @func{bytevector-index-for-word?} for a specific
word size in bits.
@end defun


@defun bytevector-start-index-and-count-for-word? @var{bv} @var{idx} @var{word-size-in-bytes} @var{count}
Return @true{} if: @var{bv} is a bytevector, @var{idx} is a
non--negative fixnum, @var{count} is a non--negative fixnum,
@var{word-size-in-bytes} is a non--negative fixnum, @var{idx} is a valid
index in @var{bv} to reference @var{count} words whose size is
@var{word-size-in-bytes}; otherwise return @false{}.  Notice that if
@var{count} is zero: it is fine for @var{idx} to be equal to the length
of @var{bv}.  This validation is for getter and setter indexes.
@end defun


@defun bytevector-start-index-and-count-for-word8? @var{bv} @var{idx}
@defunx bytevector-start-index-and-count-for-word16? @var{bv} @var{idx}
@defunx bytevector-start-index-and-count-for-word32? @var{bv} @var{idx}
@defunx bytevector-start-index-and-count-for-word64? @var{bv} @var{idx}
Specialised variants of
@func{bytevector-start-index-and-count-for-word?} for a specific word
size in bits.
@end defun

@c page
@node iklib bytevectors generic
@subsection Generic bytevector operations


The following bindings are exported by the library @library{vicare}.


@defun bytevector-empty? @var{bytevector}
Return @true{} if the bytevector @var{bytevector} has zero length,
otherwise return @false{}.
@end defun


@defun bytevector-append @var{bytevector} ...
Concatenate the bytevector arguments and return the result.  If no
arguments are given: return the empty bytevector.
@end defun


@defun bytevector-reverse-and-concatenate @var{bvs}
Reverse the list of bytevectors @var{bvs}, concatenate them and return
the resulting bytevector.  It is an error if the sum of the bytevector
lengths is not in the range of the maximum bytevector length.
@end defun


@defun bytevector-hash @var{bytevector}
Return an integer hash value for @var{bytevector}, based on its current
contents.  This hash function is suitable for use with
@func{bytevector=?} as an equivalence function.
@end defun

@c page
@node iklib strings
@section Additional string functions


The following bindings are exported by the library @library{vicare}.


@defun string-empty? @var{str}
Return @true{} if the string @var{str} is empty, otherwise return
@false{}.
@end defun


@defun string-copy! @var{src.str} @var{src.start} @var{dst.str} @var{dst.start} @var{count}
Copy @var{count} characters from @var{src.str} starting at
@var{src.start} (inclusive) to @var{dst.str} starting at
@var{dst.start}.  Return unspecified values.
@end defun


@defun string-reverse-and-concatenate @var{strs}
Reverse the list of strings @var{strs}, concatenate them and return the
resulting string.  It is an error if the sum of the string lengths is
not in the range of the maximum string length.
@end defun


@defun string->octets @var{string}
@defunx octets->string @var{bytevector}
Convert to and from a Scheme string and a Scheme bytevector holding the
raw octets encoding of the characters.  Octets are converted to
characters with @func{integer->char}; characters are converted to octets
with @func{char->integer}.  Raise an exception if the conversion is not
possible.
@end defun


@defun string->ascii @var{string}
@defunx ascii->string @var{bytevevctor}
Convert to and from a Scheme string and a Scheme bytevector holding the
@ascii{} encoding of the characters.
@end defun


@defun octets-encoded-string? @var{string}
Return @true{} if @var{string} can be interpreted as an octets encoded
string, otherwise return @false{}.  A character is considered an
octets--encoded if its integer representation @var{chi} satisfies:

@example
(<= 0 @var{chi} 255)      @result{} #t
@end example
@end defun


@defun ascii-encoded-string? @var{string}
Return @true{} if @var{string} can be interpreted as an @ascii{} encoded
string, otherwise return @false{}.  A character is considered an
@ascii{} code point if its integer representation @var{chi} satisfies:

@example
(<= #x00 @var{chi} #x7F)      @result{} #t
@end example
@end defun


@defun string->latin1 @var{string}
@defunx latin1->string @var{bytevevctor}
Convert to and from a Scheme string and a Scheme bytevector holding the
Latin-1 encoding of the characters.
@end defun


@defun latin1-encoded-string? @var{string}
Return @true{} if @var{string} can be interpreted as a Latin1 encoded
string, otherwise return @false{}.  A character in the string is
considered a Latin1 code point if its integer representation @var{chi}
satisfies:

@example
(or (<= #x00 @var{chi} #x1F)
    (<= #x20 @var{chi} #x7E)
    (<= #xA0 @var{chi} #xFF))
@result{} #t
@end example
@end defun


@defun string->utf16le @var{string}
@defunx string->utf16be @var{string}
@defunx string->utf16n @var{string}
@defunx utf16le->string @var{bytevector}
@defunx utf16be->string @var{bytevector}
@defunx utf16n->string @var{bytevector}
Convert to and from a Scheme string and a Scheme bytevector holding the
@utf{}-16 encoding of the characters under little, big or native
endianness respectively.
@end defun


@defun string-hex->bytevector @var{string}
@defunx bytevector->string-hex @var{bytevector}
Convert to and from a Scheme string and a Scheme bytevector.

The input string contains the uppercase or lowercase hexadecimal
representation of the octets.  The output string contains the uppercase
hexadecimal representation of octets.

If an error occurs in the conversion: the return value is @false{}.
@end defun


@defun string-base64->bytevector @var{string}
@defunx bytevector->string-base64 @var{bytevector}
Convert to and from a Scheme string and a Scheme bytevector.  The input
string contains the @ascii{} Base64 representation of the octets.  The
output string contains the @ascii{} Base64 representation of octets.  If
an error occurs in the conversion: an exception is raised.
@end defun


@defun uuid
Attempt to build a unique string and return it.  If an internal error
occurs because of impossible generation: raise an error.
@end defun


@defun string->uri-encoding @var{str}
@defunx string->percent-encoding @var{str}
Convert the string @var{str} to its @utf{}-8 representation, then encode
such representation according to @rfc{} 3986, @acronym{URI} percent
encoding.
@end defun


@defun uri-encoding->string @var{bytevector}
@defunx percent-encoding->string @var{bytevector}
Interpret the bytevector as encoded according to @rfc{} 3986,
@acronym{URI} percent encoding, decode it and interpret the result as
the @utf{}-8 representation of a string; return the string.
@end defun


@defun uri-encoded-string? @var{string}
@defunx percent-encoded-string? @var{string}
Return @true{} if the argument is correctly percent--encoded string
according to @rfc{} 3986.  This means every character in the string is
associated to a character in the @ascii{} encoding and additionally the
constraints of @rfc{} 3986 are satisfied.
@end defun


@defun string-or-symbol->string @var{obj}
If @var{obj} is a string return a copy of it; if it is a symbol return a
new string object equal to its string name.
@end defun


@defun string-or-symbol->symbol @var{obj}
If @var{obj} is a symbol return it; if it is a string return a symbol
having it as string name.
@end defun

@c page
@node iklib vectors
@section Additional vector functions


The following bindings are exported by the library @library{vicare}.


@defun subvector @var{vec} @var{start} @var{end}
@var{vec} must be a vector, and @var{start} and @var{end} must be exact
integer objects satisfying:

@example
0 <= @var{start} <= @var{end} <= (vector-length @var{vec})
@end example

Return a newly allocated vector formed from the items of @var{vec}
beginning with index @var{start} (inclusive) and ending with index
@var{end} (exclusive).
@end defun


@defun vector-empty? @var{vec}
Return @true{} if the vector @var{vec} has zero length, otherwise return
@false{}.
@end defun


@defun vector-append @var{vec} ...
Return a newly allocated vector whose items form the concatenation of
the given vectors.
@end defun


@defun vector-copy @var{vec}
Return a newly allocated copy of the given vector.  This is ``shallow''
copy, @strong{not} a ``deep'' copy: the returned vector holds the same
items of @var{vec}.
@end defun


@defun vector-copy! @var{src.vec} @var{src.start} @var{dst.vec} @var{dst.start} @var{count}
Copy @var{count} items from @var{src.vec} starting at @var{src.start}
(inclusive) to @var{dst.vec} starting at @var{dst.start}.  Return
unspecified values.
@end defun


@defun vector-resize @var{vec} @var{new-length}
@defunx vector-resize @var{vec} @var{new-length} @var{fill}
Return a new vector of length @var{new-length} whose first slots are
filled with the items from @var{vec} and whose last slots, if any left,
are filled with @var{fill}.  When not used: @var{fill} defaults to
@false{}.

@example
(vector-resize '#() 0)          @result{} #()
(vector-resize '#() 3)          @result{} #(#f #f #f)
(vector-resize '#(1 2 3) 5)     @result{} #(1 2 3 #f #f)
(vector-resize '#(1 2 3) 2)     @result{} #(1 2)
@end example
@end defun


@deffn Procedure vector-for-all @var{proc} @vari{vec} @varii{vec} @dots{} @varn{vec}
@deffnx Procedure vector-exists @var{proc} @vari{vec} @varii{vec} @dots{} @varn{vec}
The @var{vec}s should all have the same length, and @var{proc} should
accept @math{N} arguments and return a single value.  @var{proc} should
not mutate the @var{vec} arguments.

For natural numbers @math{i = 0, 1, @dots{}}, the @func{vector-for-all}
procedure successively applies @var{proc} to arguments @math{x_i^1
@dots{} x_i^N}, where @math{x_i^j} is the @math{i}-th element of
@var{vecj}, until @false{} is returned.

If @var{proc} returns true values for all but the last element of
@vari{vec}, @func{vector-for-all} performs a tail call of @var{proc} on
the @math{k}-th elements, where @math{k} is the length of @vari{vec}.
If @var{proc} returns @false{} on any set of elements,
@func{vector-for-all} returns @false{} after the first such application
of @var{proc}.  If the @var{vec}s are all empty, @func{vector-for-all}
returns @true{}.

For natural numbers @math{i = 0, 1, @dots{}}, the @func{vector-exists}
procedure applies @var{proc} successively to arguments @math{x_i^1
@dots{} x_i^n}, where @math{x_i^j} is the @math{i}-th element of
@var{vecj}, until a true value is returned.

If @var{proc} returns @false{} for all but the last elements of the
@var{vec}s, @func{vector-exists} performs a tail call of @var{proc} on
the @math{k}-th elements, where @math{k} is the length of @vari{vec}.
If @var{proc} returns a true value on any set of elements,
@func{vector-exists} returns that value after the first such application
of @var{proc}.  If the @var{vec}s are all empty, @func{vector-exists}
returns @false{}.

@var{proc} is always called in the same dynamic environment as
@func{vector-for-all} or, respectively, @func{vector-exists} itself.
@end deffn

@c page
@node iklib symbols
@section Additional symbol functions


@menu
* iklib symbols value::         Symbol values.
* iklib symbols plists::        Property lists.
* iklib symbols values::        System values bound to symbols.
* iklib symbols labels::        Retrieving syntactic binding labels.
* iklib symbols identifiers::   Retrieving syntactic binding identifiers.
@end menu

@c page
@node iklib symbols value
@subsection Symbol values


Under Vicare, Scheme symbols are data structures having a field
@code{value} initialised, at symbol construction time, to the built--in
value @samp{#<unbound-object>}; this field has multiple purposes:

@itemize
@item
When the symbol is the unique identifier of a data structure type:
@code{value} holds the @rtd{} of the data structure.

@item
When the symbol is a label gensym associated to a syntactic binding
exported by the boot image: @code{value} holds the syntactic binding
descriptor.

@item
When the symbol is a label gensym associated to a syntactic binding
imported in the current lexical environment: @code{value} holds the
syntactic binding descriptor.

@item
When the symbol is a storage location gensym associated to a lexical
syntactic binding: @code{value} holds the current value of the lexical
variable.

@item
When the symbol is a fresh symbol returned by a call to @func{gensym}:
we can use @code{value} for any purpose we want.
@end itemize

The following bindings are exported by the library @library{vicare}.


@defun set-symbol-value! @var{sym} @var{value}
Store @var{value} in the @code{value} field of the symbol @var{sym}.
@end defun


@defun symbol-value @var{sym}
Return the value in the @code{value} field of the symbol @var{sym}.
@end defun


@defun symbol-bound? @var{sym}
Return true if @var{sym} is a symbol and its @code{value} field is
@strong{not} set to the built--in @samp{#<unbound-object>} machine word
value.
@end defun


@defun unbound-object
Return the unbound object.
@end defun


@defun unbound-object? @var{obj}
Return @true{} if @var{obj} is the unbound object.
@end defun

@c page
@node iklib symbols plists
@subsection Property lists


Property lists are key/value associations that can be attached to any
Scheme symbol.

@example
#!ikarus
(import (vicare))

(putprop 'ciao 'british 'hello)
(putprop 'ciao 'spanish 'hola)

(getprop 'ciao 'british)        @result{} hello
(getprop 'ciao 'spanish)        @result{} hola

(remprop 'ciao 'british)
(getprop 'ciao 'british)        @result{} #f

(property-list 'ciao)           @result{} ((spanish . hola))
@end example

The following bindings are exported by the library @library{vicare}.


@defun putprop @var{symbol} @var{key} @var{value}
Add a new property @var{key} with @var{value} to the property list of
@var{symbol}.  @var{key} must be a symbol, @var{value} can be any value.

If @var{key} is already set: the old entry is mutated to reference the
new @var{value}.
@end defun


@defun getprop @var{symbol} @var{key}
Return the value of the property @var{key} in the property list of
@var{symbol}; if @var{key} is not set return false.  @var{key} must be a
symbol.
@end defun


@defun remprop @var{symbol} @var{key}
Remove property @var{key} from the list associated to @var{symbol}.
@end defun


@defun property-list @var{symbol}
Return a new association list representing the property list of
@var{symbol}.  The order of the entries is the same as the property
creation order.
@end defun

@c page
@node iklib symbols values
@subsection System values bound to symbols


Every core primitive value has a name that is considered part of
Vicare's core language; such primitive name is the actual public name of
the binding exported by the boot image.  The name of the function
@func{display} is the symbol @code{display}; the name of the
record--type descriptor @code{&condition-rtd} is the symbol
@code{&condition-rtd}.

The property list of the name contains a special entry whose value is
the @dfn{storage location gensym} (``loc'' for short) of the core
primitive value; we can easily inspect such situation as follows:

@example
(import (vicare))

(getprop 'display system-value-gensym)
@result{} loc.display

;; extract the procedure from the loc
(symbol-value (getprop 'display system-value-gensym))
@result{} #<procedure display>

(system-value 'display)
@result{} #<procedure display>

(system-value '&condition-rtd)
@result{} #[rtd name=&condition ...]
@end example

We see that the property list contains an entry with key set to the
symbol bound to @code{system-value-gensym}; notice that this key is
different every time we rebuild the boot image.


@defun system-value @var{symbol}
Attempt to extract from @var{symbol} the core primitive value of which
@var{symbol} is the name; if successful return the Scheme object, else
raise an assertion violation.
@end defun


@defvr Constant system-value-gensym
A special gensym used internally to map core primitive names to their
value.
@end defvr

@c page
@node iklib symbols labels
@subsection Retrieving syntactic binding labels


Every core primitive value has a name that is considered part of
Vicare's core language; such primitive name is the actual public name of
the binding exported by the boot image.  The name of the function
@func{display} is the symbol @code{display}; the name of the
record--type descriptor @code{&condition-rtd} is the symbol
@code{&condition-rtd}.

Every core primitive syntactic binding has a unique @dfn{label} gensym
associated to it; the label is used to map identifiers bound to core
primitives to syntactic binding decriptors in the lexical environment.

The property list of the name contains a special entry whose value is
the label gensym of the core primitive syntactic binding; we can easily
inspect such situation as follows:

@example
(import (vicare))

(getprop 'display system-label-gensym)
@result{} lab.display

;; extract the lexical environment entry describing DISPLAY
(symbol-value (getprop 'display system-label-gensym))
@result{} (core-prim . display)

(system-label 'display)
@result{} lab.display
@end example

We see that the property list contains an entry with key set to the
symbol bound to @code{system-label-gensym}; notice that this key is
different every time we rebuild the boot image.


@defun system-label @var{symbol}
Attempt to extract from @var{symbol} the core primitive syntactic
binding label of which @var{symbol} is the name; if successful return
the label, else return @false{}.
@end defun


@defvr Constant system-label-gensym
A special gensym used internally to map core primitive names to their
syntactic binding label gensym.
@end defvr

@c page
@node iklib symbols identifiers
@subsection Retrieving syntactic binding identifiers


Every core primitive binding has a name that is considered part of
Vicare's core language; such primitive name is the actual public name of
the binding exported by the boot image.  The name of the function
@func{display} is the symbol @code{display}; the name of the
record--type descriptor @code{&condition-rtd} is the symbol
@code{&condition-rtd}.

Some internal operations generate an identifier bound to the primitive
and store it in the property list of the public primitive name; we can
easily inspect such situation as follows:

@example
(import (vicare))

(getprop 'procedure? system-id-gensym)
@result{} #<syntax expr=procedure? ...>

(system-id 'procedure?)
@result{} #<syntax expr=procedure? ...>
@end example

We see that the property list contains an entry with key set to the
symbol bound to @code{system-id-gensym}; notice that this key is
different every time we rebuild the boot image.


@defun system-id @var{symbol}
Attempt to extract from @var{symbol} the bound identifier of which
@var{symbol} is the name; if successful return the label, else return
@false{}.
@end defun


@defvr Constant system-id-gensym
A special gensym used internally to map core primitive names to their
syntactic binding identifiers.
@end defvr

@c page
@node iklib fixnums
@section Additional functions on fixnums


The following bindings are exported by the library @library{vicare}.


@defun fx!=? @vari{fx} @varii{fx}
@defunx fx!= @vari{fx} @varii{fx}
Return @true{} if the arguments are different; otherwise return
@false{}.  The arguments must be fixnums.
@end defun


@defun fxadd1 @var{fx}
@defunx fxsub1 @var{fx}
Add or subtract @samp{1} to @var{fx}.
@end defun


@defun fxabs @var{fx}
Return the absolute value of the fixnum @var{fx} as a fixnum; if
@var{fx} is @code{(least-fixnum)}: its absolute value is a bignum, in
which case this function raises an implementation restriction violation.

To compute the general absolute value without overflow we must use
@func{abs} or @func{$abs-fixnum}.
@end defun


@defun fxsign @var{fx}
Return one of the fixnums @code{+1}, @code{-1}, @code{0} representing
the sign of the fixnum @var{fx}.
@end defun


@defun fixnum->char @var{fx}
@defunx char->fixnum @var{ch}
Convert a fixnum to and from a character.
@end defun


@defun fixnum->string @var{fx}
@defunx fixnum->string @var{fx} @var{base}
Return a string representation of @var{fx}.  @var{base} must be one
among @math{2}, @math{8}, @math{10}, @math{16}; when not given it
defaults to @math{10}.
@end defun


@defun fxnonpositive? @var{fx}
@defunx fxnonnegative? @var{fx}
Return @true{} if @var{fx} is, respectively, non--positive or
non--negative; else return @false{}.
@end defun

@c page
@node iklib flonums
@section Additional functions on flonums


The following bindings are exported by the library @library{vicare}.

@c ------------------------------------------------------------

@subsubheading Predicates


@defun flnonpositive? @var{fl}
@defunx flnonnegative? @var{fl}
Return @true{} if @var{fl} is, respectively, non--positive or
non--negative; else return @false{}.
@end defun

@c ------------------------------------------------------------

@subsubheading String conversion


@defun flzero?/positive @var{fl}
@defunx flzero?/negative @var{fl}
Return true if the operand is @code{+0.0} or @code{-0.0}, respectively.
Notice that @func{flzero?} does @strong{not} make this distinction.
@end defun

@c ------------------------------------------------------------

@subsubheading String conversion


@defun string->flonum @var{fl}
@defunx flonum->string @var{str}
Convert between a flonum and its string representation.
@end defun

@c ------------------------------------------------------------

@subsubheading Exponents and logarithms


@defun fllog1p @var{fl}
Return a flonum equivalent to @math{log(1 + @var{fl})}.
@end defun


@defun flexpm1 @var{fl}
Return a flonum equivalent to @math{exp(@var{fl}) - 1}.
@end defun


@defun flhypot @vari{fl} @varii{fl}
Compute the Euclidean distance function: @math{\sqrt(X*X+Y*Y)}.
@glibcref{Exponents and Logarithms, hypot}.
@end defun

@c ------------------------------------------------------------

@subsubheading Hyperbolic functions


@defun flsinh @var{fl}
@defunx flcosh @var{fl}
@defunx fltanh @var{fl}
Compute the hyperbolic functions.  Return flonum objects.
@end defun


@defun flasinh @var{fl}
@defunx flacosh @var{fl}
@defunx flatanh @var{fl}
Compute the inverse hyperbolic functions.  Return flonum objects.
@end defun

@c ------------------------------------------------------------

@subsubheading Power functions


@defun flsquare @var{fl}
Return the square of @var{fl}, that is @var{fl} multiplied by itself.
@end defun


@defun flcube @var{fl}
Return the cube of @var{fl}, that is @var{fl} times @var{fl} times
@var{fl}.
@end defun


@defun flcbrt @var{fl}
Return the real cube root function of @var{fl}.
@end defun

@c ------------------------------------------------------------

@subsubheading Miscellaneous functions


@defun flonum-bytes @var{fl}
Return @math{8} values being fixnums representing octects from the
binary representation of @var{fl}.
@end defun


@defun flonum-parts @var{fl}
Return @math{3} values begin: a boolean, true if @var{fl} is positive; a
fixnum representing the exponent's @math{11} bits; an exact integer
representing the mantissa's @math{53} bits.

@example
(flonum-parts 2.0)
@result{} #t #b10000000000 #b0

(flonum-parts 4.0)
@result{} #t #b10000000001 #b0

(flonum-parts +0.0)
@result{} #t #b00000000000 #b0

(flonum-parts -0.0)
@result{} #f #b00000000000 #b0
@end example
@end defun

@c page
@node iklib numerics
@section Additional functions on numbers


@menu
* iklib numerics constants::    Numeric constants.
* iklib numerics compar::       Additional comparison functions.
* iklib numerics preds::        Additional numeric predicates.
* iklib numerics bignums::      Additional bignum functions.
* iklib numerics math::         Additional math functions.
* iklib numerics bitwise::      Additional bitwise functions.
@end menu

@c page
@node iklib numerics constants
@subsection Numeric constants


@cindex Library @library{vicare numerics constants}
@cindex @library{vicare numerics constants}, library


The following bindings are exported by the library @library{vicare
numerics constants}.  Notice that under @gnu{} Emacs it is easy to
display the symbol @code{greek-pi} with the Unicode glyph for the greek
letter adding the following to the Scheme hook:

@example
(defun my-pretty-chars-scheme-pi ()
  (interactive)
  (font-lock-add-keywords
   nil '(("\\(\\<[-+]?\\(greek-pi\\)\\)"
          (0 (progn
               (compose-region (match-beginning 2)
                               (match-end 2)
                               ?\u03C0)
               nil))))))
@end example


@deffn Constant greek-pi
@deffnx Constant +greek-pi
@deffnx Constant -greek-pi
Evaluate to a constant flonum object representing plus or minus pi.
@end deffn


@deffn Constant greek-pi/2
@deffnx Constant +greek-pi/2
@deffnx Constant -greek-pi/2
Evaluate to a constant flonum object representing plus or minus pi
divided by @math{2}.
@end deffn


@deffn Constant greek-pi/3
@deffnx Constant +greek-pi/3
@deffnx Constant -greek-pi/3
Evaluate to a constant flonum object representing plus or minus pi
divided by @math{3}.
@end deffn


@deffn Constant greek-pi/4
@deffnx Constant +greek-pi/4
@deffnx Constant -greek-pi/4
Evaluate to a constant flonum object representing plus or minus pi
divided by @math{4}.
@end deffn


@deffn Constant greek-pi/6
@deffnx Constant +greek-pi/6
@deffnx Constant -greek-pi/6
Evaluate to a constant flonum object representing plus or minus pi
divided by @math{6}.
@end deffn


@deffn Constant greek-pi*2
@deffnx Constant +greek-pi*2
@deffnx Constant -greek-pi*2
Evaluate to a constant flonum object representing plus or minus pi
multiplied by @math{2}.
@end deffn


@deffn Constant greek-pi*2/3
@deffnx Constant +greek-pi*2/3
@deffnx Constant -greek-pi*2/3
Evaluate to a constant flonum object representing plus or minus pi
multiplied by @math{2/3}.
@end deffn


@deffn Constant greek-pi*3/4
@deffnx Constant +greek-pi*3/4
@deffnx Constant -greek-pi*3/4
Evaluate to a constant flonum object representing plus or minus pi
multiplied by @math{3/4}.
@end deffn

@c page
@node iklib numerics compar
@subsection Additional comparison functions


@defun != @vari{Z} @varii{Z} @variii{Z} @dots{}
Return @true{} if all the arguments are equal, otherwise return
@false{}; all the arguments must be numbers according to
@func{number?}.  This function is equivalent to:

@example
(not (= @vari{Z} @varii{Z} @variii{Z} ...))
@end example
@end defun

@c page
@node iklib numerics preds
@subsection Additional numeric predicates


The following bindings are exported by the library @library{vicare}.


@defun bignum? @var{obj}
Return @true{} if @var{obj} is an exact integer represented by a big
number; otherwise return @false{}.
@end defun


@defun ratnum? @var{obj}
Return @true{} if @var{obj} is an exact rational number; otherwise
return @false{}.
@end defun


@defun cflonum? @var{obj}
Return @true{} if @var{obj} is a complex number having flonums as both
real and imaginary parts; otherwise return @false{}.
@end defun


@defun compnum? @var{obj}
Return @true{} if @var{obj} is a complex number having any possible
combination of number representations as real and imaginary parts, but
not both flonums; otherwise return @false{}.
@end defun


@defun exact-integer? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum; otherwise return
@false{}.
@end defun

@c ------------------------------------------------------------

@defun non-positive? @var{X}
@defunx non-negative? @var{X}
Return @true{} if @var{X} is a real number object and it is,
respectively, non--positive or non--negative.
@end defun


@defun zero-exact-integer? @var{obj}
Return @true{} if @var{obj} is an exact integer whose value is zero,
otherwise return @false{}; only fixnums can be zero.  If @var{obj} is
not a number object: return @false{}.
@end defun


@defun positive-exact-integer? @var{obj}
@defunx negative-exact-integer? @var{obj}
Return @true{} if @var{obj} is a positive or negative exact integer;
otherwise return @false{}.  If @var{obj} is not a number object: return
@false{}.
@end defun


@defun non-positive-exact-integer? @var{obj}
@defunx non-negative-exact-integer? @var{obj}
Return @true{} if @var{obj} is a non--positive or non--negative exact
integer; otherwise return @false{}.  If @var{obj} is not a number
object: return @false{}.
@end defun

@c page
@node iklib numerics bignums
@subsection Additional bignum functions


@defun bignum-positive? @var{bn}
@defunx bignum-non-negative? @var{bn}
The argument must be a bignum.  Return @true{} if it is positive,
otherwise return @false{}.
@end defun


@defun bignum-negative? @var{bn}
@defunx bignum-non-positive? @var{bn}
The argument must be a bignum.  Return @true{} if it is negative,
otherwise return @false{}.
@end defun


@defun bignum-odd? @var{bn}
The argument must be a bignum.  Return @true{} if it is odd, otherwise
return @false{}.
@end defun


@defun bignum-even? @var{bn}
The argument must be a bignum.  Return @true{} if it is even, otherwise
return @false{}.
@end defun


@defun least-positive-bignum
Return the smallest positive bignum.
@end defun


@defun greatest-negative-bignum
Return the greatest negative bignum.
@end defun

@c page
@node iklib numerics math
@subsection Additional math functions


The following bindings are exported by the library @library{vicare}.

@c ------------------------------------------------------------

@subsubheading Arithmetic functions


@defun add1 @var{num}
@defunx sub1 @var{num}
Add or subtract @samp{1} to @var{num}, which can be any number.
@end defun


@defun square @var{num}
Return the square of @var{num}: @var{num} times @var{num}.
@end defun


@defun cube @var{num}
Return the cube of @var{num}: @var{num} times @var{num} times @var{num}.
@end defun


@defun quotient @vari{N} @varii{N}
@defunx remainder @vari{N} @varii{N}
@defunx quotient+remainder @vari{N} @varii{N}
@func{quotient+remainder} returns two values: the quotient and the
remainder of the number--theoretic integer division between the
operands; @func{quotient} returns the quotient; @func{remainder} returns
the remainder.  @vari{N} and @varii{N} must be exact or inexact integers
(fixnums, bignums, flonums); @varii{N} must be non--zero.

The operations are defined as for @func{quotient} and @func{remainder}
from @rsixlibrary{r5rs}.

Note that considering:

@example
(quotient+remainder X Y)
@end example

@noindent
according to @rnrs{6}:

@example
(define (sign n)
  (cond ((negative? n) -1)
        ((positive? n) 1)
        (else 0)))

(define (quotient n1 n2)
  (* (sign n1) (sign n2) (div (abs n1) (abs n2))))

(define (remainder n1 n2)
  (* (sign n1) (mod (abs n1) (abs n2))))

(define (modulo n1 n2)
  (* (sign n2) (mod (* (sign n2) n1) (abs n2))))
@end example

@noindent
so we have:

@example
sign(quotient)  = sign(X) * sign(Y)
sign(remainder) = sign(X)
@end example
@end defun


@defun sign @var{X}
Return a number object representing the sign of @var{X}, which must be
a real number.  When @var{X} is a:

@table @strong
@item fixnum
@itemx bignum
Return a fixnum representing the sign of @var{X}: @code{+1} for
positive, @code{-1} for negative, @code{0} for zero.

@item flonum
Return a flonum representing the sign of @var{X}: @code{+1.0} for
positive, including @code{+0.0} and @code{+inf.0}; @code{-1} for
negative, including @code{-0.0} and @code{-inf.0}; @code{+nan.0} for
not--a--number.

@item ratnum
Return a fixnum representing the sign of the numerator of @var{rn}:
@code{+1} for positive, @code{-1} for negative, @code{0} for zero.
@end table
@end defun


@defun factorial @var{I}
Return the factorial of the non--negative integer @var{I} (which can be
exact or inexact).
@end defun

@c ------------------------------------------------------------

@subsubheading Hyperbolic functions

The @var{num} operand must be a real or complex number.


@defun sinh @var{num}
@defunx cosh @var{num}
@defunx tanh @var{num}
Hyperbolic functions.
@end defun


@defun asinh @var{num}
@defunx acosh @var{num}
@defunx atanh @var{num}
Inverse hyperbolic functions.
@end defun

@c ------------------------------------------------------------

@subsubheading Complex number functions


@defun complex-conjugate @var{num}
@cindex Conjugate of a complex number
Return the complex conjugate of the number object @var{num}.
@end defun

@c page
@node iklib numerics bitwise
@subsection Additional bitwise functions


The following bindings are exported by the library @library{vicare}.


@defun sra @var{integer} @var{offset}
An alias for @func{bitwise-arithmetic-shift-right}.
@end defun


@defun sll @var{integer} @var{offset}
An alias for @func{bitwise-arithmetic-shift-left}.
@end defun

@c page
@node iklib enumerations
@section Additional functions on enumerations


The following bindings are exported by the library @library{vicare}.


@defun enum-set? @var{obj}
Return @true{} if @var{obj} is an enumeration set object, else return
@false{}.
@end defun

@c page
@node iklib hashtables
@section Additional functions on hashtables


@defun string-ci-hash @var{str}
Case--insensitive hash function for strings.
@end defun

@c page
@node iklib load
@section Loading source files


Loading of source files can be done explicitly or by requesting a
library with the @func{import} form.  Here we see how to load files by
specifying their pathname on the file system.


@defun load @var{pathname}
@defunx load @var{pathname} @var{eval-proc}
Read and evaluate the file selected by the string @var{pathname}.

If @var{eval-proc} is given: it must be a procedure that takes a single
argument, an annotated form, and evaluates it.  The default
@var{eval-proc} looks like this:

@example
(define (load-handler x)
  (eval x (interaction-environment)))
@end example

The format of the annotated source is the one which is comprehensible by
@func{eval}.
@end defun

@c page
@node iklib modules
@section Local modules


Modules are somewhat like libraries in that they define a set of
bindings in a ``private namespace''; bindings can be exported from a
module and imported into other modules and libraries.  The main
difference between modules and @rnrs{6} libraries is that modules are
defined in a single form nested into a library; so, in a way, they are
sub--libraries.


@deffn Syntax module @meta{interface} @meta{definition} ... @meta{expression} ...
@deffnx Syntax module @meta{name} @meta{interface} @meta{definition} ... @meta{expression} ...
Define a new local module.  The first form defines an @emph{anonymous}
module, while the second form defines a @emph{named} module called
@meta{name}, which must be a symbol.

@meta{interface} is a list of symbols selecting bindings from this
module to be exported; every listed symbol must be bound in this
module's @meta{definition}, otherwise an error is raised.

@meta{definition} is a set of bindings like the one that may appear at
the beginning of a @func{let} body, with the addition of @func{import}
forms that may import bindings from libraries and other modules.

@meta{expression} is a set of expressions that is evaluated at module's
definition time.

Modules ``exist'' only in the enclosing region, bindings exported from a
module are not accessible outside of the enclosing region.  Modules can
be nested and import/export relations are possible according to the
regions nesting hierarchy.

Bindings in the @meta{interface} declared by anonymous modules are
imported by default in the enclosing region: there is no need to use
@func{import}.  Bindings in the @meta{interface} declared by named
modules are visible only in regions that @func{import} the module.

@meta{definition} and @meta{expression} have no default access to the
bindings in the enclosing region; only imported bindings are visible
from the module.
@end deffn

@c ------------------------------------------------------------

@subsubheading Examples of anonymous modules

The following example defines an anonymous module, without expressions,
and invokes its functions from the enclosing region (which is the top
level):

@example
(import (vicare))

(module (one two three)
    (define (one)       'one)
    (define (two)       'two)
    (define (three)     (cons 'three (hidden)))
    (define (hidden)    'hidden))

(fprintf (current-error-port)
         "calling anonymous: ~s ~s ~s\n" (one) (two) (three))
@end example

@noindent
notice that the @func{hidden} function is visible inside the module but
not in the enclosing region.

The following example defines a module, with expressions, and invokes
its functions from the enclosing region (which is the top level):

@example
(import (vicare))

(module (one two three)
    (define (one)       'one)
    (define (two)       'two)
    (define (three)     (cons 'three (hidden)))
    (define (hidden)    'hidden)

    (fprintf (current-error-port)
             "defining an anonymous module\n"))

(fprintf (current-error-port)
         "calling anonymous: ~s ~s ~s\n" (one) (two) (three))
@end example

@noindent
notice that when the enclosing region is the top level: the expressions
at the end of a module are evaluated @strong{after} the expressions at
the top level; so the output from the example is:

@example
calling anonymous: one two (three . hidden)
defining an anonymous module
@end example

@noindent
this can lead to undesired results if the module's expressions are meant
to initialise the state of the module, and the expressions at the top
level invoke the module's functions (before initialisation).  On the
other hand: this behaviour allows the module to access definitions from
the enclosing region and the top level region despite their placement in
the file; see below for an example.  The same behaviour is shown by
named modules.

The following example defines a module, with expressions, and invokes
its functions from the enclosing region (which is a @func{let} form):

@example
(import (vicare))

(let ()
  (module (one two three)
      (define (one)       'one)
      (define (two)       'two)
      (define (three)     (cons 'three (hidden)))
      (define (hidden)    'hidden)

      (printf (current-error-port)
              "defining an anonymous module\n"))

  (fprintf (current-error-port)
           "calling anonymous: ~s ~s ~s\n" (one) (two) (three)))
@end example

@noindent
notice that when the enclosing region is @strong{not} the top level: the
expressions at the end of a module are evaluated @strong{before} the
expressions in the body of the enclosing region; so the output from the
example is:

@example
defining an anonymous module
calling anonymous: one two (three . hidden)
@end example

@noindent
so the state of the module can be correctly initialised before its
functions are invoked.  The same behaviour is shown by named modules.

The following example shows that bindings from the enclosing region and
the top level environment are accessible from the modules:

@example
(import (vicare))

(define (top-level-before) 'top-level-before)

(let ()

  (define (outer-before) 'outer-before)

  (module (one two three)
    (define (one)       'one)
    (define (two)       'two)
    (define (three)     (list 'three
                              (outer-before)
                              (outer-after)
                              (top-level-before)
                              (top-level-after))))

  (define (outer-after) 'outer-after)

  (fprintf (current-error-port)
           "calling anonymous: ~s ~s ~s\n" (one) (two) (three)))

(define (top-level-after) 'top-level-after)
@end example

@noindent
this happens both when the enclosing region is the top level and when
the enclosing region is not the top level.  The same behaviour is shown
by named modules.

@c ------------------------------------------------------------

@subsubheading Named modules


The following example defines a module named @code{blue} and invokes
functions from it in the top level region:

@example
(import (vicare))

(module blue (blue-one blue-two blue-three)
    (define (blue-one)          'blue-one)
    (define (blue-two)          'blue-two)
    (define (blue-three)        (cons 'blue-three (hidden)))
    (define (hidden)            'blue-hidden))

(import blue)
(fprintf (current-error-port)
         "calling blue: ~s ~s ~s\n"
         (blue-one) (blue-two) (blue-three))
@end example

@noindent
notice that bindings from a named module are accessible only if imported
in the enclosing region.

The following example defines two modules named @code{green} and
@code{red}, then it imports their bindings in different regions:

@example
(import (vicare))

(let ()

  (module green (one two three)
    (define (one)       'green-one)
    (define (two)       'green-two)
    (define (three)     (cons 'green-three (hidden)))
    (define (hidden)    'green-hidden))

  (module red (one two three)
    (define (one)       'red-one)
    (define (two)       'red-two)
    (define (three)     (cons 'red-three (hidden)))
    (define (hidden)    'red-hidden))

  (import green)

  (let ()
    (import red)
    (fprintf (current-error-port)
             "calling red: ~s ~s ~s\n" (one) (two) (three)))

  (fprintf (current-error-port)
           "calling green: ~s ~s ~s\n" (one) (two) (three)))
@end example

The following example shows that modules in the same enclosing region
can import their bindings:

@example
(import (vicare))

(let ()

  (module green (one two)
    (define (one)       'one)
    (define (two)       'two))

  (module red (f g)
    (import green)
    (define (f)         (cons 'f (one)))
    (define (g)         (cons 'g (two))))

  (import red)
  (fprintf (current-error-port)
           "calling red: ~s ~s\n" (f) (g)))
@end example

@noindent
while the following example shows that bindings from an anonymous module
are automatically available in modules defined in the same enclosing
region:

@example
(import (vicare))

(let ()

  (module (one two)
    (define (one)       'one)
    (define (two)       'two))

  (module red (f g)
    (define (f)         (cons 'f (one)))
    (define (g)         (cons 'g (two))))

  (import red)
  (fprintf (current-error-port)
           "calling red: ~s ~s\n" (f) (g)))
@end example

@noindent
and the following example shows that the order of module definitions
does not matter in determining visibility of bindings from
@strong{anonymous} modules:

@example
(import (vicare))

(let ()

  (module red (f g)
    (define (f)         (cons 'f (one)))
    (define (g)         (cons 'g (two))))

  (module (one two)
    (define (one)       'one)
    (define (two)       'two))

  (import red)
  (fprintf (current-error-port)
           "calling red: ~s ~s\n" (f) (g)))
@end example

@noindent
the following is an @strong{error} because it tries to import bindings
from a @strong{named} module before its definition:

@example
(import (vicare))

(let ()

  (module red (f g)
    (import green) ;; error here!!!
    (define (f)         (cons 'f (one)))
    (define (g)         (cons 'g (two))))

  (module green (one two)
    (define (one)       'one)
    (define (two)       'two))

  (import red)
  (fprintf (current-error-port)
           "calling red: ~s ~s\n" (f) (g)))
@end example

@c ------------------------------------------------------------

@subsubheading Utilities examples


The following example shows how syntactic abstractions can be used to
access definitions in a module without explicitly using the
@func{import} form:

@example
(import (vicare))

(let ()

  (define-syntax in-module
    (syntax-rules ()
      ((_ ?module ?expr ...)
       (let () (import ?module) ?expr ...))))

  (module red (one two)
    (define (one arg)   (cons 'red-one arg))
    (define (two arg)   (cons 'red-two arg)))

  (module green (one two)
    (define (one arg)   (cons 'green-one arg))
    (define (two arg)   (cons 'green-two arg)))

  (fprintf (current-error-port)
           "calling ones: ~s ~s\n"
           ((in-module red one)   123)
           ((in-module green one) 456)))
@end example

@c page
@node iklib libraries
@section Local libraries


@rnrs{6} defines libraries to be top--level symbolic expressions; the
form @func{library} can appear only at the top--level; @ref{scheme
library form, Library form}.  @value{PRJNAME} extends the notion of
libraries by having the library @library{vicare} export a @func{library}
syntax; such syntax can be used anywhere a definition can be used and
the defined library can be imported in its region of visibility.

The following is a perfectly valid Vicare program:

@example
(import (vicare))

(let ()
  (library (ciao)
    (export a)
    (import (rnrs))
    (define a 1))

  (library (hello)
    (export b)
    (import (rnrs))
    (define b 1))

  (import (ciao))
  (import (hello))

  (display (list a b)))
@end example

@c page
@node iklib parameters
@section Parameters


Parameters in @value{PRJNAME} are intended for customizing the behavior
of a procedure during the dynamic execution of some piece of code.
Parameters are first class entities (represented as procedures) that
hold the parameter value.  We can think of a parameter function as:

@example
(let ((the-value @meta{init-value})
      (guard     @meta{guard-func}))
  (case-lambda
    (()
     the-value)
    ((new-value)
     (set! the-value (guard new-value)))
    ((new-value guard?)
     (if guard?
         (set! the-value (guard new-value))
       (set! the-value new-value)))))
@end example

@noindent
where @meta{init-value} is the parameter's initialisation value and
@meta{guard-func} is a function accepting one argument and returning one
value.  The behaviour is as follows:

@itemize
@item
When applied to no arguments: the parameter function returns the current
value of the parameter.

@item
When applied to a single argument: the parameter function sets the
current value of the parameter to the return value of the guard function
applied to the argument.

@item
When applied to two arguments: the parameter function sets the current
value of the parameter to either the return value of the guard function
applied to the first argument or directly to the first argument without
applying the guard function.
@end itemize

Parameter functions are created by @func{make-parameter}; the
parameter's initialisation value is @strong{not} automatically passed
through the guard function by @func{make-parameter}.  About guarding or
not the initialisation value there are pros and cons for both the
choices; @value{PRJNAME} does not guard the initialisation value because
a parameter can be used to hold ``complex'' objects and it is not always
desirable to create one of those at program start time.  When needed it
is possible to validate the value by explicitly writing the required
predicate.

@quotation
As example, consider a parameter used to hold the ``current database
connection''; we may not want to connect to a database right at program
start time.  With a validating parameter: we should create a ``null''
connection object for the only purpose of initialising the parameter and
then test for it; with a non--validating parameter: we just initialise
the parameter to @false{}.
@end quotation

Parameters replace the older concept of using starred @code{*global*}
customization variables.  For example, instead of writing:

@example
(define *screen-width* 72)
@end example

@noindent
and then mutating the variable @code{*screen-width*} with @code{set!},
we could wrap the variable @code{*screen-width*} with a
@code{screen-width} parameter as follows:

@example
(define *screen-width* 72)
(define screen-width
   (case-lambda
     (()  *screen-width*)
     ((x) (set! *screen-width* x))))
@end example

@noindent
the value of @code{screen-width} can now be passed as argument, returned
as a value, and exported from libraries.  With parameters we can write
this code succinctly as:

@example
(define screen-width (make-parameter 72))
@end example

Typical uses of the guard function include checking some constraints on
the passed argument or converting it to a different data type.  The
@code{screen-width} parameter may be constructed more robustly as:

@example
(define screen-width
  (make-parameter 72
    (lambda (w)
      (assert (and (integer? w) (exact? w)))
      (max w 1))))
@end example

@noindent
this definition ensures, through @func{assert}, that the argument passed
is an exact integer; it also ensures, through @func{max} that the
assigned value is always positive.


@deffn Procedure make-parameter @var{init}
@deffnx Procedure make-parameter @var{init} @var{guard}
Build and return a new parameter function using @var{init} as
initialisation value and @var{guard} as guard function.
@end deffn


@deffn Syntax parametrise ((@meta{lhs} @meta{rhs}) @dots{}) @metao{body} @meta{body} @dots{}
@deffnx Syntax parameterize ((@meta{lhs} @meta{rhs}) @dots{}) @metao{body} @meta{body} @dots{}
@deffnx Syntax parameterise ((@meta{lhs} @meta{rhs}) @dots{}) @metao{body} @meta{body} @dots{}
Parameters can be assigned to by simply calling the parameter procedure
with a single argument.  The @func{parameterize} syntax is used to set
the value of a parameter within the dynamic extent of the @code{body
body* ...} expressions.

The @code{lhs* ...} are expressions, each of which must evaluate to a
parameter.  Such parameters are not necessarily constructed by
@func{make-parameter}---any procedure that follows the parameters
protocol works.

The advantage of using @func{parameterize} over explicitly assigning to
parameters (same argument applies to global variables) is that you're
guaranteed that whenever control exits the body of a @func{parameterize}
expression, the value of the parameter is reset back to what it was
before the body expressions were entered.  This is true even in the
presence of @func{call/cc}, errors, and exceptions.

The following example shows how to set the text property of a terminal
window.  The parameter @code{terminal-property} sends an @ansi{} escape
sequence to the terminal whenever the parameter value is changed.  The
use of @code{terminal-property} within @func{parameterize} changes the
property before @code{(display "RED!")} is called and resets it back to
normal when the body returns.

@example
(define terminal-property
  (make-parameter "0"
    (lambda (x)
      (display "\x1b;[")
      (display x)
      (display "m")
      x)))

(display "Normal and ")
(parameterize ((terminal-property "41;37"))
  (display "RED!"))
(newline)
@end example

Notice that this syntax applies the parameters' guard functions when
setting new values, but does @strong{not} apply them when restoring the
original value.
@end deffn

@c page
@node iklib gensym
@section Gensyms


Gensym stands for @emph{generated symbol}---a fresh symbol that is
generated at run time and is guaranteed to be @emph{not} @func{eq?} to
any other symbol present in the system.  Gensyms are useful in many
applications including expanders, compilers, and interpreters when
generating an arbitrary number of unique names is needed.

@value{PRJNAME} is similar to Chez Scheme in that the readers (including the
@func{read} procedure) and writers (including @func{write} and
@func{pretty-print}) maintain the read/write invariance on gensyms.
When a gensym is written to an output port, the system automatically
generates a random unique identifier for the gensym.  When the gensym is
read back though the @code{#@{gensym@}} read syntax, a new gensym is
@emph{not} regenerated, but instead, it is looked up in the global
symbol table.

A gensym's name is composed of two parts: a @emph{pretty} string and a
@emph{unique} string.  The Scheme procedure @func{symbol->string}
returns the pretty string of the gensym and not its unique string.
Gensyms are printed by default as @code{#@{pretty-string unique-string@}}.

The reader supports special syntaxes to generate symbols, @ref{iklib
reader stx}.


@deffn Procedure gensym
@deffnx Procedure gensym @var{string}
@deffnx Procedure gensym @var{symbol}
Construct a new gensym.  If passed no arguments, construct a gensym with
no pretty name.  The pretty name is constructed when and if the pretty
name of the resulting gensym is needed.  If @func{gensym} is passed a
string, that string is used as the pretty name.  If @func{gensym} is
passed a symbol, the pretty name of the symbol is used as the pretty
name of the returned gensym.  See @func{gensym-prefix} and
@func{gensym-count} for details.

@example
> (gensym)
#@{g0 |y0zf>GlFvcTJE0xw|@}
> (gensym)
#@{g1 |U%X&sF6kX!YC8LW=|@}
> (eq? (gensym) (gensym))
#f
@end example

@code{(gensym string)} constructs a new gensym with @var{string} as its
pretty name.  Similarly, @code{(gensym symbol)} constructs a new gensym
with the pretty name of @var{symbol}, if it has one, as its pretty name.

@example
> (gensym "foo")
#@{foo |>VgOllCM&$dSvRN=|@}
> (gensym 'foo)
#@{foo |!TqQLmtw2hoEYfU>|@}
> (gensym (gensym 'foo))
#@{foo |N2C>5O0>C?OROUBU|@}
@end example
@end deffn


@deffn Procedure gensym? @var{x}
Return @true{} if its argument is a gensym, return @false{} otherwise.

@example
> (gensym? (gensym))
#t
> (gensym? 'foo)
#f
> (gensym? 12)
#f
@end example
@end deffn


@deffn Procedure gensym->unique-string @var{gensym}
Return the unique name associated with the gensym argument.

@example
> (gensym->unique-string (gensym))
"YukrolLMgP?%ElcR"
@end example
@end deffn

@c ------------------------------------------------------------

@subsubheading An example

The @library{rnrs syntax-case} library provides a
@func{generate-temporaries} procedure, which takes a syntax object
(representing a list of things) and returns a list of fresh identifiers.
Using @func{gensym}, that procedure can be defined as follows:

@example
(define (generate-temporaries* stx)
  (syntax-case stx ()
    [(x* ...)
     (map (lambda (x)
            (datum->syntax #'unimportant
              (gensym
                (if (identifier? x)
                    (syntax->datum x)
                    't))))
          #'(x* ...))]))
@end example

The above definition works by taking the input @var{stx} and
destructuring it into the list of syntax objects @code{x* ...}.  The
inner procedure maps each @var{x} into a new syntax object (constructed
with @func{datum->syntax}).  The datum is a gensym, whose name is the
same name as @var{x} if @var{x} is an identifier, or the symbol @code{t}
if @var{x} is not an identifier.  The output of
@func{generate-temporaries*} generates names similar to their input
counterpart:

@example
> (print-gensym #f)
> (generate-temporaries* #'(x y z 1 2))
(#<syntax x> #<syntax y> #<syntax z> #<syntax t> #<syntax t>)
@end example

@c page
@node iklib printing
@section Printing


@deffn Procedure pretty-print @var{datum}
@deffnx Procedure pretty-print @var{datum} @var{output-port}
The procedure @func{pretty-print} is intended for printing Scheme data,
typically Scheme programs, in a format close to how a Scheme programmer
would write it.  Unlike @func{write}, which writes its input all in one
line, @func{pretty-print} inserts spaces and new lines in order to
produce more pleasant output.

@example
(define fact-code
  '(letrec ([fact (lambda (n)
                    (if (zero? n)
                        1
                      (* n (fact (- n 1)))))])
     (fact 5)))

> (pretty-print fact-code)
(letrec ((fact
          (lambda (n) (if (zero? n) 1 (* n (fact (- n 1)))))))
  (fact 5))
@end example

The second argument to @func{pretty-print}, if supplied, must be an
output port.  If not supplied, the @func{current-output-port} is used.

@quotation
@strong{LIMITATIONS} As shown in the output above, the current
implementation of @func{pretty-print} does not handle printing of square
brackets properly.
@end quotation
@end deffn


@defun pretty-print* @var{datum} @var{output-port} @var{start-column} @var{ending-newline?}
Like @func{pretty-print} but accepts the additional arguments:

@table @var
@item start-column
A non--negative fixnum.  The zero--based column offset at which the
first line is displayed.  When printing a multiline symbolic expression,
the column offset of the first line depends upon what has been already
printed on such line; this argument allows us to correctly align the
second and subsequent lines.  For example the following program:

@example
#!r6rs
(import (vicare))

(pretty-width 10)
(set-port-buffer-mode! (current-output-port)
                       (buffer-mode none))

(display "01234")
(pretty-print  '("56789" "8 7 6 5"))

(newline)

(display "01234")
(pretty-print* '("56789" "8 7 6 5")
               (current-output-port) 5 #t)
@end example

@noindent
prints:

@example
01234("56789"
  "8 7 6 5")

01234("56789"
       "8 7 6 5")
@end example

@item ending-newline?
Interpreted as boolean value.  If true: a newline character is output
after the symbolic expression.
@end table
@end defun


@deffn Parameter pretty-width
@deffnx Parameter pretty-width @var{n}
The parameter @func{pretty-width} controls the number of characters
after which the @func{pretty-print} starts breaking long lines into
multiple lines.  The initial value of @func{pretty-width} is set to 60
characters, which is suitable for most terminals and printed material.

@example
> (parameterize ([pretty-width 40])
     (pretty-print fact-code))
(letrec ((fact
          (lambda (n)
            (if (zero? n)
                1
                (* n (fact (- n 1)))))))
  (fact 5))
@end example

Note that @func{pretty-width} does not guarantee that the output will
not extend beyond the specified number.  Very long symbols, for
examples, cannot be split into multiple lines and may force the printer
to go beyond the value of @func{pretty-width}.
@end deffn


@defun debug-print . @var{args}
Print the given arguments on the current error port using
@func{pretty-print}.  This is a convenience function, useful while
debugging code.
@end defun


@deffn Parameter debug-print-enabled?
When set to true, @func{debug-print*} will print its arguments.  It is
initialised to @false{}.  We can set this parameter to any value,
internally the value is normalised to @true{} or @false{}.
@end deffn


@defun debug-print* . @var{args}
Like @func{debug-print}, but print arguments only when the parameter
@func{debug-print-enabled?} is set to true.
@end defun


@deffn Procedure format @var{fmt-string} @var{args} ...
The procedure @func{format} produces a string formatted according to
@func{fmt-string} and the supplied arguments.  The format string
contains markers in which the string representation of each argument is
placed.  The markers include:

@table @code
@item ~s
instructs the formatter to place the next argument as if the procedure
@func{write} has printed it; if the argument contains a string, the
string will be quoted and all quotes and backslashes in the string will
be escaped; similarly, characters will be printed using the @code{#\x}
notation;

@item ~a
instructs the formatter to place the next argument as if the procedure
@func{display} has printed it; strings and characters are placed as they
are in the output;

@item ~b
instructs the formatter to convert the next argument to its binary (base
2) representation; the argument must be an exact number;

@item ~o
is similar to @code{~b} except that the number is printed in octal (base
8);

@item ~x
is similar to @code{~b} except that the number is printed in hexadecimal
(base 16);

@item ~d
outputs the next argument, which can be an exact or inexact number, in
its decimal (base 10) representation;

@item ~~
instructs the formatter to place a tilde character, @code{~}, in the
output without consuming an argument;

@item ~%
instructs the formatter to place a newline character in the output
without consuming an argument.
@end table

Note that the @code{#b}, @code{#o}, and @code{#x} numeric prefixes are
not added to the output when @code{~b}, @code{~o}, and @code{~x} are
used.

@example
> (format "message: ~s, ~s, and ~s" 'symbol "string" #\c)
"message: symbol, \"string\", and #\\c"

> (format "message: ~a, ~a, and ~a" 'symbol "string" #\c)
"message: symbol, string, and c"
@end example
@end deffn


@deffn Procedure printf @var{fmt-string} @var{args} ...
The procedure @func{printf} is similar to @func{format} except that the
output is sent to the @code{current-output-port} instead of being
collected in a string.

@example
> (let ([n (+ (expt 2 32) #b11001)])
    (printf "~d = #b~b = #x~x\n" n n n))
4294967321 = #b100000000000000000000000000011001 = #x100000019
@end example
@end deffn


@deffn Procedure fprintf @var{output-port} @var{fmt-string} @var{args} ...
The procedure @func{fprintf} is similar to @func{printf} except that the
output port to which the output is sent is specified as the first
argument.
@end deffn


@deffn Parameter print-unicode
@deffnx Parameter print-unicode #t
@deffnx Parameter print-unicode #f
If set to true: print Scheme Unicode characters outside of the printable
@ascii{} range in hex format, else print them using the encoding of the
output port.  The default is false.
@end deffn


@deffn Parameter printer-integer-radix
The radix used to print exact integers (fixnums and bignums) with
@func{write}, @func{display} and similar functions.  Initialised to
@code{10}, it must hold a value usable as second argument to
@func{string->number}.
@end deffn


@deffn Parameter print-gensym
@deffnx Parameter print-gensym #t
@deffnx Parameter print-gensym #f
@deffnx Parameter print-gensym 'pretty
The parameter @code{print-gensym} controls how gensyms are printed by
the various writers.

If the value of @code{print-gensym} is @false{}, then gensym syntax is
suppressed by the writers and only the gensyms' pretty names are
printed.  If the value of @code{print-gensym} is @true{}, then the full
@code{#@{pretty unique@}} syntax is printed.  Finally, if the value of
@code{print-gensym} is the symbol @code{pretty}, then gensyms are
printed using the @code{#:pretty} notation.

@example
> (parameterize ([print-gensym #f])
    (pretty-print (list (gensym) (gensym))))
(g0 g1)

> (parameterize ([print-gensym #t])
    (pretty-print (list (gensym) (gensym))))
(#@{g2 |KR1M2&CTt1<B0n/m|@} #@{g3 |FBAb&7NC6&=c82!O|@})

> (parameterize ([print-gensym 'pretty])
    (pretty-print (list (gensym) (gensym))))
(#:g4 #:g5)
@end example

The initial value of @code{print-gensym} is @true{}.
@end deffn


@deffn Parameter gensym-prefix
@deffnx Parameter gensym-prefix @var{string}
The parameter @code{gensym-prefix} specifies the string to be used as
the prefix to generated pretty names.  The default value of
@code{gensym-prefix} is the string @code{g}, which causes generated
strings to have pretty names in the sequence @code{g0}, @code{g1},
@code{g2}, etc.

@example
> (parameterize ([gensym-prefix "var"]
                 [print-gensym #f])
     (pretty-print (list (gensym) (gensym) (gensym))))
(var0 var1 var2)
@end example

Beware that the @code{gensym-prefix} controls how pretty names are
generated, and has nothing to do with how @func{gensym} constructs a new
gensym.  In particular, notice the difference between the output in the
first example with the output of the examples below:

@example
> (pretty-print
    (parameterize ([gensym-prefix "var"] [print-gensym #f])
      (list (gensym) (gensym) (gensym))))
(g3 g4 g5)

> (let ([ls (list (gensym) (gensym) (gensym))])
    (parameterize ([gensym-prefix "var"] [print-gensym #f])
      (pretty-print ls)))
(var5 var6 var7)
@end example
@end deffn


@deffn Parameter gensym-count
@deffnx Parameter gensym-count @var{n}
The parameter @code{gensym-count} determines the number which is
attached to the @code{gensym-prefix} when gensyms' pretty names are
generated.  The initial value of @code{gensym-count} is 0 and is
incremented every time a pretty name is generated.  It might be set to
any non-negative integer value.

@example
> (let ([x (gensym)])
    (parameterize ([gensym-count 100] [print-gensym #f])
      (pretty-print (list (gensym) x (gensym)))))
(g100 g101 g102)
@end example
@end deffn

Notice from all the examples so far that pretty names are generated in
the order at which the gensyms are printed, not in the order in which
gensyms were created.

@c page
@node iklib tracing
@section Tracing for debugging


@deffn Syntax trace-define (name . args) body body* ...
@deffnx Syntax trace-define name expression
The @func{trace-define} syntax is similar to @func{define} except that
the bound value, which must be a procedure, becomes a traced procedure.
A traced procedure prints its arguments when it is called and prints its
values when it returns.

@example
> (trace-define (fact n)
    (if (zero? n) 1 (* n (fact (- n 1)))))
> (fact 5)
|(fact 5)
| (fact 4)
| |(fact 3)
| | (fact 2)
| | |(fact 1)
| | | (fact 0)
| | | 1
| | |1
| | 2
| |6
| 24
|120
120
@end example

The tracing facility in @value{PRJNAME} preserves and shows tail recursion and
distinguishes it from non--tail recursion by showing tail calls starting
at the same line in which their parent was called.

@example
> (trace-define (fact n)
    (trace-define (fact-aux n m)
      (if (zero? n) m (fact-aux (- n 1) (* n m))))
    (fact-aux n 1))
> (fact 5)
|(fact 5)
|(fact-aux 5 1)
|(fact-aux 4 5)
|(fact-aux 3 20)
|(fact-aux 2 60)
|(fact-aux 1 120)
|(fact-aux 0 120)
|120
120
@end example

Moreover, the tracing facility interacts well with continuations and
exceptions.

@example
> (call/cc
    (lambda (k)
      (trace-define (loop n)
        (if (zero? n)
            (k 'done)
            (+ (loop (- n 1)) 1)))
      (loop 5)))
|(loop 5)
| (loop 4)
| |(loop 3)
| | (loop 2)
| | |(loop 1)
| | | (loop 0)
done
@end example
@end deffn


@deffn Syntax trace-lambda name args body body* ...
The @func{trace-lambda} macro is similar to @func{lambda} except that
the resulting procedure is traced: it prints the arguments it receives
and the results it returns.
@end deffn


@deffn Procedure make-traced-procedure @var{name} @var{proc}
The procedure @func{make-traced-procedure} takes a name (typically a
symbol) and a procedure.  It returns a procedure similar to @var{proc}
except that it traces its arguments and values.

@example
> (define (fact n)
    (if (zero? n)
        (lambda (k) (k 1))
        (lambda (k)
          ((fact (- n 1))
           (make-traced-procedure `(k ,n)
             (lambda (v)
               (k (* v n))))))))
> (call/cc
    (lambda (k)
      ((fact 5) (make-traced-procedure 'K k))))
|((k 1) 1)
|((k 2) 1)
|((k 3) 2)
|((k 4) 6)
|((k 5) 24)
|(K 120)
120
@end example
@end deffn


@deffn Syntax trace-define-syntax @meta{keyword} @meta{expression}
Like @func{define-syntax} but create a tracing transformer function.
Whenever the macro is expanded the transformer function will print its
argument (the input form) and its return value (the output form).
Example:

@example
(trace-define-syntax ciao
  (syntax-rules ()
    ((_ ?a)
     (list 1 ?a 3))))

(ciao 2)
@print{} |(ciao (ciao 2))
@print{} |(list 1 2 3)
@end example

@noindent
the first printed symbolic expression @code{(ciao (ciao 2))} shows the
called tranformer function @code{(ciao ---)} and its argument being the
input form @code{(ciao 2)}, filtered through @func{syntax->datum}.
@end deffn


@deffn Syntax trace-let-syntax @meta{bindings} @meta{form} ...
@deffnx Syntax trace-letrec-syntax @meta{bindings} @meta{form} ...
Like @func{let-syntax} and @func{letrec-syntax} but define tracing
transformer functions.
@end deffn

@c page
@node iklib timing
@section Timing


This section describes some of @value{PRJNAME}'s timing facilities which may be
useful for benchmarking and performance tuning.


@deffn Syntax time @var{expression}
The @func{time} macro performs the following: it evaluates
@var{expression}, then prints a summary of the run time statistics, then
returns the values returned by @var{expression}.  The run--time summary
includes the number of bytes allocated, the number of garbage collection
runs, and the time spent in both the mutator and the collector.

@example
> (let ()                                   ;;; 10 million
    (define ls (time (vector->list (make-vector 10000000))))
    (time (append ls ls))
    (values))
running stats for (vector->list (make-vector 10000000)):
    3 collections
    672 ms elapsed cpu time, including 547 ms collecting
    674 ms elapsed real time, including 549 ms collecting
    120012328 bytes allocated
running stats for (append ls ls):
    4 collections
    1536 ms elapsed cpu time, including 1336 ms collecting
    1538 ms elapsed real time, including 1337 ms collecting
    160000040 bytes allocated
@end example

@quotation
@emph{Note:} The output listed above is @emph{just a sample} that was
taken at some point on some machine.  The output on your machine at the
time you read this may vary.
@end quotation
@end deffn


@deffn Procedure time-it @var{message} @var{thunk}
The procedure @func{time-it} takes a datum denoting the name of the
computation and a thunk (i.e. a procedure with no arguments), invokes
the thunk, prints the stats, and returns the values obtained from
invoking the thunk.  If the value of @var{message} is true,
@var{message} is used when displaying the run--time statistics; if the
value of @var{message} is @false{}, then no name for the computation is
displayed.

@example
> (time-it "a very fast computation"
    (lambda () (values 1 2 3)))
running stats for a very fast computation:
    no collections
    0 ms elapsed cpu time, including 0 ms collecting
    0 ms elapsed real time, including 0 ms collecting
    24 bytes allocated
1
2
3

> (time-it #f (lambda () 12))
running stats:
    no collections
    0 ms elapsed cpu time, including 0 ms collecting
    0 ms elapsed real time, including 0 ms collecting
    0 bytes allocated
12
@end example
@end deffn


@defun time-and-gather @var{gather} @var{thunk}
Like @func{time-it} evaluate the procedure @var{thunk} timing its
execution; return the return values of @var{thunk}.  Build two objects
of type @code{stats} and apply the procedure @var{gather} to them: the
first represents the statistics before @var{thunk} evaluation, the
second represents the statistics after @var{thunk} evaluation.
@end defun


@defun stats? @var{obj}
Return true if @var{obj} is an object of type @code{stats}.
@end defun


All the fields of a @code{stats} object hold fixnums.


@defun stats-user-secs @var{stats}
Return the user seconds field of @var{stats}.
@end defun


@defun stats-user-usecs @var{stats}
Return the user microseconds field of @var{stats}.
@end defun


@defun stats-sys-secs @var{stats}
Return the system seconds field of @var{stats}.
@end defun


@defun stats-sys-usecs @var{stats}
Return the system microseconds field of @var{stats}.
@end defun


@defun stats-real-secs @var{stats}
Return the real seconds field of @var{stats}.
@end defun


@defun stats-real-usecs @var{stats}
Return the real microseconds field of @var{stats}.
@end defun


@defun stats-collection-id @var{stats}
Return the collection identifier field of @var{stats}.
@end defun

@defun stats-gc-user-secs @var{stats}
Return the garbage collection user seconds field of @var{stats}.
@end defun


@defun stats-gc-user-usecs @var{stats}
Return the garbage collection user microseconds field of @var{stats}.
@end defun


@defun stats-gc-sys-secs @var{stats}
Return the garbage collection system seconds field of @var{stats}.
@end defun


@defun stats-gc-sys-usecs @var{stats}
Return the garbage collection system microseconds field of @var{stats}.
@end defun


@defun stats-gc-real-secs @var{stats}
Return the garbage collection real seconds field of @var{stats}.
@end defun


@defun stats-gc-real-usecs @var{stats}
Return the garbage collection real microseconds field of @var{stats}.
@end defun


@defun stats-bytes-minor @var{stats}
Return the garbage collection bytes minor field of @var{stats}.
@end defun


@defun stats-bytes-major @var{stats}
Return the garbage collection bytes major field of @var{stats}.
@end defun

@c page
@node iklib gc
@section Interfacing with garbage collection


@defun collect
Run the garbage collector.  If post--garbage collection hooks are
registered, they are run.  This binding is exported by the library
@library{vicare}.
@end defun

@c ------------------------------------------------------------

@subsubheading Avoiding garbage collection of objects


The following @api{} allows us to register objects in the internal state
of Vicare so that they are not garbage collected even though we may
loose all the Scheme references to them.

This mechanism is useful when we create a Scheme object and register it
in a data structure controlled by a foreign library (for example when
interfacing with C language libraries); we can loose the Scheme
references to such object without having it garbage collected, and later
we retrieve the object reference and use it.

@center @strong{This @api{} is to be considered experimental.}


@defun register-to-avoid-collecting @var{obj}
Register @var{obj} in the internal state of Vicare so that it is not
garbage collected even when we loose all the Scheme references to it;
return a pointer object which can be used to uniquely identify the
collected @var{obj}.

If @var{obj} is the return value of @code{(void)}: the returned value is
a @cnull{} pointer.
@end defun


@defun forget-to-avoid-collecting @var{pointer}
Remove the Scheme object associated to @var{pointer} from the internal
state of Vicare, so that it is garbage collected when we loose all the
Scheme references to it; return the referenced object.  @var{pointer}
must be the return value of a previous call to
@func{register-to-avoid-collecting}.

If @var{pointer} is @cnull{}: nothing happens and the returned value is
@code{(void)}.
@end defun


@defun retrieve-to-avoid-collecting @var{pointer}
Return the Scheme object associated to @var{pointer} in the internal
state of Vicare.  @var{pointer} must be the return value of a previous
call to @func{register-to-avoid-collecting}.

If @var{pointer} is @cnull{}: nothing happens and the returned value is
@code{(void)}.
@end defun


@defun replace-to-avoid-collecting @var{pointer} @var{new-obj}
Replace the Scheme object associated to @var{pointer} in the internal
state of Vicare with @var{new-obj}; return the previously registered
object.  @var{pointer} must be the return value of a previous call to
@func{register-to-avoid-collecting}.

If @var{pointer} is @cnull{}: nothing happens and the returned value is
@code{(void)}.
@end defun


@defun collection-avoidance-list
Return the list of objects that where registered to avoid collection by
@func{register-to-avoid-collecting}; it can be the empty list.
@end defun


@defun purge-collection-avoidance-list
Reset to empty the list of objects registered to avoid collection with
@func{register-to-avoid-collecting}.  Use with care.
@end defun

@c page
@node iklib guardians
@section Guardians and garbage collection


@cindex Guardians and garbage collection
@cindex Guarded values
@cindex Finalisation of objects through guardians
@cindex Objects finalisation through guardians
@cindex Destruction of objects through guardians
@cindex Objects destruction through guardians
@cindex Destructors, objects and guardians
@cindex Finalisers, objects and guardians


Guardians are available in the @library{vicare} library; quoting
@bibref{DYBGUA}:

@quotation
Guardians provide a means to protect objects from destruction by the
garbage collector.  A guardian is an object with which objects can be
registered for preservation and from which objects actually saved from
destruction can be retrieved, one at a time, at the convenience of the
program.
@end quotation

@menu
* iklib guardians examples::    Usage examples for guardians.
* iklib guardians api::         Guardians programming interface.
@end menu

@c page
@node iklib guardians examples
@subsection Usage examples for guardians


Let's say that we use the @value{PRJNAME} @ffi{} to handle some memory
block (@ref{ffi} for details on the @ffi{}); memory blocks allocated
with @func{malloc} are not released by the @value{PRJNAME} garbage
collector: we have to explicitly apply @func{free} to the pointer value
referencing them.

If we use the blocks synchronously with the evaluation of forms, we do
(assuming we do not use continuations, so this use of
@func{dynamic-wind} is fine):

@example
(import (vicare)
  (vicare ffi))

(define (do-something-with . args)
  (display args)
  (newline))

(let ((p        #f)
      (size     4096))
  (dynamic-wind
      (lambda ()
        (set! p (malloc size))
        (unless p (error #f "memory allocation")))
      (lambda ()
        (do-something-with p))
      (lambda ()
        (free p))))
@end example

@noindent
and we can define a syntax for it:

@example
(import (vicare)
  (vicare ffi))

(define (do-something-with . args)
  (display args)
  (newline))

(define-syntax with-block
  (syntax-rules ()
    ((_ ?pointer ?size ?body ...)
     (let ((?pointer    #f))
       (dynamic-wind
           (lambda ()
             (set! ?pointer (malloc ?size))
             (unless ?pointer (error #f "memory allocation")))
           (lambda ()
             ?body ...)
           (lambda ()
             (free ?pointer)))))))

(with-block p 2048
  (do-something-with p))

(with-block p 4096
  (do-something-with p))

(with-block p 8192
  (do-something-with p))
@end example

If we need the block in an event driven program: we will probably need
to use it asynchronously with the evaluation of forms.  For example, we
store the pointer value that references a block in a thunk (a closure
that takes no arguments):

@example
(import (vicare)
  (vicare ffi))

(define *event-source* '())

(define (enqueue-event event)
  (set! *event-source*
        (reverse (cons event (reverse *event-source*)))))

(define (pop-event)
  (if (null? *event-source*)
      #f
    (let ((event (car *event-source*)))
      (set! *event-source* (cdr *event-source*))
      event)))

;; Usage:

(define (do-something-with . args)
  (display args)
  (newline))

(let ((p (malloc 4096)))
  (unless p (error #f "memory allocation"))
  (enqueue-event (lambda ()
                   (do-something-with p)))
  (enqueue-event (lambda ()
                   (do-something-with 123)))
  (enqueue-event (lambda ()
                   (do-something-with p))))

(do ((event (pop-event) (pop-event)))
    ((not event))
  (event))
@end example

@noindent
once the thunks have been evaluated, the pointer value is garbage
collected, but the allocated memory block becomes leaked memory.  We
need a way to be notified of the pointer value garbage collection, so
that we can apply @func{free} to it; this is the job for guardians.

The following script shows the usage of a guardian to free a memory
block:

@example
(import (vicare)
  (vicare ffi))

(define g (make-guardian))

(let ((a (malloc (expt 2 20))))
  (unless p (error #f "memory allocation"))
  (g a)
  (printf "value ~s~%" a))

(printf "value from guardian ~s~%" (g))

;; This triggers a garbage collection.
(collect)

(let ((p (g)))
  (printf "value from guardian ~s~%" p)
  (free p))
@end example

In an event driven program what we have to do is to register the pointer
into the guardian, and then periodically enqueue as event a call to the
guardian:

@example
(import (vicare)
  (vicare ffi))

;; Event source handling.

(define *event-source* '())

(define (enqueue-event event)
  (set! *event-source*
        (reverse (cons event (reverse *event-source*)))))

(define (pop-event)
  (if (null? *event-source*)
      #f
    (let ((event (car *event-source*)))
      (set! *event-source* (cdr *event-source*))
      event)))

;; Block guardian.

(define block-guardian (make-guardian))

(define (run-block-guardian)
  (do ((p (block-guardian) (block-guardian)))
      ((not p))
    (printf "collecting ~s~%" p)
    (free p)))

;; Application follows.

(define (do-something-with . args)
  (display args)
  (newline))

(let ((p (malloc (expt 2 20))))
  (unless p (error #f "memory allocation"))
  (block-guardian p)
  (enqueue-event (lambda () (do-something-with p)))
  (enqueue-event (lambda () (do-something-with 123)))
  (enqueue-event (lambda () (do-something-with p)))
  (enqueue-event (lambda () (do-something-with 456))))

(do ((event (pop-event) (pop-event))
     (i 1 (+ i 1)))
    ((= i 20))
  (when event
    (event))
  (when (= 0 (modulo i 10))
    (collect)
    (enqueue-event run-block-guardian)))
@end example

@c page
@node iklib guardians api
@subsection Guardians programming interface


@defun make-guardian
Build and return a new guardian object: a closure that can be called
with one or zero arguments, and that is interfaced with the garbage
collector of @value{PRJNAME} in a non--portable way.

The guardian work like this:

@itemize
@item
When the closure is called with one argument: it adds the argument to an
internal set of ``guarded values'', accessible to the garbage collector;
the return value if the argument itself.

@item
When the garbage collector detects no other references to a value in the
set of guarded values: the guardian removes it from the set and appends
it to an internal queue (@acronym{FIFO}).

@item
When the closure is called with zero arguments: it removes the first
value from the internal queue and returns it; if no values are in the
queue it returns @false{}.
@end itemize

After an object has been returned by the guardian, it is no more
``guarded'' so it will be garbage collected when it will become
inaccessible (unless it is again registered in a guardian).

@quotation
@strong{NOTE} It is possible to register an object in more than one
guardian; when the object is found inaccessible all the guardian
closures that have it will return it to the caller.  This may lead to
invalid finalisation operations, it is the responsibility of the
programmer to avoid this.
@end quotation

@quotation
@strong{NOTE} It is possible to register an object multiple times in the
same guardian; when the object is found inaccessible the guardian
closure that has it will return it to the caller multiple times.  This
may lead to invalid finalisation operations, it is the responsibility of
the programmer to avoid this.
@end quotation
@end defun


@deffn Parameter post-gc-hooks
Hold a list of thunks evaluated after each garbage collection run.  It
can be used to run a guardian cleanup function like this (using the
example in the previous section):

@example
(define (run-block-guardian)
  (do ((p (block-guardian) (block-guardian)))
      ((not p))
    (free p)))

(post-gc-hooks
 (cons run-block-guardian
  (post-gc-hooks)))
@end example
@end deffn

@c page
@node iklib io
@section Input/output library


@value{PRJNAME} extends the input/output facilities defined by @rnrs{6}.

@menu
* iklib io pathnames::          String and bytevector pathnames
                                handling.
* iklib io codecs::             Transcoders and additional codecs.
* iklib io non-blocking::       Handling non--blocking devices.
* iklib io binary::             Additional binary port features.
* iklib io textual::            Additional textual port features.
* iklib io buffer::             Buffer size customisation.
* iklib io plists::             Port property lists.
* iklib io misc::               Miscellaneous port functions.
@end menu

@c page
@node iklib io pathnames
@subsection String and bytevector pathnames handling


All the file--related functions defined by @rnrs{6} accept a Scheme
string as representing a file pathname; internally such string is
converted to a bytevector to be handed to the underlying operating
system.

The following bindings are exported by the library @library{vicare}.


@deffn Parameter string->filename-func
@deffnx Parameter string->pathname-func
In @value{PRJNAME} the string--to--filename conversion is performed by
the function returned by @func{string->filename-func}, which defaults to
@func{string->utf8}.
@end deffn


@deffn Parameter filename->string-func
@deffnx Parameter pathname->string-func
In @value{PRJNAME} the filename--to--string conversion is performed by
the function returned by @func{filename->string-func}, which defaults to
@func{utf8->string}.
@end deffn


@defun directory-exists? @var{ptn}
Return @true{} if @var{ptn} is a string or bytevector representing the
pathname of an existent directory; otherwise return @false{}.
@end defun


The following bindings are exported by the library @library{vicare
language-extensions posix}.


@defun file-pathname? @var{obj}
@defunx file-string-pathname? @var{obj}
@defunx file-bytevector-pathname? @var{obj}
Return @true{} if @var{obj} is a string or bytevector, not empty, not
including a character whose @ascii{} representation is the null byte.
@end defun


@defun file-absolute-pathname? @var{pathname}
@defunx file-string-absolute-pathname? @var{pathname}
@defunx file-bytevector-absolute-pathname? @var{pathname}
The argument @var{pathname} must be a string or bytevector.  Return
@true{} if @var{pathname} starts with a @code{/} character, which means
it is valid as Unix--style absolute pathname; otherwise return @false{}.

This function only acts upon its argument, never accessing the file
system.
@end defun


@defun file-relative-pathname? @var{pathname}
@defunx file-string-relative-pathname? @var{pathname}
@defunx file-bytevector-relative-pathname? @var{pathname}
The argument @var{pathname} must be a string or bytevector.  Return
@true{} if @var{pathname} doest @strong{not} start with a @code{/}
character, which means it is valid as Unix--style relative pathname;
otherwise return @false{}.

This function only acts upon its argument, never accessing the file
system.
@end defun


@defun split-pathname-root-and-tail @var{pathname}
Given a string representing a pathname: split it into the directory part
and the tail part.  Return 2 values: a string representing the directory
part and a string representing the tail name part.  If @var{pathname} is
just the name of a file or directory relative to the current directory:
the directory part is empty and the first returned value is the empty
string.

Assume the pathname components separator is @code{/}, which is
Unix--specific.

@example
(receive (root tail)
    (split-pathname-root-and-tail "a/b")
  (list root tail))
@result{} ("a" "b")

(receive (root tail)
    (split-pathname-root-and-tail "ciao")
  (list root tail))
@result{} ("" "ciao")
@end example
@end defun


@defun file-colon-search-path? @var{obj}
@defunx file-string-colon-search-path? @var{obj}
@defunx file-bytevector-colon-search-path? @var{obj}
Return @true{} if @var{obj} is a string or bytevector, possibly empty,
not including a character whose @ascii{} representation is the null
byte.
@end defun


@defun split-search-path @var{path}
@defunx split-search-path-bytevector @var{bytevector-path}
@defunx split-search-path-string @var{string-path}
Split a file search path into its components and return a list of
pathnames.  A search path is meant to be a list of directory pathnames
separated by a colon character; @var{bytevector-path} must be a
bytevector, @var{string-path} must be a Scheme string, @var{path} must
be a Scheme string or bytevector.  Empty pathnames are discarded.

@example
#!vicare
(import (vicare))

(split-search-path-bytevector '#vu8())
@result{} ()

(split-search-path-bytevector #ve(ascii "ciao:hello"))
@result{} (#ve(ascii "ciao") #ve(ascii "hello"))

(split-search-path-bytevector '#ve(ascii "::::"))
@result{} ()

(split-search-path-string "")
@result{} ()

(split-search-path-string "ciao:hello:salut")
@result{} ("ciao" "hello" "salut")

(split-search-path-string "::::")
@result{} ()

(split-search-path "ciao:hello:salut")
@result{} ("ciao" "hello" "salut")

(split-search-path '#ve(ascii "ciao:hello:salut"))
@result{} (#ve(ascii "ciao") #ve(ascii "hello") #ve(ascii "salut"))
@end example
@end defun


@defun list-of-pathnames? @var{obj}
@defunx list-of-string-pathnames? @var{obj}
@defunx list-of-bytevector-pathnames? @var{obj}
Return @true{} if @var{obj} is a proper list of pathnames according to
@func{file-pathname?}, @func{file-string-pathname?},
@func{file-bytevector-pathname?}.
@end defun


@defun split-pathname @var{pathname}
@defunx split-pathname-bytevector @var{bytevector-pathname}
@defunx split-pathname-string @var{string-pathname}
Split a file pathname into its components and return two values: a
boolean, true if the pathname starts with a slash characters; the list
of components which can be empty.

A pathname is meant to be a file or directory name with components
separated by a slash character; @var{bytevector-pathname} must be a
bytevector, @var{string-pathname} must be a Scheme string, @var{path}
must be a Scheme string or bytevector.

Empty components are discarded.

@example
#!vicare
(import (vicare))

(split-pathname-bytevector '#vu8())
@error{} "invalid pathname"

(split-pathname-bytevector '#ve(ascii "ciao/hello"))
@result{} #f (#ve(ascii "ciao") #ve(ascii "hello"))

(split-pathname-bytevector '#ve(ascii "////"))
@result{} #t ()

(split-pathname-string "")
@error{} "invalid pathname"

(split-pathname-string "ciao/hello/salut")
@result{} #f ("ciao" "hello" "salut")

(split-pathname-string "////")
@result{} #t ()

(split-pathname "ciao/hello/salut")
@result{} #f ("ciao" "hello" "salut")

(split-pathname '#ve(ascii "/ciao/hello/salut"))
@result{} #t (#ve(ascii "ciao") #ve(ascii "hello") #ve(ascii "salut"))
@end example
@end defun


@defun search-file-in-environment-path @var{pathname} @var{environment-variable}
Search a file pathname (regular file or directory) in the given search
path.

@var{pathname} must be a string representing a file pathname;
@var{environment-variable} must be a string representing a system
environment variable.

@itemize
@item
If @var{pathname} is absolute, test its existence: when found, return a
string representing the real absolute file pathname; otherwise return
@false{}.

@item
If @var{pathname} is relative and it has a directory part, test its
existence: when found, return a string representing the real absolute
file pathname; otherwise return @false{}.

@item
If @var{pathname} is relative and it has no directory part, read the
environment variable as colon--separated list of directories and search
the file in them, from the first to the last: when found, return a
string representing the real absolute file pathname; otherwise return
@false{}.

Notice that the file is searched in the process' current working
directory only if such directory is listed in the given path.
@end itemize
@end defun


@defun search-file-in-list-path @var{pathname} @var{list-of-directories}
Search a file pathname (regular file or directory) in the given search
path.

@var{pathname} must be a string representing a file pathname;
@var{list-of-directories} must be a list of strings representing
directory pathnames.

@itemize
@item
If @var{pathname} is absolute, test its existence: when found, return a
string representing the real absolute file pathname; otherwise return
@false{}.

@item
If @var{pathname} is relative and it has a directory part, test its
existence: when found, return a string representing the real absolute
file pathname; otherwise return @false{}.

@item
If @var{pathname} is relative and it has no directory part, search the
file in the given directories, from the first to the last: when found,
return a string representing the real absolute file pathname; otherwise
return @false{}.

Notice that the file is searched in the process' current working
directory only if such directory is listed in the given path.
@end itemize
@end defun

@c page
@node iklib io codecs
@subsection Transcoders and additional codecs


The following bindings are exported by the @library{vicare} library.


@defun transcoder? @var{obj}
Return @true{} if @var{obj} is a transcoder, else return @false{}.
@end defun


@deffn Parameter native-transcoder
@findex open-input-file
@findex with-input-from-file
@findex call-with-input-file
@findex open-output-file
@findex with-output-to-file
@findex call-with-output-file
The function @func{native-transcoder} defined by @rnrs{6} returns a
transcoder representing acceptable defaults for the platform on which
the Scheme implementation is running.  Under @value{PRJNAME} such
default is:

@example
(make-transcoder (utf-8-codec) 'none 'replace)
@end example

@noindent
and additionally the function is a parameter, so the default can be
configured.  Notice that the following functions create Scheme ports
using the transcoder returned by @func{native-transcoder}:

@example
open-input-file         open-output-file
with-input-from-file    with-output-to-file
call-with-input-file    call-with-output-file
@end example
@end deffn


The codec returned by @func{utf-16-codec}, defined by @rnrs{6}, has
different semantics depending upon the type of the port:

@itemize
@item
For output and input/output ports it defaults to @utf{}-16 big endian
(which seems mandated by the Unicode Consortium).

@item
For input ports the endianness is left unspecified until the first bytes
are read: such bytes must be a valid @utf{}-16 Byte Order Mark which
dynamically configures the port.@footnote{The big endian @acronym{BOM}
for @utf{}-16 is the sequence of bytes @code{#xFE #xFF}; the little
endian @acronym{BOM} for @utf{}-16 is the sequence of bytes @code{#xFF
#xFE}.}
@end itemize


@deffn Procedure utf-16le-codec
@deffnx Procedure utf-16be-codec
Codecs for the @utf{}-16 encoding schemes, little endian and big endian.
A call to any of these procedures returns a value that is equal in the
sense of @func{eqv?} to the result of any other call to the same
procedure.
@end deffn


@deffn Procedure utf-16n-codec
Return a codec for the @utf{}-16 encoding scheme, with endianness equal
to the one returned by @func{(native-endianness)}.  A call to this
procedure returns a value that is equal in the sense of @func{eqv?} to
the result of any other call to the same procedure.
@end deffn


@deffn Procedure utf-bom-codec
Codec for @utf{} encoding schemes whose data open with a Byte Order
Mark.  A call to this procedure returns a value that is equal in the
sense of @func{eqv?} to the result of any other call to the same
procedure.

At present this codec is supported only by input ports.
@end deffn

@c page
@node iklib io non-blocking
@subsection Handling non--blocking devices


@cindex Non--blocking mode, input/output ports
@cindex Input/output ports in non--blocking mode
@cindex Would--block object
@cindex Unique objects, would--block object


@rnrs{6} defines the input operations on Scheme ports as properly
blocking when no input data is available; this is fine when the
underlying device is configured in blocking mode.  @value{PRJNAME}
extends the Scheme input/output ports to support underlying devices
configured in non--blocking mode; such ports are typically the ones
whose underlying device is a @posix{} file or socket descriptor.

The implementation of Scheme ports read from the underlying device
through a function @func{read!}; if the device is configured in
non--blocking mode: @func{read!} might raise an exception with condition
object type @condition{i/o-eagain}, which means: there are no available
bytes, but this is not the end--of--file.  This scenario corresponds to
the case in which a @posix{} function fails with @code{errno} set to
@code{EAGAIN} or @code{EWOULDBLOCK}.

The functions extended by @value{PRJNAME} behave as described in this
section.  The extended behaviour is disabled when running with the
command line @option{--strict-r6rs}: in this case the port will block as
mandated by @rnrs{6}.

@menu
* iklib io non-blocking object::  The would--block object.
* iklib io non-blocking mode::    Ports and non-blocking mode.
* iklib io non-blocking binary::  Extended binary input functions.
* iklib io non-blocking textual:: Extended textual input functions.
@end menu

@c page
@node iklib io non-blocking object
@subsubsection The would--block object


@defun would-block-object
Return a unique object representing the condition ``no bytes, not EOF''
on a device configured in non--blocking mode.  The would--block object
can be compared with @func{eq?}.
@end defun


@defun would-block-object? @var{obj}
Return @true{} if @var{obj} is the would--block object, else return
@false{}.
@end defun

@c page
@node iklib io non-blocking mode
@subsubsection Ports and non-blocking mode


@defun port-set-non-blocking-mode! @var{port}
Set non--blocking mode for @var{port}; if successful return unspecified
values, if an error occurs raise an exception.  @var{port} must have a
file descriptor as underlying device.
@end defun


@defun port-unset-non-blocking-mode! @var{port}
Unset non--blocking mode for @var{port}; if successful return
unspecified values, if an error occurs raise an exception.  @var{port}
must have a file descriptor as underlying device.
@end defun


@defun port-in-non-blocking-mode? @var{port}
Query @var{port} for its non--blocking mode; if successful: return
@true{} if the port is in non--blocking mode, @false{} otherwise.  If an
error occurs: raise an exception.

@var{port} can be any Scheme port: this function will recognise
non-blocking mode only for ports having a file descriptor as underlying
device; for all the other ports the return value is @false{}.
@end defun

@c page
@node iklib io non-blocking binary
@subsubsection Extended binary input functions


@defun get-u8 @var{port}
Return the @eof{} object, the would--block object or a fixnum:

@itemize
@item
If a byte is available: return the byte as an octet and update
@var{port} to point just past that byte.

@item
If no input byte is seen before an end of file is reached: the @eof{}
object is returned.

@item
If the underlying device is in non--blocking mode and no bytes are
available: return the would--block object.
@end itemize
@end defun


@defun lookahead-u8 @var{port}
Like GET-U8, but it does not update @var{PORT} to point past the byte.
@end defun


@defun get-bytevector-n @var{port} @var{count}
Return the @eof{} object, the would--block object or a bytevector:

@itemize
@item
If @var{count} bytes are available before an end of file: return a
bytevector of size @var{count}.  The input port is updated to point just
past the bytes read.

@item
If fewer than @var{count} bytes are available before an end of file:
return a bytevector containing those bytes.  The input port is updated
to point just past the bytes read.

@item
If an end of file is reached before any bytes are available: return the
@eof{} object.

@item
If the underlying device is in non--blocking mode and fewer than
@var{count} bytes are available: return a bytevector containing those
bytes.  The input port is updated to point just past the bytes read.

@item
If the underlying device is in non--blocking mode and no bytes are
available: return the would--block object.
@end itemize
@end defun


@defun get-bytevector-n! @var{port} @var{dst.bv} @var{dst.start} @var{count}
Return the @eof{} object, the would--block object or the number of bytes
written in the given bytevector:

@itemize
@item
If @var{count} bytes are available before the end of file: they are
written into @var{dst.bv} starting at index @var{dst.start}, and the
result is @var{count}.  The input port is updated to point just past the
bytes read.

@item
If fewer than @var{count} bytes are available before the end of file:
the available bytes are written into @var{dst.bv} starting at index
@var{dst.start}, and the result is a number object representing the
number of bytes actually read.  The input port is updated to point just
past the bytes read.

@item
If the end of file is reached before any bytes are available: return the
@eof{} object.

@item
If the underlying device is in non--blocking mode and fewer than
@var{count} bytes are available: the available bytes are written into
@var{dst.bv} starting at index @var{dst.start}, and the result is a
number object representing the number of bytes actually read.  The input
port is updated to point just past the bytes read.

@item
If the underlying device is in non--blocking mode and no bytes are
available: return the would--block object.
@end itemize
@end defun


@defun get-bytevector-some @var{port}
Return the @eof{} object, the would--block object or a bytevector:

@itemize
@item
If bytes are available: return a freshly allocated bytevector containing
the initial available bytes (at least one), and update @var{port} to
point just past these bytes.

@item
If no input bytes are seen before an end of file is reached: the @eof{}
object is returned.

@item
If the underlying device is in non--blocking mode and no bytes are
available: return the would--block object.
@end itemize
@end defun

@c page
@node iklib io non-blocking textual
@subsubsection Extended textual input functions


@defun get-char @var{port}
Return the @eof{} object, the would--block object or a character:

@itemize
@item
If a complete character is available before the next end of file: return
that character and update the input port to point past the character.

@item
If an end of file is reached before any character is read: return the
@eof{} object.

@item
If the underlying device is in non--blocking mode and no full character
is available: return the would--block object.
@end itemize
@end defun


@defun read-char
@defunx read-char @var{port}
Like @func{get-char}.
@end defun


@defun lookahead-char @var{port}
Like @func{get-char}, but it does not update @var{port} to point past
the character.
@end defun


@defun peek-char
@defunx peek-char @var{port}
Like @func{lookahead-char}.
@end defun


@defun get-string-n @var{port} @var{requested-count}
Return the @eof{} object, the would--block object or a string and update
the input port to point past the consumed characters:

@itemize
@item
If @var{requested-count} characters are available before end of file:
return a string consisting of those @var{requested-count} characters.

@item
If fewer than @var{requested-count} characters are available before an
end of file, but one or more characters can be read: return a string
containing those characters.

@item
If no characters can be read before an end of file: return the @eof{}
object.

@item
If the underlying device is in non--blocking mode and no characters are
available: return the would--block object.
@end itemize
@end defun


@defun get-string-n! @var{port} @var{dst.str} @var{dst.start} @var{count}
Return the @eof{} object, the would--block object or a string and update
the input port to point past the consumed characters:

@itemize
@item
If @var{count} characters are available before an end of file: they are
written into @var{DST.STR} starting at index @var{DST.START}, and
@var{count} is returned.

@item
If fewer than @var{count} characters are available before an end of
file, but one or more can be read: those characters are written into
@var{dst.str} starting at index @var{dst.start} and the number of
characters actually read is returned as an exact integer object.

@item
If no characters can be read before an end of file: the @eof{} object is
returned.

@item
If the underlying device is in non--blocking mode and fewer than
@var{count} characters are available before a would--block condition,
but one or more can be read: those characters are written into
@var{dst.str} starting at index @var{dst.start} and the number of
characters actually read is returned as an exact integer object.

@item
If the underlying device is in non--blocking mode and no characters are
available: return the would--block object.
@end itemize
@end defun


@defun get-string-all @var{port}
Return the @eof{} object or a string and update the input port to point
past the consumed characters:

@itemize
@item
If characters are available before the end of file: a string containing
all the characters decoded from that data is returned.  Further reading
from the port will return the @eof{} object.

@item
If no character precedes the end of file: the @eof{} object is returned.
@end itemize

Even when the underlying device is in non--blocking mode: this function
attempts to read input until the @eof{} is found.
@end defun


@defun get-string-some @var{port}
Return the @eof{} object, the would--block object or a string and update
the input port to point past the consumed characters:

@itemize
@item
If characters become available before the end of file: return a freshly
allocated string containing the initial available characters (at least
one), and update @var{port} to point just past these characters.

@item
If no input characters are available before the end of file: the @eof{}
object is returned.

@item
If no input characters are available before a would--block condition:
the would--block object is returned.
@end itemize
@end defun

@c page
@node iklib io binary
@subsection Additional binary port features


The following bindings are exported by the @library{vicare} library.


@defun binary-input-port? @var{obj}
@defunx binary-output-port? @var{obj}
@defunx binary-input/output-port? @var{obj}
Return @true{} if @var{obj} is a binary port and, respectively, it is
input, output or input/output.
@end defun


@defun lookahead-two-u8 @var{port}
Like @func{lookahead-u8} but peeks at @math{2} octets and return two
values: the @eof{} object, the would--block object or a fixnum
representing first octet; the @eof{} object, the would--block object or
a fixnum representing the second octet.
@end defun


@deffn Parameter current-input-port
@deffnx Parameter current-output-port
@deffnx Parameter current-error-port
These are like defined by @rnrs{6}, but in addition they are parameters.
@end deffn


@defun console-input-port
@defunx console-input-port @var{textual-input-port}
Return the default textual input port: the default value of the
parameter @func{current-input-port}; each call returns the same port.
When the readline interface is not used, this port is used by the
@repl{} and the debugger.

When applied to an argument: the argument must be a textual input port
which replaces the old value; the old port is left untouched (it is not
closed).  When selecting a new console input port: the same port should
be used as top value for the parameter @func{current-input-port}.
@end defun


@defun console-output-port
@defunx console-output-port @var{textual-output-port}
Return the default textual output port: the default value of the
parameter @func{current-output-port}; each call returns the same port.
This port is used by the @repl{} and the debugger.

When applied to an argument: the argument must be a textual output port
which replaces the old value; the old port is left untouched (it is not
closed).  When selecting a new console output port: the same port should
be used as top value for the parameter @func{current-output-port}.
@end defun


@defun console-error-port
@defunx console-error-port @var{textual-output-port}
Return the default textual error port: the default value of the
parameter @func{current-input-port}; each call returns the same port.

When applied to an argument: the argument must be a textual output port
and it replaces the old value; the old port is left untouched (it is not
closed).  When selecting a new console error port: the same port should
be used as top value for the parameter @func{current-error-port}.
@end defun


@defvr Constant stdin
@defvrx Constant stdout
@defvrx Constant stderr
Bound to the values returned by @func{console-input-port},
@func{console-output-port}, @func{console-error-port} respectively.
@end defvr


@defun make-binary-file-descriptor-input-port @var{fd} @var{identifier}
@defunx make-binary-file-descriptor-output-port @var{fd} @var{identifier}
@defunx make-binary-file-descriptor-input/output-port @var{fd} @var{identifier}
Build and return binary Scheme ports using the platform file descriptor
@var{fd} as device.  @var{identifier} must be a string used for better
error reporting.  Closing the Scheme ports will close the file
descriptors too.

File descriptor ports do support port position operations.
@end defun


@defun make-binary-file-descriptor-input-port* @var{fd} @var{identifier}
@defunx make-binary-file-descriptor-output-port* @var{fd} @var{identifier}
@defunx make-binary-file-descriptor-input/output-port* @var{fd} @var{identifier}
Build and return binary Scheme ports using the platform file descriptor
@var{fd} as device.  @var{identifier} must be a string used for better
error reporting.  Closing the Scheme ports will @strong{not} close the
file descriptors.

File descriptor ports do support port position operations.
@end defun


@defun make-binary-socket-input-port @var{sock} @var{identifier}
@defunx make-binary-socket-output-port @var{sock} @var{identifier}
@defunx make-binary-socket-input/output-port @var{sock} @var{identifier}
Build and return a binary Scheme port using the platform socket
descriptor @var{sock} as device.  @var{identifier} must be a string used
for better error reporting.  Closing the Scheme port will close the
socket descriptor too.

Socket ports do @strong{not} support port position operations.
@end defun


@defun make-binary-socket-input-port* @var{sock} @var{identifier}
@defunx make-binary-socket-output-port* @var{sock} @var{identifier}
@defunx make-binary-socket-input/output-port* @var{sock} @var{identifier}
Build and return a binary Scheme port using the platform socket
descriptor @var{sock} as device.  @var{identifier} must be a string used
for better error reporting.  Closing the Scheme port will @strong{not}
close the socket descriptor.

Socket ports do @strong{not} support port position operations.
@end defun

@c page
@node iklib io textual
@subsection Additional textual port features


The following bindings are exported by the @library{vicare} library.


@defun textual-input-port? @var{obj}
@defunx textual-output-port? @var{obj}
@defunx textual-input/output-port? @var{obj}
Return @true{} if @var{obj} is a textual port and, respectively, it is
input, output or input/output.
@end defun


@defun open-string-input-port @var{string}
@defunx open-string-input-port @var{string} @var{eol-style}
As defined by @rnrs{6}: return a textual input port whose characters are
drawn from @var{string}.  When @var{eol-style} is given: it must be a
symbol selecting an end--of--line style conversion, as accepted by
@func{eol-style}; such conversion is applied to the characters drawn
from @var{string}.

If @var{string} is modified after @func{open-string-input-port} has been
called, the effect on the returned port is unspecified.
@end defun


@defun open-string-input-port/id @var{string} @var{id}
@defunx open-string-input-port/id @var{string} @var{id} @var{eol-style}
Like @func{open-string-input-port} but allows the specification of a
customised port identifier @var{id}, which must be a Scheme string.
@end defun


@defun open-string-output-port
@defunx open-string-output-port @var{eol-style}
As defined by @rnrs{6}, return two values: a textual output port and an
extraction procedure; the output port accumulates the characters written
to it for later extraction by the procedure.

As a @value{PRJNAME} extension, when @var{eol-style} is given: it must
be a symbol selecting an end--of--line style conversion, as accepted by
@func{eol-style}; such conversion is applied to the characters written
to the port.
@end defun


@defun get-output-string @var{port}
Return the string accumulated in the @var{port} opened by
@func{open-string-output-port}.  This function can be called also when
the port has been closed.
@end defun


@defun get-char-and-track-textual-position @var{port}
Like @func{get-char} but track the textual position.  Recognise only
linefeed characters as line-ending.
@end defun


@defun port-textual-position @var{port}
Given a textual port, return the current textual position as a condition
object of type @condition{source-position}.
@end defun


@defun make-textual-file-descriptor-input-port @var{fd} @var{identifier} @var{transcoder}
@defunx make-textual-file-descriptor-output-port @var{fd} @var{identifier} @var{transcoder}
@defunx make-textual-file-descriptor-input/output-port @var{fd} @var{identifier} @var{transcoder}
Build and return textual Scheme ports using the platform file descriptor
@var{fd} as device.  @var{identifier} must be a string used for better
error reporting.  @var{transcoder} must be a transcoder object.  Closing
the Scheme ports will close the file descriptors too.

File descriptor ports do support port position operations.
@end defun


@defun make-textual-file-descriptor-input-port* @var{fd} @var{identifier} @var{transcoder}
@defunx make-textual-file-descriptor-output-port* @var{fd} @var{identifier} @var{transcoder}
@defunx make-textual-file-descriptor-input/output-port* @var{fd} @var{identifier} @var{transcoder}
Build and return textual Scheme ports using the platform file descriptor
@var{fd} as device.  @var{identifier} must be a string used for better
error reporting.  @var{transcoder} must be a transcoder object.  Closing
the Scheme ports will @strong{not} close the file descriptors.

File descriptor ports do support port position operations.
@end defun


@defun make-textual-socket-input/output-port @var{sock} @var{identifier} @var{transcoder}
Build and return a textual Scheme port using the platform socket
descriptor @var{sock} as device.  @var{identifier} must be a string used
for better error reporting.  @var{transcoder} must be a transcoder
object.  Closing the Scheme port will close the socket descriptor too.

Socket ports do @strong{not} support port position operations.
@end defun


@defun make-textual-socket-input/output-port* @var{sock} @var{identifier} @var{transcoder}
Build and return a textual Scheme port using the platform socket
descriptor @var{sock} as device.  @var{identifier} must be a string used
for better error reporting.  @var{transcoder} must be a transcoder
object.  Closing the Scheme port will @strong{not} close the socket
descriptor.

Socket ports do @strong{not} support port position operations.
@end defun


@defun read-line
@defunx read-line @var{port}
Read from the textual input @var{port} up to and including the linefeed
character or end of file, decoding characters in the same manner as
@func{get-string-n} and @func{get-string-n!}.  This function is exactly
like @func{get-line}, defined by @rsixlibrary{io ports}, but it uses the
return value of @func{current-input-port} if no @var{port} argument is
used.
@end defun


@defun get-string-some @var{port}
Defined by Vicare.  Read from the textual input @var{port}, blocking as
necessary, until characters are available or until an end of file is
reached.

If characters become available, @func{get-string-some} returns a freshly
allocated string containing the initial available characters (at least
one), and it updates @var{port} to point just past these characters.

If no input characters are available: the EOF object is returned.
@end defun

@c page
@node iklib io buffer
@subsection Buffer size customisation


The following bindings are exported by the @library{vicare} library.


@deffn Parameter bytevector-port-buffer-size
@deffnx Parameter bytevector-port-buffer-size @var{fixnum}
Hold the buffer size for bytevector ports, like the one returned by
@func{open-bytevector-output-port}.  It is initialised to @math{16384}.
@end deffn


@deffn Parameter string-port-buffer-size
@deffnx Parameter string-port-buffer-size @var{fixnum}
Hold the buffer size for string ports, like the one returned by
@func{open-string-output-port}.  It is initialised to @math{256}.
@end deffn


@deffn Parameter input-file-buffer-size
@deffnx Parameter input-file-buffer-size @var{fixnum}
Hold the buffer size for input file ports, like the one returned by
@func{open-input-file}.  It is initialised to @math{16384}.
@end deffn


@deffn Parameter output-file-buffer-size
@deffnx Parameter output-file-buffer-size @var{fixnum}
Hold the buffer size for output file ports, like the one returned by
@func{open-output-file}.  It is initialised to @math{16384}.
@end deffn


@deffn Parameter input/output-file-buffer-size
@deffnx Parameter input/output-file-buffer-size @var{fixnum}
Hold the buffer size for input/output file ports, like the one returned
by @func{open-file-input/output-prot}.  It is initialised to
@math{16384}.
@end deffn


@deffn Parameter input/output-socket-buffer-size
@deffnx Parameter input/output-socket-buffer-size @var{fixnum}
Hold the buffer size for socket ports.  It is initialised to
@math{16384}.
@end deffn

@c page
@node iklib io plists
@subsection Port property lists


Port property work like symbol property lists; they are a simple way to
tag I/O ports with values.


@defun port-putprop @var{port} @var{key} @var{value}
Add a new property @var{key} with @var{value} to the property list of
@var{port}.  If @var{key} is already set: the old entry is mutated to
reference @var{value}.  @var{key} must be a symbol.
@end defun


@defun port-getprop @var{port} @var{key}
Return the value of the property @var{key} in the property list of
@var{port}; if @var{key} is not set return @false{}.  @var{key} must be
a symbol.
@end defun


@defun port-remprop @var{port} @var{key}
Remove the property @var{key} from the property list of @var{port}.
@var{key} must be a symbol.
@end defun


@defun port-property-list @var{port}
Return a new association list representing the property list of
@var{port}.
@end defun

@c page
@node iklib io misc
@subsection Miscellaneous port functions


The following bindings are exported by the @library{vicare} library.


@defun input/output-port? @var{port}
Return a boolean, @true{} if @var{port} is an input and output port.
@end defun


@defun port-fd @var{port}
If @var{port} is a port with a file descriptor as device: return a
fixnum representing the device, else return @false{}.
@end defun


@defun port-id @var{port}
Return a Scheme string representing the identifier of @var{port}.
@end defun


@defun port-uid @var{port}
Return a gensym uniquely associated to @var{port}.  The gensym is
generated the first time this function is applied to @var{port}.
@end defun


@defun port-hash @var{port}
Return a fixnum associated to @var{port} to be used as hash key.  The
gensym is generated the first time this function is applied to
@var{port}.
@end defun


@defun port-closed? @var{port}
Return @true{} if @var{port} has already been closed, else return
@false{}.
@end defun


@defun set-port-buffer-mode! @var{port} @var{buffer-mode}
Reset the port buffer mode to @var{buffer-mode}, which must be one of
the arguments accepted by @func{buffer-mode}.  It is an error to select
@code{line} mode if @var{port} is a binary port.
@end defun


@defun port-dump-status @var{port}
To be used for debugging purposes.  Write to the current error port some
informations on the internals of @var{port}.
@end defun


@deffn Syntax file-options @meta{file-options-symbol} @dots{}
As defined by @rnrs{6}: return a file--options object that encapsulates
the specified options.  Each @meta{file-options-symbol} must be a
symbol.

@value{PRJNAME} extends the standard options adding the following:

@table @code
@item executable
Open the file with executable permissions; before the process' file mode
creation mask is applied, executable permissions are granted to user,
group and others.  @manpage{umask, Set file mode creation mask}.
@end table
@end deffn

@c page
@node iklib pointers
@section Handling pointer objects


@menu
* iklib pointers objects::      Handling pointer values.
* iklib pointers poke::         Poking values.
* iklib pointers peek::         Peeking values.
* iklib arrays poke::           Poking values into arrays.
* iklib arrays peek::           Peeking values from arrays.
@end menu

@c page
@node iklib pointers objects
@subsection Handling pointer values


Pointer objects are a disjoint type identified by the @func{pointer?}
predicate.  When applied to pointer objects:

@itemize
@item
The result of calling @func{eq?} is true only if the two arguments are
both pointers and they refer to the same Scheme storage location.

@item
The result of calling @func{eqv?} and @func{equal?} is true only if the
two arguments are both pointers and they reference the same raw memory
location.
@end itemize

@noindent
pointers also have @func{pointer=?} as specialised comparison predicate.

The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.


@defun pointer? @var{obj}
Return @true{} if @var{obj} is a pointer object, return @false{}
otherwise.
@end defun


@defun pointer->integer @var{pointer}
Convert the value of @var{pointer} to an exact integer value.  The
result may be a fixnum or a bignum depending on the pointer.
@end defun


@defun integer->pointer @var{exact-integer}
Convert @var{exact-integer} to a pointer value.  The argument must be
non--negative and in the appropriate range for 32-bit or 64-bit
platforms.  It is guaranteed that:

@example
(integer->pointer (pointer->integer p))
@end example

@noindent
points to the same address as @var{p}.
@end defun


@defun null-pointer
Return a newly allocated pointer object representing @cnull{}.
@end defun


@defun pointer-null? @var{obj}
Return true if @var{obj} is a pointer object and it represents @cnull{}.
@end defun


@defun set-pointer-null! @var{pointer}
Mutate the pointer object @var{pointer} to represent the @cnull{}
pointer.
@end defun


@defun pointer-diff @vari{ptr} @varii{ptr}
Return an exact integer representing the difference between the two
pointer objects @vari{ptr} and @varii{ptr}.  The returned value is such
that:

@example
(pointer=? P (pointer-add Q (pointer-diff P Q)))
@result{} #t
@end example
@end defun


@defun pointer-add @var{ptr} @var{diff}
Return a new pointer object holding the memory reference resulting from
adding @var{diff}, which must be an exact integer, to @var{ptr}.  If the
addition would cause an overflow or underflow in machine words: raise an
assertion violation.
@end defun


@defun pointer-and-offset? @var{ptr} @var{diff}
Return true if the exact integer @var{diff} can be added to @var{ptr}
without causing a pointer overflow or underflow.
@end defun


@defun pointer=? @vari{ptr} @varii{ptr}
@defunx pointer!=? @vari{ptr} @varii{ptr}
@defunx pointer<? @vari{ptr} @varii{ptr}
@defunx pointer>? @vari{ptr} @varii{ptr}
@defunx pointer<=? @vari{ptr} @varii{ptr}
@defunx pointer>=? @vari{ptr} @varii{ptr}
Comparison functions for pointers.  Return @true{} if the arguments
satisfy the predicate, else return @false{}.
@end defun


@defun pointer-clone @var{pointer}
Return a new pointer object being a copy of @var{pointer}.  This is
useful when we need a pointer that might be reset to another value in
the future.
@end defun

@c page
@node iklib pointers poke
@subsection Poking values


With all the following functions: the @var{memory} argument must be a
valid pointer object or @code{memory-block} instance; the @var{offset}
argument must be an exact integer in the range of the C language type
@code{ptrdiff_t}.  When adding an offset to a pointer: all the following
functions @strong{do not} scale the offset to the size of the poked
value; pointer arithmetics is performed with byte offsets.

The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.

@macro bitpoker{BYTENUM,BITNUM}
Set to @var{value} the \BYTENUM\ of memory located at @var{offset} from
@var{memory}.  @var{VALUE} must be an exact integer in the range
representable by \BITNUM\ bits.
@end macro

@macro cpoker{TYPE}
Set to @var{value} a number of bytes corresponding to the @code{signed
\TYPE\} or @code{unsigned \TYPE\} type located at @var{offset} from
@var{memory}.
@end macro

@c ------------------------------------------------------------

@subsubheading Poking bitwise sized exact integers

The following functions store signed and unsigned exact integers in raw
memory location selecting the size with the number of bits required to
represent the value.


@defun pointer-set-c-sint8! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-uint8! @var{memory} @var{offset} @var{value}
@bitpoker{single byte,8}
@end defun


@defun pointer-set-c-sint16! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-uint16! @var{memory} @var{offset} @var{value}
@bitpoker{two bytes,16}
@end defun


@defun pointer-set-c-sint32! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-uint32! @var{memory} @var{offset} @var{value}
@bitpoker{four bytes,32}
@end defun


@defun pointer-set-c-sint64! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-uint64! @var{memory} @var{offset} @var{value}
@bitpoker{eigth bytes,64}
@end defun

@c ------------------------------------------------------------

@subsubheading Poking C language exact integers

The following functions store signed and unsigned exact integers in raw
memory locations selecting the size according to the one used by the C
language implementation.


@defun pointer-set-c-signed-char! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-unsigned-char! @var{memory} @var{offset} @var{value}
@cpoker{char}
@end defun


@defun pointer-set-c-signed-short! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-unsigned-short! @var{memory} @var{offset} @var{value}
@cpoker{short int}
@end defun


@defun pointer-set-c-signed-int! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-unsigned-int! @var{memory} @var{offset} @var{value}
@cpoker{int}
@end defun



@defun pointer-set-c-signed-long! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-unsigned-long! @var{memory} @var{offset} @var{value}
@cpoker{long}
@end defun


@defun pointer-set-c-signed-long-long! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-unsigned-long-long! @var{memory} @var{offset} @var{value}
@cpoker{long long}
@end defun


@defun pointer-set-c-size_t! @var{memory} @var{offset} @var{value}
Set to @var{value} a number of bytes corresponding to the @code{size_t}
type located at @var{offset} from @var{memory}.
@end defun


@defun pointer-set-c-ssize_t! @var{memory} @var{offset} @var{value}
Set to @var{value} a number of bytes corresponding to the @code{ssize_t}
type located at @var{offset} from @var{memory}.
@end defun


@defun pointer-set-c-off_t! @var{memory} @var{offset} @var{value}
Set to @var{value} a number of bytes corresponding to the @code{off_t}
type located at @var{offset} from @var{memory}.
@end defun


@defun pointer-set-c-ptrdiff_t! @var{memory} @var{offset} @var{value}
Set to @var{value} a number of bytes corresponding to the
@code{ptrdiff_t} type located at @var{offset} from @var{memory}.
@end defun

@c ------------------------------------------------------------

@subsubheading Poking floating point numbers


@defun pointer-set-c-float! @var{memory} @var{offset} @var{flonum}
Convert the Scheme floating point number @var{flonum} (represented in
@value{PRJNAME} as an @ieee{} 754 double precision floating point number) to a
float (an @ieee{} 754 single precision floating point number) and store
the result in the four bytes at @var{offset} from @var{memory}.
@end defun


@defun pointer-set-c-double! @var{memory} @var{offset} @var{flonum}
Store the double precision @ieee{} 754 floating point value of the
Scheme @var{flonum} in the eight bytes at @var{offset} from
@var{memory}.
@end defun


@c ------------------------------------------------------------

@subsubheading Poking pointers


@defun pointer-set-c-pointer! @var{memory} @var{offset} @var{value}
Store address of the raw memory location referenced by the pointer
@var{value} at @var{offset} from @var{memory}.
@end defun

@c page
@node iklib pointers peek
@subsection Peeking values


With all the following functions: the @var{memory} argument must be a
valid pointer object; the @var{offset} argument must be an exact integer
in the range of the C language type @code{ptrdiff_t}.  When adding an
offset to a pointer: all the following functions @strong{do not} scale
the offset to the size of the peeked value; pointer arithmetics is
performed with byte offsets.

The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.

@macro bitpeeker{BITNUM}
Peek the \BITNUM\ bits located at @var{offset} from @var{memory} and
return them as signed or unsigned exact integer.
@end macro

@macro cpeeker{TYPE}
Peek the @code{signed \TYPE\} or @code{unsigned \TYPE\} integer located
at @var{offset} from @var{memory} and return it as signed or unsigned
exact integer.
@end macro

@c ------------------------------------------------------------

@subsubheading Peeking bitwise sized exact integers

The following functions retrieve signed and unsigned exact integers from
raw memory location selecting the size with the number of bits required
to represent the value.


@defun pointer-ref-c-sint8 @var{memory} @var{offset}
@defunx pointer-ref-c-uint8 @var{memory} @var{offset}
@bitpeeker{8}
@end defun


@defun pointer-ref-c-sint16 @var{memory} @var{offset}
@defunx pointer-ref-c-uint16 @var{memory} @var{offset}
@bitpeeker{16}
@end defun


@defun pointer-ref-c-sint32 @var{memory} @var{offset}
@defunx pointer-ref-c-uint32 @var{memory} @var{offset}
@bitpeeker{32}
@end defun


@defun pointer-ref-c-sint64 @var{memory} @var{offset}
@defunx pointer-ref-c-uint64 @var{memory} @var{offset}
@bitpeeker{64}
@end defun

@c ------------------------------------------------------------

@subsubheading Peeking C language exact integers

The following functions store signed and unsigned exact integers from
raw memory locations selecting the size according to the one used by the
C language implementation.


@defun pointer-ref-c-signed-char @var{memory} @var{offset}
@defunx pointer-ref-c-signed-char @var{memory} @var{offset}
@cpeeker{char}
@end defun


@defun pointer-ref-c-signed-short @var{memory} @var{offset}
@defunx pointer-ref-c-unsigned-short @var{memory} @var{offset}
@cpeeker{short int}
@end defun


@defun pointer-ref-c-signed-int @var{memory} @var{offset}
@defunx pointer-ref-c-unsigned-int @var{memory} @var{offset}
@cpeeker{int}
@end defun


@defun pointer-ref-c-signed-long @var{memory} @var{offset}
@defunx pointer-ref-c-unsigned-long @var{memory} @var{offset}
@cpeeker{long}
@end defun


@defun pointer-ref-c-signed-long-long @var{memory} @var{offset}
@defunx pointer-ref-c-unsigned-long-long @var{memory} @var{offset}
@cpeeker{long long}
@end defun


@defun pointer-ref-c-size_t @var{memory} @var{offset}
Peek the @code{size_t} integer located at @var{offset} from @var{memory}
and return it as exact integer.
@end defun


@defun pointer-ref-c-ssize_t @var{memory} @var{offset}
Peek the @code{ssize_t} integer located at @var{offset} from @var{memory}
and return it as exact integer.
@end defun


@defun pointer-ref-c-off_t @var{memory} @var{offset}
Peek the @code{off_t} integer located at @var{offset} from @var{memory}
and return it as exact integer.
@end defun


@defun pointer-ref-c-ptrdiff_t @var{memory} @var{offset}
Peek the @code{ptrdiff_t} integer located at @var{offset} from
@var{memory} and return it as exact integer.
@end defun

@c ------------------------------------------------------------

@subsubheading Peeking floating point numbers


@defun pointer-ref-c-float @var{memory} @var{offset}
Return the four--byte float (represented as @ieee{} 754 single precision
floating point number) stored at @var{offset} from @var{memory}.  The
value is extended to an @ieee{} 754 double precision floating point
number that @value{PRJNAME} uses to represent inexact numbers.
@end defun


@defun pointer-ref-c-double @var{memory} @var{offset}
Return the eight--byte float (represented as @ieee{} 754 double
precision floating point number) stored at @var{offset} from
@var{memory}.
@end defun

@c ------------------------------------------------------------

@subsubheading Peeking pointers


@defun pointer-ref-c-pointer @var{memory} @var{offset}
Return the pointer stored at @var{offset} from @var{memory}.  The size
of the pointer (also the number of bytes loaded) depends on the
architecture: it is 4 bytes on 32-bit systems and 8 bytes on 64-bit
systems.
@end defun

@c page
@node iklib arrays poke
@subsection Poking values into arrays


With all the following functions: the @var{memory} argument must be a
valid pointer object or @code{memory-block} instance; the @var{index}
argument must be an exact integer in the range of the C language type
@code{ptrdiff_t}.  When adding an offset to a pointer: all the following
functions @strong{do} scale the index to the size of the poked value.

The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.

@macro abitpoker{BYTENUM,BITNUM}
Set to @var{value} the \BYTENUM\ of memory located at @var{index} from
@var{memory}.  @var{VALUE} must be an exact integer in the range
representable by \BITNUM\ bits.
@end macro

@macro acpoker{TYPE}
Set to @var{value} a number of bytes corresponding to the @code{signed
\TYPE\} or @code{unsigned \TYPE\} type located at @var{index} from
@var{memory}.
@end macro

@c ------------------------------------------------------------

@subsubheading Poking bitwise sized exact integers

The following functions store signed and unsigned exact integers in raw
memory location selecting the size with the number of bits required to
represent the value.


@defun array-set-c-sint8! @var{memory} @var{index} @var{value}
@defunx array-set-c-uint8! @var{memory} @var{index} @var{value}
@abitpoker{single byte,8}
@end defun


@defun array-set-c-sint16! @var{memory} @var{index} @var{value}
@defunx array-set-c-uint16! @var{memory} @var{index} @var{value}
@abitpoker{two bytes,16}
@end defun


@defun array-set-c-sint32! @var{memory} @var{index} @var{value}
@defunx array-set-c-uint32! @var{memory} @var{index} @var{value}
@abitpoker{four bytes,32}
@end defun


@defun array-set-c-sint64! @var{memory} @var{index} @var{value}
@defunx array-set-c-uint64! @var{memory} @var{index} @var{value}
@abitpoker{eight bytes,64}
@end defun

@c ------------------------------------------------------------

@subsubheading Poking C language exact integers

The following functions store signed and unsigned exact integers in raw
memory locations selecting the size according to the one used by the C
language implementation.


@defun array-set-c-signed-char! @var{memory} @var{index} @var{value}
@defunx array-set-c-unsigned-char! @var{memory} @var{index} @var{value}
@acpoker{char}
@end defun


@defun array-set-c-signed-short! @var{memory} @var{index} @var{value}
@defunx array-set-c-unsigned-short! @var{memory} @var{index} @var{value}
@acpoker{short int}
@end defun


@defun array-set-c-signed-int! @var{memory} @var{index} @var{value}
@defunx array-set-c-unsigned-int! @var{memory} @var{index} @var{value}
@acpoker{int}
@end defun


@defun array-set-c-signed-long! @var{memory} @var{index} @var{value}
@defunx array-set-c-unsigned-long! @var{memory} @var{index} @var{value}
@acpoker{long}
@end defun


@defun array-set-c-signed-long-long! @var{memory} @var{index} @var{value}
@defunx array-set-c-unsigned-long-long! @var{memory} @var{index} @var{value}
@acpoker{long long}
@end defun


@defun array-set-c-size_t! @var{memory} @var{index} @var{value}
Set to @var{value} a number of bytes corresponding to the @code{size_t}
type located at @var{index} from @var{memory}.
@end defun


@defun array-set-c-ssize_t! @var{memory} @var{index} @var{value}
Set to @var{value} a number of bytes corresponding to the @code{ssize_t}
type located at @var{index} from @var{memory}.
@end defun


@defun array-set-c-off_t! @var{memory} @var{index} @var{value}
Set to @var{value} a number of bytes corresponding to the @code{off_t}
type located at @var{index} from @var{memory}.
@end defun


@defun array-set-c-ptrdiff_t! @var{memory} @var{index} @var{value}
Set to @var{value} a number of bytes corresponding to the
@code{ptrdiff_t} type located at @var{index} from @var{memory}.
@end defun

@c ------------------------------------------------------------

@subsubheading Poking floating point numbers


@defun array-set-c-float! @var{memory} @var{index} @var{flonum}
Convert the Scheme floating point number @var{flonum} (represented in
@value{PRJNAME} as an @ieee{} 754 double precision floating point number) to a
float (an @ieee{} 754 single precision floating point number) and store
the result in the four bytes at @var{index} from @var{memory}.
@end defun


@defun array-set-c-double! @var{memory} @var{index} @var{flonum}
Store the double precision @ieee{} 754 floating point value of the
Scheme @var{flonum} in the eight bytes at @var{index} from
@var{memory}.
@end defun


@c ------------------------------------------------------------

@subsubheading Poking pointers


@defun array-set-c-pointer! @var{memory} @var{index} @var{value}
Store address of the raw memory location referenced by the pointer
@var{value} at @var{index} from @var{memory}.
@end defun

@c page
@node iklib arrays peek
@subsection Peeking values from arrays


With all the following functions: the @var{memory} argument must be a
valid pointer object; the @var{index} argument must be an exact integer
in the range of the C language type @code{ptrdiff_t}.  When adding an
offset to a pointer: all the following functions @strong{do} scale the
index to the size of the peeked value.

The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.

@macro abitpeeker{BITNUM}
Peek the \BITNUM\ bits located at @var{index} from @var{memory} and
return them as signed or unsigned exact integer.
@end macro

@macro acpeeker{TYPE}
Peek the @code{signed \TYPE\} or @code{unsigned \TYPE\} integer located
at @var{index} from @var{memory} and return it as signed or unsigned
exact integer.
@end macro

@c ------------------------------------------------------------

@subsubheading Peeking bitwise sized exact integers

The following functions retrieve signed and unsigned exact integers from
raw memory location selecting the size with the number of bits required
to represent the value.


@defun array-ref-c-sint8 @var{memory} @var{index}
@defunx array-ref-c-uint8 @var{memory} @var{index}
@abitpeeker{8}
@end defun


@defun array-ref-c-sint16 @var{memory} @var{index}
@defunx array-ref-c-uint16 @var{memory} @var{index}
@abitpeeker{16}
@end defun


@defun array-ref-c-sint32 @var{memory} @var{index}
@defunx array-ref-c-uint32 @var{memory} @var{index}
@abitpeeker{32}
@end defun


@defun array-ref-c-sint64 @var{memory} @var{index}
@defunx array-ref-c-uint64 @var{memory} @var{index}
@abitpeeker{64}
@end defun

@c ------------------------------------------------------------

@subsubheading Peeking C language exact integers

The following functions store signed and unsigned exact integers from
raw memory locations selecting the size according to the one used by the
C language implementation.


@defun array-ref-c-signed-char @var{memory} @var{index}
@defunx array-ref-c-signed-char @var{memory} @var{index}
@acpeeker{char}
@end defun


@defun array-ref-c-signed-short @var{memory} @var{index}
@defunx array-ref-c-unsigned-short @var{memory} @var{index}
@acpeeker{short int}
@end defun


@defun array-ref-c-signed-int @var{memory} @var{index}
@defunx array-ref-c-unsigned-int @var{memory} @var{index}
@acpeeker{int}
@end defun


@defun array-ref-c-signed-long @var{memory} @var{index}
@defunx array-ref-c-unsigned-long @var{memory} @var{index}
@acpeeker{long}
@end defun


@defun array-ref-c-signed-long-long @var{memory} @var{index}
@defunx array-ref-c-unsigned-long-long @var{memory} @var{index}
@acpeeker{long long}
@end defun


@defun array-ref-c-size_t @var{memory} @var{index}
Peek the @code{size_t} integer located at @var{index} from @var{memory}
and return it as signed or unsigned exact integer.
@end defun


@defun array-ref-c-ssize_t @var{memory} @var{index}
Peek the @code{ssize_t} integer located at @var{index} from @var{memory}
and return it as signed or unsigned exact integer.
@end defun


@defun array-ref-c-off_t @var{memory} @var{index}
Peek the @code{off_t} integer located at @var{index} from @var{memory}
and return it as signed or unsigned exact integer.
@end defun


@defun array-ref-c-ptrdiff_t @var{memory} @var{index}
Peek the @code{ptrdiff_t} integer located at @var{index} from
@var{memory} and return it as signed or unsigned exact integer.
@end defun

@c ------------------------------------------------------------

@subsubheading Peeking floating point numbers


@defun array-ref-c-float @var{memory} @var{index}
Return the four--byte float (represented as @ieee{} 754 single precision
floating point number) stored at @var{index} from @var{memory}.  The
value is extended to an @ieee{} 754 double precision floating point
number that @value{PRJNAME} uses to represent inexact numbers.
@end defun


@defun array-ref-c-double @var{memory} @var{index}
Return the eight--byte float (represented as @ieee{} 754 double
precision floating point number) stored at @var{index} from
@var{memory}.
@end defun

@c ------------------------------------------------------------

@subsubheading Peeking pointers


@defun array-ref-c-pointer @var{memory} @var{index}
Return the pointer stored at @var{index} from @var{memory}.  The size
of the pointer (also the number of bytes loaded) depends on the
architecture: it is 4 bytes on 32-bit systems and 8 bytes on 64-bit
systems.
@end defun

@c page
@node iklib memory
@section Memory management


@menu
* iklib memory intro::          Introduction to managing memory.
* iklib memory alloc::          Allocating and freeing memory.
* iklib memory ops::            Memory operations.
* iklib memory blocks::         Memory blocks.
* iklib memory condition::      Memory allocation condition objects.
@end menu

@c page
@node iklib memory intro
@subsection Introduction to managing memory


@value{PRJNAME} Scheme is a managed environment: Scheme objects are
allocated in a special memory region (the Scheme heap) and have
type--specific object layouts; this allows the run time system to
distinguish object types and the garbage collector to locate all
potentially live objects, and reclaim the memory of dead objects.

Scheme objects are also @emph{opaque} in the sense that the data
structures used to represent Scheme objects are not exposed, at the
Scheme level, to the programmer who can only interact with objects
through an interface.

Unmanaged environments, such as the operating system on which
@value{PRJNAME} runs, require that the programmer manages the allocation
and deallocation of system resources herself.  Memory regions, file
handles, external devices, the screen, etc., are all examples of
resources whose management must be coordinated among the different parts
of the system, and this becomes the responsibility of the programmer who
is wiring the different subsystems together.

The procedures acting on pointer objects are meant to provide a way to
interface with the low level memory operations such as setting and
getting bytes from specific locations in memory.

@c page
@node iklib memory alloc
@subsection Allocating and freeing memory


The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.


@defun malloc @var{number-of-bytes}
@defunx guarded-malloc @var{number-of-bytes}
Interface to the C function @cfunc{malloc}, @glibcref{Basic Allocation,
malloc}.  Allocate a block of memory @var{number-of-bytes} wide;
@var{number-of-bytes} must be an exact integer in the range of the C
language type @code{size_t}.  If successful return a pointer object,
else return @false{}.

Memory allocated by @func{malloc} must be released by @func{free};
memory allocated by @func{guarded-malloc} is automatically released
whenever the returned pointer object is garbage collected.
@end defun


@defun malloc* @var{number-of-bytes}
@defunx guarded-malloc* @var{number-of-bytes}
Like @func{malloc} and @func{guarded-malloc}, but if allocation fails
raise a non--continuable exception with components: @condition{who},
@condition{message}, @condition{out-of-memory-error}.
@end defun


@defun realloc @var{memory} @var{number-of-bytes}
@defunx guarded-realloc @var{memory} @var{number-of-bytes}
Interface to the C function @cfunc{realloc}, @glibcref{Changing Block
Size, realloc}.  Reallocate the block of memory referenced by
@var{memory} to the new size @var{number-of-bytes}.

@var{memory} must be a pointer object or @code{memory-block} instance.

@var{number-of-bytes} must be an exact integer in the range of the C
language type @code{size_t}.

If successful: mutate the pointer in @var{memory} to reference the new
memory block and return @var{memory} itself; when @var{memory} is a
@code{memory-block}: mutate the size field to @var{number-of-bytes}.  If
an error occurs: return @false{} and leave untouched both @var{memory}
and its referenced memory.

Memory allocated by @func{realloc} must be released by @func{free},
unless @var{memory} was already scheduled to be removed by the garbage
collector; when @func{guarded-realloc} is used:

@itemize
@item
When @var{memory} is a pointer object: the allocated memory is
automatically released whenever the returned pointer object is garbage
collected.  If @var{memory} was already scheduled to be removed by the
garbage collector: we should use @func{realloc} not
@func{guarded-realloc}.

@item
When @var{memory} is an instance of @code{memory-block}: the allocated
memory is automatically released by the garbage collector only if
@code{memory-block} was built by @func{make-memory-block/guarded}.
@end itemize
@end defun


@defun realloc* @var{pointer} @var{number-of-bytes}
@defunx guarded-realloc* @var{pointer} @var{number-of-bytes}
Like @func{realloc} and @func{guarded-realloc}, but if allocation fails
raise a non--continuable exception with components: @condition{who},
@condition{message}, @condition{out-of-memory-error}.
@end defun


@defun calloc @var{number-of-elements} @var{element-size}
@defunx guarded-calloc @var{number-of-elements} @var{element-size}
Interface to the C function @cfunc{calloc}, @glibcref{Allocating Cleared
Space, calloc}.  Allocate and clear to zero a block of memory capable of
holding @var{number-of-elements} each @var{element-size} wide; both the
arguments must be exact integers in the range of the C language type
@code{size_t}.  If successful return a pointer object, else return
@false{}.

Memory allocated by @func{calloc} must be released by @func{free};
memory allocated by @func{guarded-calloc} is automatically released
whenever the returned pointer object is garbage collected.
@end defun


@defun calloc @var{number-of-elements} @var{element-size}
@defunx guarded-calloc @var{number-of-elements} @var{element-size}
Like @func{calloc} and @func{guarded-calloc}, but if allocation fails
raise a non--continuable exception with components: @condition{who},
@condition{message}, @condition{out-of-memory-error}.
@end defun


@defun free @var{memory}
Release the memory referenced by @var{memory}, which must be either a
pointer object returned by @cfunc{malloc}, @cfunc{realloc},
@cfunc{calloc} or a similar system procedure or an instance of
@code{memory-block}.  The pointer object in @var{memory} is mutated to
reference the @cnull{} pointer; when @var{memory} is a
@code{memory-block}: the @code{size} field is also reset to zero.

If memory allocated by a guarding function is released by @func{free}:
@value{PRJNAME} will @strong{not} try to automatically release the old
memory again.

If the pointer in @var{memory} is @cnull{} nothing happens.
@end defun


@defun with-local-storage @var{lengths} @var{proc}
Call @var{proc} with arguments being pointers to memory blocks allocated
just for the dynamic extent of @var{proc}.  The number and size of the
memory blocks is determined by @var{lengths}, which must be a vector of
non--negative fixnums.

@ignore
@c This is not clear, so far letting the flow go through with an
@c exception seems to work (Marco Maggi; Dec  7, 2011)

We must not let control flow go through a call to
@func{with-local-storage} by raising an exception.  @var{proc}
@strong{must} return to the caller.
@end ignore

@strong{NOTE} We must not let control flow go through a call to
@func{with-local-storage} with an escaping continuation.

@example
#!r6rs
(import (rnrs)
  (prefix (vicare ffi) ffi.))

;; no allocated memory
(let ((a 1) (b 2))
  (ffi.with-local-storage '#()
    (lambda ()
      (+ a b 4))))
@result{} 7

;; allocate a single block of 4 bytes
(let ((a 1) (b 2))
  (ffi.with-local-storage '#(4)
    (lambda (&int32)
      (ffi.pointer-set-c-sint32! &int32 0 4)
      (+ a b (ffi.pointer-ref-c-sint32 &int32 0)))))
@result{} 7

;; allocate two blocks of 4 and 8 bytes
(let ((a 1) (b 2))
  (ffi.with-local-storage '#(4 8)
    (lambda (&int32 &int64)
      (ffi.pointer-set-c-sint32! &int32 0 4)
      (ffi.pointer-set-c-sint64! &int64 0 8)
      (+ a b
         (ffi.pointer-ref-c-sint32 &int32 0)
         (ffi.pointer-ref-c-sint64 &int64 0)))))
@result{} 15
@end example

The memory blocks are actually allocated on the stack of
@value{PRJNAME}'s runtime.
@end defun

@c page
@node iklib memory ops
@subsection Memory operations


The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.


@defun memcpy @var{dst} @var{src} @var{count}
Interface to the C function @cfunc{memcpy}, @glibcref{Copying and
Concatenation, memcpy}.  Copy @var{count} bytes from the memory
referenced by the pointer @var{src} to the memory referenced by the
pointer @var{dst}; @var{count} must be an exact integer in the range of
the C language type @code{size_t}.  The two memory regions must not
overlap.  Return unspecified values.
@end defun


@defun memmove @var{dst} @var{src} @var{count}
Interface to the C function @cfunc{memmove}, @glibcref{Copying and
Concatenation, memmove}.  Copy @var{count} bytes from the memory
referenced by the pointer @var{src} to the memory referenced by the
pointer @var{dst}; @var{count} must be an exact integer in the range of
the C language type @code{size_t}.  The two memory regions can be
overlapping.  Return unspecified values.
@end defun


@defun memset @var{ptr} @var{value} @var{count}
Interface to the C function @cfunc{memset}, @glibcref{Copying and
Concatenation, memset}.Set to @var{value} @var{count} bytes of the
memory referenced by the pointer @var{ptr}.  @var{count} must be an
exact integer in the range of the C language type @code{size_t},
@var{value} must be an exact fixnum in the range @math{[-128, 255]}.
Return unspecified values.
@end defun


@defun memcmp @vari{pointer} @varii{pointer} @var{count}
Interface to the C function @cfunc{memcmp}, @glibcref{String/Array
Comparison, memcmp}.  Compare @var{count} bytes in the memory blocks
referenced by @vari{pointer} and @varii{pointer}, return a fixnum
representing the classic comparison ternary result.  @var{count} must be
an exact integer in the range of the C language type @code{size_t}.
@end defun


@defun memory-copy dst dst.start src src.start count
Copy @var{count} bytes from @var{src} starting at offset @var{src.start}
to @var{dst} starting at offset @var{dst.start}.  @var{src} and
@var{dst} can be pointers or bytevectors; @var{dst.start},
@var{src.start} and @var{count} must be non--negative fixnums.  The two
memory regions must not overlap.  Return unspecified values.
@end defun


@defun memory->bytevector @var{pointer} @var{number-of-bytes}
Build and return a new bytevector object holding @var{number-of-bytes}
from the memory region starting at @var{pointer}.  @var{number-of-bytes}
must be a non--negative fixnum.
@end defun


@defun bytevector->memory @var{bv}
@defunx bytevector->guarded-memory @var{bv}
Allocate a new raw memory block and copy into it the contents of
@var{bv}.  If successful return two values being the pointer object
referencing the memory and a fixnum representing the length of the
memory block; if allocating memory fails return @false{} and @false{}.

Memory allocated by @func{bytevector->memory} must be released by
@func{free}; memory allocated by @func{bytevector->guarded-malloc} is
automatically released whenever the returned pointer object is garbage
collected.
@end defun


@defun bytevector->memory* @var{bv}
@defunx bytevector->guarded-memory* @var{bv}
Like @func{bytevector->memory*} and @func{bytevector->guarded-memory*},
but if allocation fails raise a non--continuable exception with
components: @condition{who}, @condition{message},
@condition{out-of-memory-error}.
@end defun

@c page
@node iklib memory blocks
@subsection Memory blocks


The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.


@deftp {Struct Type} memory-block
Data structure used to reference a raw memory block through a pointer
and number of bytes.  It has the following public fields:

@table @code
@item pointer
A pointer object referencing the first byte of memory.

@item size
The number of bytes in the memory block; it is an exact integer in the
range of the C language type @code{size_t}.
@end table
@end deftp


@defun make-memory-block @var{pointer} @var{size}
@defunx make-memory-block/guarded @var{pointer} @var{size}
Build and return a new instance of @code{memory-block} referencing a
memory block pointed to by @var{pointer} and of @var{size} number of
bytes.

When a @code{memory-block} built by @func{make-memory-block} is garbage
collected: nothing happens.

When a @code{memory-block} built by @func{make-memory-block/guarded} is
garbage collected: the referenced memory block is released with
@func{free} from @library{vicare}.
@end defun


@defun memory-block? @var{obj}
Return @true{} if @var{obj} is an instance of @code{memory-block}.
@end defun


@defun memory-block?/non-null @var{obj}
@defunx memory-block?/not-null @var{obj}
Return @true{} if @var{obj} is an instance of @code{memory-block} and
the pointer is not @cnull{}.
@end defun


@defun memory-block-pointer @var{mblock}
@defunx memory-block-size @var{mblock}
Accessors for the fields of @code{memory-block} instances.  The pointer
object returned by @func{memory-block-pointer} is a copy of the pointer
object in @var{mblock}.
@end defun


@defun memory-block-reset @var{mblock}
Reset an instance of @code{memory-block} to a @cnull{} pointer and zero
size; return unspecified values.  If @var{mblock} has been created to
release the referenced memory block: the memory block is freed.
@end defun


@defun null-memory-block
Build and return a new instance of @code{memory-block} holding a new
@cnull{} pointer object and zero as size.
@end defun

@c page
@node iklib memory condition
@subsection Memory allocation condition objects


The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.


@deftp {Condition Type} &out-of-memory-error
Condition object type used to tag conditions representing memory
allocation errors; it is derived from @condition{error}.  It has no
fields.
@end deftp


@defun make-out-of-memory-error
@defunx out-of-memory-error? @var{obj}
Maker and predicate for condition objects of type
@condition{out-of-memory-error}.
@end defun

@c page
@node iklib cstrings
@section Raw C strings


The following functions perform operations on raw @ascii{} coded strings
terminated by a zero byte, for short @asciiz{} strings; some functions
act upon raw @utf{}-16 strings.  The following bindings are exported by
the libraries @library{vicare} and @library{vicare system $foreign} and
reexported by the library @library{vicare ffi}.


@defun bytevector->cstring @var{bv}
@defunx bytevector->guarded-cstring @var{bv}
Convert from a Scheme bytevector to an @asciiz{} string.  If successful
return a pointer object referencing the string, else return @false{}.

Memory allocated by @func{bytevector->cstring} must be explicitly
released by @func{free}; memory allocated by
@func{bytevector->guarded-cstring} is automatically released by the
garbage collector whenever the returned pointer is garbage collected.
@end defun


@defun bytevector->cstring* @var{bv}
@defunx bytevector->guarded-cstring* @var{bv}
Like @func{bytevector->cstring*} and @func{bytevector->guarded-cstring},
but if allocation fails raise a non--continuable exception with
components: @condition{who}, @condition{message},
@condition{out-of-memory-error}.
@end defun


@defun cstring->bytevector @var{pointer}
@defunx cstring->bytevector @var{pointer} @var{count}
Convert between an @asciiz{} string and a Scheme bytevector.  When used,
@var{count} must be a fixnum representing the number of bytes to include
in the bytevector.
@end defun


@defun string->cstring @var{str}
@defunx string->guarded-cstring @var{str}
Convert from a Scheme string to an @asciiz{} string.  If successful
return a pointer object referencing the string, else return @false{}.

The string argument must contain only characters with Unicode code
points in the range @math{[0, 255]}.

Memory allocated by @func{string->cstring} must be explicitly
released by @func{free}; memory allocated by
@func{string->guarded-cstring} is automatically released by the
garbage collector whenever the returned pointer is garbage collected.
@end defun


@defun cstring16->bytevector @var{pointer}
Convert between an @utf{}-16 string and a Scheme bytevector; this
function works with all the possible encodings of the string.  The end
of the string is determined by searching for a sequence of two
consecutive zero bytes, starting at even offset.
@end defun


@defun cstring16n->string @var{pointer}
@defunx cstring16le->string @var{pointer}
@defunx cstring16be->string @var{pointer}
Like @func{cstring16->bytevector}, but convert the result to a Scheme
string assuming the specified byte order (native, little endian, big
endian).
@end defun


@defun string->cstring* @var{str}
@defunx string->guarded-cstring* @var{str}
Like @func{string->cstring} and @func{string->guarded-cstring}, but if
allocation fails raise a non--continuable exception with components:
@condition{who}, @condition{message}, @condition{out-of-memory-error}.
@end defun


@defun cstring->string @var{pointer}
@defunx cstring->string @var{pointer} @var{count}
Convert between an @asciiz{} string and a Scheme string.  When used,
@var{count} must be a fixnum representing the number of bytes to include
in the string.
@end defun


@defun strlen @var{pointer}
Interface to the C function @cfunc{strlen}, @glibcref{String Length,
strlen}.  Return an exact integer representing the length of the
@asciiz{} string referenced by @var{pointer}.
@end defun


@defun strcmp @vari{pointer} @varii{pointer}
Interface to the C function @cfunc{strcmp}, @glibcref{String/Array
Comparison, strcmp}.  Return a fixnum representing the classic
comparison ternary result of comparing the @asciiz{} strings referenced
by @vari{pointer} and @varii{pointer}.
@end defun


@defun strncmp @vari{pointer} @varii{pointer} @var{count}
Interface to the C function @cfunc{strncmp}, @glibcref{String/Array
Comparison, strncmp}.  Return a fixnum representing the classic
comparison ternary result of comparing the first @var{count} bytes in
the @asciiz{} strings referenced by @vari{pointer} and @varii{pointer}.
@var{count} must be an exact integer in the range of the C language type
@code{size_t}.
@end defun


@defun strdup @var{pointer}
@defunx guarded-strdup @var{pointer}
Interface to the C function @cfunc{strdup}, @glibcref{Copying and
Concatenation, strdup}.  Duplicate the @asciiz{} string referenced by
@var{pointer}; if successful return a new pointer object, else return
@false{}.

Memory allocated by @func{strdup} must be explicitly released by
@func{free}; memory allocated by @func{guarded-strdup} is automatically
released by the garbage collector whenever the returned pointer is
garbage collected.
@end defun


@defun strdup* @var{pointer}
@defunx guarded-strdup* @var{pointer}
Like @func{strdup} and @func{guarded-strdup}, but if allocation fails
raise a non--continuable exception with components: @condition{who},
@condition{message}, @condition{out-of-memory-error}.
@end defun


@defun strndup @var{pointer} @var{count}
@defunx guarded-strndup @var{pointer} @var{count}
Interface to the C function @cfunc{strndup}, @glibcref{Copying and
Concatenation, strndup}.  Duplicate the first @var{count} bytes in the
@asciiz{} string referenced by @var{pointer}; if successful return a new
pointer object, else return @false{}.  @var{count} must be an exact
integer in the range of the C language type @code{size_t}.

Memory allocated by @func{strdup} must be explicitly released by
@func{free}; memory allocated by @func{guarded-strdup} is automatically
released by the garbage collector whenever the returned pointer is
garbage collected.
@end defun


@defun strndup* @var{pointer} @var{count}
@defunx guarded-strndup* @var{pointer} @var{count}
Like @func{strndup} and @func{guarded-strndup}, but if allocation fails
raise a non--continuable exception with components: @condition{who},
@condition{message}, @condition{out-of-memory-error}.
@end defun


@defun bytevectors->argv @var{list-of-bytevectors}
@defunx bytevectors->guarded-argv @var{list-of-bytevectors}
Given a list of bytevectors: convert them into @asciiz{} strings and
build a @cnull{} terminated array of C pointers referencing the strings.
Return a pointer to the array.  The strings and the array are stored in
a single memory block.

Memory allocated by @func{bytevectors->argv} must be explicitly released
by @func{free}; memory allocated by @func{bytevectors->guarded-argv} is
automatically released by the garbage collector whenever the returned
pointer is garbage collected.
@end defun


@defun bytevectors->argv* @var{list-of-bytevectors}
@defunx bytevectors->guarded-argv* @var{list-of-bytevectors}
Like @func{bytevectors->argv*} and @func{bytevectors->guarded-argv*},
but if allocation fails raise a non--continuable exception with
components: @condition{who}, @condition{message},
@condition{out-of-memory-error}.
@end defun


@defun argv->bytevectors @var{pointer}
Given a pointer to a @cnull{} terminated array of C pointers referencing
@asciiz{} strings: build and return a list of bytevectors holding the
same bytes of the strings.
@end defun


@defun strings->argv @var{list-of-strings}
@defunx strings->guarded-argv @var{list-of-strings}
Given a list of Scheme strings: convert them into @asciiz{} strings and
build a @cnull{} terminated array of C pointers referencing the strings.
Return a pointer to the array.  The strings and the array are stored in
a single memory block.

The string arguments must contain only characters with Unicode code
points in the range @math{[0, 255]}.

Memory allocated by @func{strings->argv} must be explicitly released
by @func{free}; memory allocated by @func{strings->guarded-argv} is
automatically released by the garbage collector whenever the returned
pointer is garbage collected.
@end defun


@defun strings->argv* @var{list-of-strings}
@defunx strings->guarded-argv* @var{list-of-strings}
Like @func{strings->argv} and @func{strings->guarded-argv}, but if
allocation fails raise a non--continuable exception with components:
@condition{who}, @condition{message}, @condition{out-of-memory-error}.
@end defun

@defun argv->strings @var{pointer}
Given a pointer to a @cnull{} terminated array of C pointers referencing
@asciiz{} strings: build and return a list of strings holding the same
bytes of the strings.
@end defun


@defun argv-length @var{argv}
Return the number of strings in the @cnull{}--terminated array of
strings referenced by the @var{argv} pointer.
@end defun

@c page
@node iklib errno
@section Interface to @code{errno}


Most C language system functions report errors by setting a the special
variable @code{errno} to some predefined integer constant,
@glibcref{Checking for Errors, errno}.  The Scheme code accessing
@code{errno} values should be agnostic with respect to the actual error
codes; for this to happen we should use the following facilities along
with bindings from @library{vicare platform errno}, @libsref{errno, More
features for @code{errno}} for details.

Values for the C language variable @code{errno} are encoded as negated
fixnum values: if @code{EPERM} is defined to @code{1} at the C language
level, @value{PRJNAME} defines it as the fixnum @code{-1}; at present
all the known error codes fit into fixnums range.  One syntax identifier
binding for each known @code{errno} value is exported by the library
@library{vicare platform errno} and reexported by the library
@library{vicare platform constants}.

If some error codes are not defined on a platform: the corresponding
binding evaluates to @true{}.  Notice that if no error occurred
@code{errno} is set to the fixnum zero.

The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.


@defun errno
@defunx errno @var{code}
Interface to the C language level @code{errno} variable to be used with
the foreign--functions interface (@ffi{}).

When called with no values return the value of the C variable
@code{errno} right after the last call to a C function performed by the
current process through the @ffi{}.  When called with one argument: set
the C variable @code{errno} of the current process to @var{code},
appropriately handling the coding of the value.

Notice that bindings exported by @library{vicare posix}, @library{vicare
glibc} and @library{vicare linux} do @strong{not} use this mechanism;
rather they raise an exception whenever an error happen.

As special cases: when the C variable @code{errno} is set to zero,
@func{errno} returns @false{}; when @var{code} is @false{}, the C
variable @code{errno} is set to zero; when @var{code} is @true{}, the C
variable @code{errno} is set to @code{EFAULT}.

The mechanism is such that the following form:

@example
(let ((rv (call-foreign-function)))
  (values rv (errno)))
@end example

@noindent
performs a foreign--function call and evaluates to two values: the
return value from the foreign function and the value of the C variable
@code{errno} right after the foreign call.
@end defun

@c page
@node iklib time
@section Basic time and date functions


The following bindings are exported by the library @library{vicare}.


@defun current-time
Return an object of disjoint type representing the current time as
determined by @cfunc{gettimeofday}: this is the elapsed time since the
Epoch.
@end defun


@defun time-from-now @var{delta}
Return a time object representing the current time plus the time object
@var{delta}.
@end defun


@defun make-time @var{seconds} @var{nanoseconds}
Build and return a new time object with microseconds resolution.  If
@var{nanoseconds} exceeds @math{1000000} its value is normalised and the
excess added to @var{seconds}.
@end defun


@defun time? @var{obj}
Return @true{} if @var{obj} is a time object returned by
@func{current-time}.
@end defun


@defun time-second @var{time}
@defunx time-nanosecond @var{time}
Accessors, returning exact integers, for the seconds and nanoseconds
components of the time objects returned by @func{current-time}.
@end defun


@defun time-gmt-offset @var{time}
Return the @acronym{GMT} offset in seconds of the @var{time} object
returned by @func{current-time}, as determined ty @cfunc{gmtime_r}.
@end defun


@defun date-string
Return a string representing the current date in the simple format:
year, month, day.
@end defun

@c ------------------------------------------------------------

@subsubheading Time operations


@defun time-addition @vari{time} @varii{time}
Compute the addition between two times: @code{@vari{time} +
@varii{time}} and return a time struct representing it.
@end defun


@defun time-difference @vari{time} @varii{time}
Compute the difference between two times: @code{@vari{time} -
@varii{time}} and return a time struct representing it.
@end defun

@c ------------------------------------------------------------

@subsubheading Time comparison


@defun time=? @vari{time} @varii{time}
Return @true{} if the time objects are equal, else return @false{}.
@end defun


@defun time<? @vari{time} @varii{time}
Return @true{} if the @vari{time} is less than @varii{time}, else return
@false{}.
@end defun


@defun time<=? @vari{time} @varii{time}
Return @true{} if the @vari{time} is less than or equal to @varii{time},
else return @false{}.
@end defun


@defun time>? @vari{time} @varii{time}
Return @true{} if the @vari{time} is greater than @varii{time}, else
return @false{}.
@end defun


@defun time>=? @vari{time} @varii{time}
Return @true{} if the @vari{time} is greater than or equal to
@varii{time}, else return @false{}.
@end defun

@c page
@node iklib readline
@section Readline interface


The following bindings are exported by the library @library{vicare}.  An
extended @api{} for @gnu{} Readline is available through the
@library{vicare readline} library; @libsref{readline, Extended interface
to @gnu{} Readline} for details.


@defun readline-enabled?
Return @true{} is support for readline is enabled, return @false{}
otherwise.  When this function returns @false{}: no other readline
functions must be called, lest the process be aborted.
@end defun


@defun readline
@defunx readline @var{prompt}
Read a single line and return it as a Scheme string @strong{not}
terminated by a newline character.  @var{prompt} must be @false{}, a
bytevector or a string to be used as input prompt; when @false{} or not
present: no prompt will be displayed.
@end defun


@defun make-readline-input-port
@defunx make-readline-input-port @var{prompt-maker}
Return a custom textual input port reading character through
@func{readline}.

@var{prompt-maker} must be a @false{} or a thunk, when not used it
defaults to @false{}; the thunk, when evaluated, must return a string or
bytevector representing the input prompt in @ascii{} characters; if the
return value is @false{} or @var{prompt-maker} is not used: no prompt
will be displayed.
@end defun

@c page
@node iklib debug
@section Debugging utilities


@defun integer->machine-word @var{exact-integer}
@defunx machine-word->integer @var{word}
Convert between an exact integer and a machine word.  This operation
shows at the Scheme level the internal representation of values.  Care
must be taken when using these functions because it is very easy to
cause undefined behaviour.

@example
;; on 32-bit platforms
(integer->machine-word #b11100) @result{} #b111

;; on 64-bit platforms
(integer->machine-word #b111000) @result{} #b111

(integer->machine-word #x3F)    @result{} #t
(integer->machine-word #x2F)    @result{} #f

(machine-word->integer #t)      @result{} #x3F
(machine-word->integer #f)      @result{} #x2F
@end example
@end defun


@defun flonum->bytevector @var{flo}
@defunx bytevector->flonum @var{bv}
Convert a flonum to a bytevector and vice versa.  The flonum's memory
block is copied byte by byte in the data area of the bytevector; and
vice versa.

For @func{bytevector->flonum}: if the bytevector does not have the
length of a flonum's memory block, the return value is @false{}.
@end defun


@defun bignum->bytevector @var{flo}
@defunx bytevector->bignum @var{bv}
Convert a bignum to a bytevector and vice versa.  The bignum's memory
block is copied byte by byte in the data area of the bytevector; and
vice versa.
@end defun

@c page
@node iklib misc
@section Miscellaneous functions


@defun neq? @vari{obj} @varii{obj}
Compare the arguments as @func{eq?} would do, but return a negated
result.  Equivalent (but more efficient) to:

@example
(not (eq? @vari{obj} @varii{obj}))
@end example
@end defun


@defun immediate? @var{obj}
Return true if @var{obj} is an immediate object: an object contained in
a single machine word.  Compound objects (like lists and vectors) are
@strong{not} immediate.
@end defun


@defun void
Return the void value.  It is the value returned by forms that do not
return a meaningful value.
@end defun


@defun always-true @var{arg} @dots{}
@defunx always-false @var{arg} @dots{}
Always return @true{} or @false{}, ignoring the arguments.
@end defun


@defun apropos @var{key}
Given a string or symbol @var{key}, search among the internally
installed libraries all the exported bindings having @var{key} as
substring of their name and print a report to the standard output port.
Useful when using the @repl{}.  Example:

@example
vicare> (apropos "-length")
*** in library (vicare):
(bitwise-length bytevector-length string-length
  struct-length vector-length)

*** in library (rnrs):
(bitwise-length bytevector-length string-length
  vector-length)

*** in library (rnrs arithmetic bitwise):
(bitwise-length)

*** in library (rnrs base):
(string-length vector-length)

*** in library (rnrs bytevectors):
(bytevector-length)

*** in library (vicare):
(bitwise-length bytevector-length string-length
  struct-length vector-length)

vicare>
@end example
@end defun


@defun getenv @var{varname}
Interface to the C function @cfunc{getenv}, @glibcref{Environment
Access, getenv}.  Retrieve the value of environment variables.
@var{variable} must reference a string object representing the name of
the environment variable.  If the environment variable is set: return a
string representing its value; else return false.

@example
(getenv "PATH")
@result{} "/usr/local/bin:/usr/bin:/bin"
@end example

The Scheme level representation of environment variables names and
values is a string, but internally it is a bytevector; strings are
internally converted to bytevectors using @func{string->utf8}.
@end defun


@defun environ
Interface to the global C variable @code{environ}, @glibcref{Environment
Access, unsetenv}.  Retrieve the full environment.  Return a list of
strings representing the contents of the @code{environ} array; if the
environment is empty (no environment variables set) return nil.
@end defun


@defun strerror @var{errno}
Return a string describing the @code{errno} code @var{errno}.  Makes use
of the system function @cfunc{strerror}.  If @var{errno} is not a valid
@code{errno} value: return a string telling it.  As special cases
@var{errno} can be also @true{}, meaning ``unknown error'', and
@false{}, meaning ``no error''.

@glibcref{Error Messages, Error Messages}
@end defun


@defun warning @var{who} @var{message} @var{irritant} ...
Similar to @func{error}, but raise a @strong{continuable} exception with
condition components: @condition{warning}, @condition{who},
@condition{message}, @condition{irritants}.
@end defun


@defun die @var{who} @var{message} @var{irritant} ...
A deprecated alias for @func{assertion-violation}.
@end defun


@defun random @var{fx}
Return a random fixnum object between zero (included) and @var{fx}
(excluded).  @var{fx} must be a strictly positive fixnum.
@end defun


@deffn Parameter exit-hooks
Contains null or a list of thunks to be evaluated by @func{exit}
whenever the process is normally terminated.  Any exception raised by
the thunks is catched and discarded.  To add an exit hook:

@example
(define (do-something-at-exit)
  ---)

(exit-hooks (cons do-something-at-exit
                  (exit-hooks)))
@end example
@end deffn

@c end of file

@node lang
@chapter Language extension libraries


@menu
* keywords::                    More facilities for keyword objects.
* cond-expand::                 Feature based conditional expansion.
* include::                     Including source files at expand time.
* amb::                         McCarthy's @func{amb} operator.
* simple-match::                Simple destructuring match syntax.
* sentinels::                   Sentinel values.
* namespaces::                  Namespaces.
* variables::                   Defining storage locations.
* syntaxes::                    Language syntactic extensions.
* makers::                      Maker syntaxes.
* custom-ports::                Custom ports.
* asciis::                      Utilities for @ascii{} characters.
* hooks::                       Running lists of functions.
* callables::                   Callable objects.
* c-enums::                     C language flags and flags combinations.
* streams::                     Streams.
* loops::                       Loop constructs.
* comparisons::                 Comparison functions.
* restarts::                    Signaling conditions and restarts.
@end menu

@c page
@node keywords
@section More facilities for keyword objects


@cindex Library @library{vicare language-extensions keywords}
@cindex @library{vicare language-extensions keywords}, library


Keywords are disjoint objects which can be read by @value{PRJNAME}'s
reader in @code{#!vicare} mode, @vicareref{iklib reader stx}.  The core
bindings and keyword objects handling is embedded in @value{PRJNAME}'s
boot image, but additional facilities are required to make use of
keywords.

The following bindings are exported by the library @library{vicare
language-extensions keywords}.  Additionally the following bindings are
reexported from @library{vicare}:

@example
symbol->keyword         keyword->symbol
keyword?                keyword=?
keyword-hash
@end example


@defun string->keyword @var{string}
Convert a string to a keyword object.  The string is the name of the
symbol embedded in the keyword.
@end defun


@deffn Syntax let-keywords @meta{input} @meta{args} @meta{allow} @meta{options-spec} @metao{form} @meta{form} ...
@deffnx Syntax let*-keywords @meta{input} @meta{args} @meta{allow} @meta{options-spec} @metao{form} @meta{form} ...
@deffnx Syntax letrec-keywords @meta{input} @meta{args} @meta{allow} @meta{options-spec} @metao{form} @meta{form} ...
@deffnx Syntax letrec*-keywords @meta{input} @meta{args} @meta{allow} @meta{options-spec} @metao{form} @meta{form} ...
@deffnx {Auxiliary Syntax} with-argument @meta{name} @meta{default} @meta{keyword}
@deffnx {Auxiliary Syntax} without-argument @meta{name} @meta{default} @meta{keyword} @meta{when-given}
Expand into a @func{let} like form whose bindings are configured from a
list of arguments and options.

@func{let-keywords} expands into a @func{let} syntax,
@func{let*-keywords} expands into a @func{let*} syntax,
@func{letrec-keywords} expands into a @func{letrec} syntax,
@func{letrec*-keywords} expands into a @func{letrec*} syntax.

@meta{input} must be an expression evaluating to a list of values and
keywords; keywords must be compliant to the specification in
@meta{options-spec}.  The same keyword can be present multiple times in
@meta{input}.

@meta{args} must be an identifier which will be bound to a list of
values from @meta{input} not matching any of the options specified in
@meta{options-spec}.

@meta{allow} must be an expression meant to evaluate to @false{} or
true; when @false{}: keyword values in @meta{input} not matched by
specifications in @meta{options-spec} will cause an assertion violation;
when true: keyword values in @meta{input} not matched by specifications
in @meta{options-spec} will be collected in @meta{args}.

@meta{options-spec} must be null or a list of lists, each with the
following formats:

@example
(with-argument @meta{name} @meta{default} @meta{keyword})
(without-argument @meta{name} @meta{default} @meta{keyword} @meta{when-given})
@end example

@noindent
such specifications are interpreted as follows:

@itemize
@item
The @func{with-argument} specification describes an optional keyword
argument with mandatory value, which must @strong{not} be a keyword
itself.

@item
The @func{without-argument} specification describes an optional keyword
argument without value.

@item
@meta{name} must be an identifier which will become the name of a
binding in the output @func{let} like syntax.

@item
@meta{default} must be an expression which will become a the value of
binding in the output @func{let} like syntax.

@item
@meta{keyword} must be a keyword object which can be present in
@meta{input} to mutate the associated @meta{name} binding.

@item
For keywords with argument: when the @meta{keyword} is present in
@meta{input}, it must be followed by a value which will become the new
value of the corresponding @meta{name} binding.


@item
For keywords without argument: when the @meta{keyword} is present in
@meta{input}, the value resulting from the evaluation of
@meta{when-given} will become the new value of the corresponding
@meta{name} binding.
@end itemize

We can imagine the following macro use:

@example
(let-keywords @meta{input} args #f
    ((with-argument a 1 #:a)
     (with-argument b 2 #:b))
  (alpha)
  (beta))
@end example

@noindent
to expand to something like:

@example
(let ((a 1)
      (b 2))
  (let ((args @meta{options-parser}))
    (alpha)
    (beta)))
@end example

@noindent
where @meta{options-parser} is a form which takes care of parsing the
@meta{input}.
@end deffn


Examples:

@example
#!vicare
(import (vicare)
  (vicare language-extensions keywords))

;; options with arguments
(let-keywords '(#:a 1 #:b 2 #:d 4) args #f
    ((with-argument a #\a #:a)
     (with-argument b #\b #:b)
     (with-argument c #\c #:c)
     (with-argument d #\d #:d))
  (list a b c d args))
@result{} (1 2 #\c 4 ())

;; options without arguments
(let-keywords '(#:a #:b #:d 4) args #f
    ((without-argument a #\a #:a #\A)
     (without-argument b #\b #:b #\B)
     (without-argument c #\c #:c #\C)
     (with-argument d #\d #:d))
  (list a b c d args))
@result{} (#\A #\B #\c 4 ())

;; options with arguments, leftover arguments
(let-keywords '(#:a 1 ciao #:b 2 hello #:d 4) args #f
    ((with-argument a #\a #:a)
     (with-argument b #\b #:b)
     (with-argument c #\c #:c)
     (with-argument d #\d #:d))
  (list a b c d args))
@result{} (1 2 #\c 4 (ciao hello))

;; no options, allow unknown
(let-keywords '(#:a 1 #:b 2 #:d 4) args #t
    ()
  args)
@result{} (#:a 1 #:b 2 #:d 4)

(let-keywords '(#:a) args #f
    ()
  args)
@error{} unknown option #:a

(let-keywords '(#:a #:b 123) args #t
    ((with-argument a 1 #:a)
     (with-argument b 2 #:b))
  args)
@error{} option value for #:a cannot be a keyword

(let-keywords '(#:a) args #t
    ((with-argument a 1 #:a)
     (with-argument b 2 #:b))
  args)
@error{} option #:a requires argument

;; keywords used multiple times
(let-keywords '(#:verbose #:verbose #:verbose) args #f
  ((without-argument verbosity 0 #:verbose (+ 1 verbosity)))
  verbosity)
@result{} 3
@end example

@c page
@node cond-expand
@section Feature based conditional expansion


@cindex Library @library{vicare language-extensions cond-expand}
@cindex @library{vicare language-extensions cond-expand}, library
@cindex Library @library{vicare language-extensions cond-expand helpers}
@cindex @library{vicare language-extensions cond-expand helpers}, library


The following bindings are exported by the library @library{vicare
language-extensions cond-expand}.


@deffn Syntax define-cond-expand @meta{cond-expand} @meta{feature-func} ...
Expand to the definition of a syntax like @func{cond-expand} supporting
all the features of the @func{cond-expand} from @ansrfi{0} and in
addition supporting the features specified by a set of functions.
@ref{srfi cond-expand vicare, Features supported by @value{PRJNAME}}

@meta{cond-expand} must be an identifier representing the name of the
new syntax.

The optional @meta{feature-func} arguments must be expressions which,
evaluated only once at expand time, must return functions; each of such
functions must accept as single argument an identifier representing a
feature and must return as single argument: @true{} if the feature is
supported, @false{} otherwise.
@end deffn

In the following example we define a @func{cond-expand} syntax just like
the one exported by @ansrfi{0}:

@example
#!r6rs
(import (rnrs)
  (vicare language-extensions cond-expand))

(define-cond-expand cond-expand)

(cond-expand
  ((and srfi-0 srfi-1)  #t)
  (else                 #f))
@expansion{} #t
@end example

@noindent
in the following example we define a @func{cond-expand} that
additionally recognises the features @func{write} and @func{display}:

@example
#!r6rs
(import (rnrs)
  (vicare language-extensions cond-expand))

(define-cond-expand cond-expand
  (lambda (id)
    (free-identifier=? id #'display))
  (lambda (id)
    (free-identifier=? id #'write)))

(cond-expand
  ((or display write)   #t)
  (else                 #f))
@expansion{} #t
@end example

The following bindings are exported by the library @library{vicare
language-extensions cond-expand helpers}.


@deffn Syntax define-cond-expand-identifiers-helper @meta{who} @meta{feature-clause} ...
Expand to the definition of a function bound to @meta{who} which can be
used as feature function in uses of the macro @func{define-cond-expand}.

Each of the optional @meta{feature-clause} must have the following
format:

@example
(@meta{feature-id} @meta{expr})
@end example

@noindent
where @meta{feature-id} must be the feature identifier and @meta{expr}
must be an expression.  The generated function compares the given
identifier with each of @meta{feature-id}, using
@func{free-identifier=?}:

@itemize
@item
If the result is @true{}: evaluate @meta{expr} and return the result.

@item
If the result is @false{}: move on to the next @meta{feature-id}.

@item
If no more @meta{feature-id} are left: return @false{}.
@end itemize
@end deffn


In the following example we define a @func{cond-expand} that
additionally recognises the features @func{write} and @func{display}:

@example
#!r6rs
(import (rnrs)
  (vicare language-extensions cond-expand)
  (for (vicare language-extensions cond-expand)
       expand))

(define-cond-expand cond-expand
  (let ()
    (define-cond-expand-identifiers-helper help
      (display        #t)
      (write          #t))
    help))

(cond-expand
  ((or display write)   #t)
  (else                 #f))
@expansion{} #t
@end example

@c page
@node include
@section Including source files at expand time


@cindex Library @library{vicare language-extensions include}
@cindex @library{vicare language-extensions include}, library


The following bindings are exported by the library @library{vicare
language-extensions include}.


@deffn Syntax include @var{filename}
Include in the current source file the contents of the file selected by
the pathname @var{filename}, which must be a string.  Everything happens
as if the code was present in place of the @func{include} form.
@end deffn


@deffn Syntax include/lexical-context @var{filename} @var{identifier}
Include in the current source file the contents of the file selected by
the pathname @var{filename}, which must be a string.  @var{identifier}
must be a Scheme identifier and it is used to assign a lexical context
to the sourced code.
@end deffn

@c page
@node amb
@section McCarthy's @func{amb} operator


@cindex Library @library{vicare language-extensions amb}
@cindex @library{vicare language-extensions amb}, library


The library @library{vicare language-extensions amb} defines McCarthy's
@func{amb} operator and a set of related utilities.  The @dfn{ambiguous
operator} allows the execution of depth--first search in a tree of
choices integrated in the normal control flow of a Scheme program; it is
built upon continuations.

The @func{amb} operator was briefly defined in:

@quotation
John McCarthy.  ``A Basis for a Mathematical Theory of Computation''.
In Computer Programming And Formal Systems by P. Braffort and
D. Hirschberg (Ed.), 1963.
@end quotation

@noindent
and further discussed in:

@quotation
Ramin Zabih, David McAllester, and David Chapman.  ``Non--deterministic
Lisp with dependency--directed backtracking''.  In Proc. Proceedings of
the Sixth National Conference on Artificial Intelligence, pp. 59-64,
1987.
@end quotation

@menu
* amb api::                     Programming interface for @func{amb}.
* amb examples::                Usage examples for @func{amb}.
@end menu

@c page
@node amb api
@subsection Programming interface for @func{amb}


@menu
* amb api core::                Core @func{amb} syntaxes.
* amb api random::              Random selection of choices.
* amb api generator::           Generating choices.
* amb api utilities::           Utility functions and syntaxes.
* amb api condition::           Condition object types.
@end menu

@c page
@node amb api core
@subsubsection Core @func{amb} syntaxes


The following bindings are exported by the library @library{vicare
language-extensions amb}.


@deffn Syntax with-ambiguous-choices @metao{body} @meta{body} ...
Initialise the dynamic environment for a new @func{amb} search and in
such environment evaluates the @meta{body} forms.  Return the result of
the last form.
@end deffn


@deffn Syntax with-amb-exhaustion-handler @meta{handler} @meta{thunk}
Install in the dynamic environment a custom handler for search tree
exhaustion.  This syntax should be used in the body of
@func{with-ambiguous-choices}, but before the first use of @func{amb}.

@meta{handler} must be an expression evaluating to a thunk: such thunk
is called by @func{amb} whenever no more choices are available.
@meta{thunk} must be an expression evaluating to a thunk: it is
evaluated while the custom handler is installed.
@end deffn


@deffn Syntax amb @meta{expr} ...
Evaluate one of the @meta{expr} expressions and return its result; save
in the dynamic environment a continuation that can be reinstated to
reject the result of this @meta{expr} and try with the next @meta{expr}.
The @meta{expr} arguments are tried in the given order: left to right.

If the result of evaluating an @meta{expr} is a promise (produced by
@func{delay}): the promise is forced to produce the result.

When used with no arguments: reject the result of the most recent
@var{expr} and reinstate the previous continuation to try the next
@var{expr}.

When all the choices have been tried: raise a non--continuable exception
with condition object components @condition{who}, @condition{message},
@condition{amb-exhaustion}.

It is an error if @func{amb} is used outside the dynamic environment
prepared by @func{with-ambiguous-choices}.
@end deffn

@c page
@node amb api random
@subsubsection Random selection of choices


The following bindings are exported by the library @library{vicare
language-extensions amb}.


@deffn Syntax amb-permute @meta{expr} ...
Like @func{amb} but permute the order of the given expressions.  The
permutation determining the selection order is generated at every first
execution of the expanded code, using the random fixnum generator
referenced by @func{amb-random-fixnum-maker}.

If we define the following function:

@example
(define (choose)
  (amb 1 2 3))
@end example

@noindent
a new permutation is generated at every function invocation.
@end deffn


@deffn Syntax amb-permute @meta{expr} ...
Like @func{amb} but randomly select an expression to evaluate; the same
expression can be selected multiple times.  This syntax never finishes
choices.  The next expression to evaluate is selected using the random
fixnum generator referenced by @func{amb-random-fixnum-maker}.
@end deffn


@deffn Parameter amb-random-fixnum-maker
Hold a procedure accepting a fixnum as single argument: when applied to
the fixnum @math{N} it must return a fixnum in the range @math{[0, N)}.
It is initialised with @func{random} from the library @library{vicare},
@vicareref{iklib misc, random}.
@end deffn

@c page
@node amb api generator
@subsubsection Generating choices


The following bindings are exported by the library @library{vicare
language-extensions amb}.


@defun amb-thunk @var{generator-thunk}
Like @func{amb} but generate the next choice by evaluating a thunk.
@var{generator-thunk} must be a thunk, which, when evaluated, returns
the next choice; when no more choices are available
@var{generator-thunk} must evaluate @code{(amb)}.

@example
#!r6rs
(import (vicare)
  (vicare language-extensions amb))

(define-values (empty? enqueue! dequeue!)
  (make-queue '(1 2 3 4)))

(define (generator)
  (if (empty?)
      (amb)
    (dequeue!)))

(with-ambiguous-choices
 (let ((R (amb-thunk generator)))
   (amb-assert (<= 3 R))
   R))
@result{} 3
@end example
@end defun

@c page
@node amb api utilities
@subsubsection Utility functions and syntaxes


The following bindings are exported by the library @library{vicare
language-extensions amb}.


@deffn Syntax amb-assert @meta{expr}
Evaluate @meta{expr} and if the result is true return it; if the result
is false reject the latest @func{amb} choice.

@example
(amb-assert @meta{expr}) @expansion{} (or @meta{expr} (amb))
@end example
@end deffn


@deffn Parameter amb-backtrack-log
Hold a thunk to be called every time @func{amb}, or any of its
derivatives, backtracks to reject a previous choice.  It is initialised
to @func{void}.
@end deffn

@c page
@node amb api condition
@subsubsection Condition object types


@subsubheading Search tree exhaustion


@deftp {Condition Type} &amb-exhaustion
Condition type used to signal the exhaustion of a search tree visited by
@func{amb}; it is derived from @condition{condition}.
@end deftp


@defun make-amb-exhaustion
Build and return a new instance of @condition{amb-exhaustion}.
@end defun


@defun amb-exhaustion? @var{obj}
Return @true{} if @var{obj} is an instance of
@condition{amb-exhaustion}, else return @false{}.
@end defun

@c ------------------------------------------------------------

@subsubheading Search not initialised


@deftp {Condition Type} &amb-not-initialised
Condition type used to tag the compound condition object raised whenever
@func{amb} is used outside the dynamic environment prepared by
@func{with-ambiguous-choices}; it is derived from @condition{assertion}.
@end deftp


@defun make-amb-not-initialised
Build and return a new instance of @condition{amb-not-initialised}.
@end defun


@defun amb-not-initialised? @var{obj}
Return @true{} if @var{obj} is an instance of
@condition{amb-not-initialised}, else return @false{}.
@end defun

@c page
@node amb examples
@subsection Usage example for @func{amb}


@menu
* amb examples simple::         Introductory examples.
* amb examples ssc::            Seed, square, cube.
* amb examples coloring::       Graph coloring.
@end menu

@c page
@node amb examples simple
@subsubsection Introductory examples


In all the examples of this section we will assume that the following
prelude opens the program:

@example
#!r6rs
(import (vicare)
  (vicare language-extensions amb))
@end example

The @func{amb} operator requires appropriate initialisation of the
dynamic environment, so if we just evaluate the following form we will
get an error:

@example
(amb)
@error{} &amb-not-initialised
@end example

If we initialise the environment and then just call @func{amb}, we get
an ``exhausted search tree'' error:

@example
(with-ambiguous-choices
 (amb))
@error{} &amb-exhaustion
@end example

@noindent
because there are no choices, so the search terminates immediately.

If we apply @func{amb} to some choices, it will return the first one:

@example
(with-ambiguous-choices
 (amb 1 2 3))
@result{} 1
@end example

If we want to see an actual use of @func{amb}, we have to reject some
choices.  Let's look at this program:

@example
(with-ambiguous-choices
 (let ((X (amb 1 2 3)))
   (amb-assert (even? X))
   X))
@result{} 2
@end example

@noindent
this is what happens:

@enumerate
@item
@func{amb} returns the result of the first expression: @code{1}.

@item
@func{amb-assert} rejects @code{1} because it is odd; the execution flow
jumps back to the form @code{(amb 1 2 3)}.

@item
@func{amb} returns the result of the next expression: @code{2}.

@item
@func{amb-assert} accepts @code{2} because it is even.

@item
The result is @code{2}.
@end enumerate

@c ------------------------------------------------------------

@subsubheading The custom failure handler

The syntax @func{with-amb-exhaustion-handler} allows us to install a
custom handler for the event ``exhausted search tree''; the installed
handler is called by @func{amb} whenever no more choices are available.
As example, if we want a non--local exit at the end of a failed search,
we can do:

@example
(call/cc
    (lambda (escape)
      (with-ambiguous-choices
       (with-amb-exhaustion-handler
           (lambda ()
             (escape #t))
         (lambda ()
           (amb)
           #f)))))
@result{} #t
@end example


@c page
@node amb examples ssc
@subsubsection Seed, square, cube


Given the seed numbers:

@example
1 3
@end example

@noindent
let's say we want to select the one having the square among:

@example
5 9 11
@end example

@noindent
and the cube among:

@example
13 27 31
@end example

@noindent
we can imagine a search tree, @ref{fig:amb_ssc_tree, amb examples ssc}.

@float Figure,fig:amb_ssc_tree
@example
     | A |    | B |    | C |

o----- 1 -----  5 ----- 13
   |       |        |-- 27
   |       |         -- 31
   |       |
   |       |--  9 ----- 13
   |       |        |-- 27
   |       |         -- 31
   |       |
   |        -- 11 ----- 13
   |                |-- 27
   |                 -- 31
   |
    -- 3 -----  5 ----- 13
           |        |-- 27
           |         -- 31
           |
           |--  9 ----- 13
           |        |-- 27
           |         -- 31
           |
            -- 11 ----- 13
                    |-- 27
                     -- 31
@end example
@caption{Search tree for the seed, square, cube problem.}
@end float

If we assign a selected seed to the variable @math{A}, a selected
possible square to the variable @math{B} and a selected possible cube to
the variable @math{C}, we want search for a tuple @math{(A, B, C)}
satisfying the constraints: @math{A^2 = B}, @math{A^3 = C}.

To select among the seeds we use the syntax:

@example
(amb 1 3)
@end example

@noindent
to select among the possible squares we use the syntax:

@example
(amb 5 9 11)
@end example

@noindent
to select among the possible cubes we use the syntax:

@example
(amb 13 27 31)
@end example

@noindent
and the constraints can be expressed by the predicates:

@example
(= (square A) B)
(= (cube   A) C)
@end example

@noindent
the resulting program follows:

@example
#!r6rs
(import (vicare)
  (vicare language-extensions amb))

(with-ambiguous-choices
  (let* ((A (amb 1 3))
         (B (amb 5 9 11)))
    (amb-assert (= (square A) B))
    (let ((C (amb 13 27 31)))
      (amb-assert (= (cube A) C))
      (list A B C))))
@result{} (3 9 27)
@end example

We can modify the program to show the search path:

@example
#!r6rs
(import (vicare)
  (vicare language-extensions amb))

(define (print . args)
  (apply fprintf (current-error-port) args))

(with-ambiguous-choices
 (let ((A (amb 1 3)))
   (print "A=~a\n" A)
   (let ((B (amb 5 9 11)))
     (print "\tB=~a\n" B)
     (amb-assert (= (square A) B))
     (let ((C (amb 13 27 31)))
       (print "\t\tC=~a\n" C)
       (amb-assert (= (cube A) C))
       (list A B C)))))
@result{} (3 9 27)
@print{} A=1
@print{}         B=5
@print{}         B=9
@print{}         B=11
@print{} A=3
@print{}         B=5
@print{}         B=9
@print{}                 C=13
@print{}                 C=27
@end example

@c page
@node amb examples coloring
@subsubsection Graph coloring


The following program shows how to select colors to paint European
nations on map: given a map of nations we want to paint each nation with
a color different from the one of its neighbors; it is known that 4
colors are always enough (even though more than 4 colors are
aesthetically better).  The code is derived from an example in ``Teach
Yourself Scheme in Fixnum Days'' by Dorai Sitaram.

We start with the prelude:

@example
#!r6rs
(import (vicare)
  (vicare language-extensions amb)
  (only (vicare language-extensions syntaxes)
        define-values))
@end example

We represent the map with a graph: one node for each nation; nations
that face each other are connected by a link.  We select the adjacency
list representation.  We want to make sure that we have correctly
defined the graph: two nodes connected by a link must be present in the
adjacency list of each other.  A better graph definition syntax would
have integrated this check.

@example
(define-record-type node
  (fields (immutable name)
          ;;List of NODE  records representing the adjacency
          ;;list of this node.
          (mutable neighbors)
          ;;Symbol representing this node's color.
          (mutable color))
  (protocol (lambda (maker)
              (lambda (name)
                (maker name '() #f)))))

(define-syntax define-nodes
  (syntax-rules ()
    ((_ ?nodes-var (?node (?neighbor ...)) ...)
     (begin
       (define ?node (make-node (quote ?node)))
       ...
       (module ()
         (node-neighbors-set! ?node (list ?neighbor ...))
         ...)
       (define ?nodes-var
         (list ?node ...))
       (module ()
         (assert-graph-consistency ?nodes-var))))
    ))

(define (assert-graph-consistency nodes)
  ;;Verify that every node is  present in the adjacency list
  ;;of all its neighbors.
  ;;
  (define who 'assert-graph-consistency)
  (for-each
      (lambda (node)
        (for-each
            (lambda (neighbor)
              (unless (memq node (node-neighbors neighbor))
                (assertion-violation who
                  "incorrect node links"
                  (node-name node)
                  (node-name neighbor))))
          (node-neighbors node)))
    nodes))
@end example

We are interested in nations that face each other, even when there is a
sea between them; for example: it is aesthetically more pleasant if
France and the United Kingdom are painted in different colors.

@example
(define-nodes europe-facing-nations
  (portugal        (spain))
  (spain           (portugal andorra france))
  (andorra         (spain france))
  (france          (spain andorra monaco italy
                    switzerland germany luxembourg
                    belgium united-kingdom))
  (united-kingdom  (france belgium netherlands denmark
                    norway iceland ireland))
  (ireland         (united-kingdom iceland))
  (monaco          (france))
  (italy           (france greece albania montenegro
                    croatia slovenia austria switzerland
                    san-marino))
  (san-marino      (italy))
  (switzerland     (france italy austria germany
                    liechtenstein))
  (liechtenstein   (switzerland austria))
  (germany         (france switzerland austria czech-republic
                    poland sweden denmark netherlands
                    belgium luxembourg))
  (belgium         (france luxembourg germany netherlands
                    united-kingdom))
  (netherlands     (belgium germany united-kingdom))
  (luxembourg      (france germany belgium))
  (austria         (italy slovenia hungary slovakia
                    czech-republic germany switzerland
                    liechtenstein))
  (slovenia        (italy croatia hungary austria))
  (croatia         (italy montenegro bosnia serbia hungary
                    slovenia))
  (bosnia          (croatia montenegro serbia))
  (montenegro      (croatia italy albania serbia bosnia))
  (albania         (italy greece macedonia serbia
                    montenegro))
  (greece          (italy cyprus bulgaria macedonia albania))
  (cyprus          (greece))
  (macedonia       (albania greece bulgaria serbia))
  (bulgaria        (macedonia greece romania serbia))
  (serbia          (montenegro albania macedonia bulgaria
                    romania hungary croatia bosnia))
  (romania         (serbia bulgaria hungary))
  (hungary         (slovenia croatia serbia romania slovakia
                    austria))
  (slovakia        (austria hungary poland czech-republic))
  (czech-republic  (germany austria slovakia poland))
  (poland          (germany czech-republic slovakia sweden))
  (denmark         (united-kingdom germany sweden norway))
  (sweden          (norway denmark germany poland finland))
  (norway          (united-kingdom denmark sweden finland
                    iceland))
  (finland         (sweden norway))
  (iceland         (ireland united-kingdom norway)))
@end example

The only use of @func{amb} is in the function that selects a color for a
nation.  We use @func{amb-permute}, rather than the plain @func{amb}, to
try assigning a different first color to the nations (statistically
speaking).

@example
(define (choose-color)
  ;;Every time we call this function: we start a new choice.
  ;;
  (amb-permute 'red 'yellow 'blue 'green))
@end example

We validate a possible solution with @func{amb-assert}, checking that a
node/nation has color different from the one of its neighbors:

@example
(define (validate-all-nodes-color all-nodes)
  (for-all validate-single-node-color all-nodes))
@end example

To build a ``better'' starting point, we also want to test the color of
a single node against the colors of its neighbors while we are building
the initial choice.  When calling this function: the neighbors may not
have a color yet: their @code{color} field can be set to @false{}.

@example
(define (validate-single-node-color node)
  (amb-assert (not (memq (node-color node)
                         (map node-color
                           (node-neighbors node))))))
@end example

The actual coloring function that selects a color for each nation and
validates the solution until all the constraints are satisfied:

@example
(define (color-nations nations)
  (with-ambiguous-choices
   ;;Build an initial choice.
   (for-each
       (lambda (nation)
         (node-color-set! nation (choose-color))
         (validate-single-node-color nation))
     nations)
   ;;Validate the choice and backtrack if needed.
   (validate-all-nodes-color nations)))
@end example

We also need to display the result:

@example
(define (print-colors nations)
  (for-each
      (lambda (nation)
        (print "~a: ~a\n"
               (node-name nation)
               (node-color nation))
        (for-each
            (lambda (neighbor)
              (print "\t~a: ~a\n"
                     (node-name neighbor)
                     (node-color neighbor)))
          (node-neighbors nation)))
    europe-facing-nations))

(define (print . args)
  (apply fprintf (current-error-port) args))
@end example

Run it:

@example
(color-nations europe-facing-nations)
(print-colors  europe-facing-nations)
@end example

@c page
@node simple-match
@section Simple destructuring match syntax


@cindex Library @library{vicare language-extensions simple-match}
@cindex @library{vicare language-extensions simple-match}, library


The library @library{vicare language-extensions simple-match} provides a
simple implementation of the destructuring--bind @func{match} syntax; it
is @strong{not} a fully featured @func{match} syntax.

It has two purposes: being a single macro transformer, without
dependencies on external libraries, it can be used in the code of
@value{PRJNAME}'s boot image; being simple, its code can be used as
starting point to implement more complex destructuring syntaxes.

The supported syntax is @strong{different} from the one of the popular
matching libraries by Alex Shinn and Andrew Wright.

@menu
* simple-match syntax::         Pattern matcher generator.
@end menu

@c page
@node simple-match syntax
@subsection Pattern matcher generator


The following bindings are exported by the library @library{vicare
languae-extensions simple-match}.  The auxiliary syntaxes are the
bindings exported by the library @library{vicare}, which are reexported
by this library.


@deffn Syntax match @meta{expr} @meta{clause} ...
@deffnx {Auxiliary Syntax} =>
@deffnx {Auxiliary Syntax} else
@deffnx {Auxiliary Syntax} let
@deffnx {Auxiliary Syntax} quote
@deffnx {Auxiliary Syntax} quasiquote
@deffnx {Auxiliary Syntax} syntax
@deffnx {Auxiliary Syntax} and
@deffnx {Auxiliary Syntax} or
@deffnx {Auxiliary Syntax} not
@deffnx {Auxiliary Syntax} apply
@deffnx {Auxiliary Syntax} eval
@deffnx {Auxiliary Syntax} {...}
@deffnx {Auxiliary Syntax} _
Match the symbolic expression @meta{expr} against the @meta{clause}
arguments.  Each clause must have one of the formats:

@example
(@meta{pattern} @meta{body} ...)
(@meta{pattern} (=> @meta{next}) @meta{body} ...)
(else @metao{body} @meta{body} ...)
@end example

@meta{expr} is evaluated once and the result is matched against each
@meta{pattern} in turn; the first to succeed causes the corresponding
@meta{body} forms to be evaluated as in @func{begin}, and the remaining
patterns are ignored.  However, if the @meta{next} identifier is
labeled, it may be used as a continuation to continue matching, allowing
for additional runtime tests on the pattern.

A clause with no body @code{(@meta{pattern})}, when matching the input
expression, causes the evaluation of @code{(values)} (which returns zero
values).
@end deffn


The syntax for the patterns is:

@table @samp
@item _
The literal underscore is the wildcard: it matches anything, it does not
reference any variable.

@example
(match "ciao"
  (_            #t)
  (else         #f))
@result{} #t

(match '(1 2 3)
  (_            #t)
  (else         #f))
@result{} #t

(match '(1 2 3)
  ((_ _ _)      #t)
  (else         #f))
@result{} #t

(match '(1 2 3)
  ((_ 2 _)      #t)
  (else         #f))
@result{} #t

(match '(1 2 3)
  ((_ 0 _)      #t)
  (else         #f))
@result{} #f
@end example

@item @meta{datum}
Matches if the input expression equals @meta{datum}.  The pattern
@meta{datum} can be a boolean, character, fixnum, bignum, ratnum,
flonum, cflonum, compnum, string or bytevector; such data is compared to
the input expression using type--specific predicates and unsafe
accessors.

@example
(match 1
  (1            #t)
  (else         #f))
@result{} #t
@end example

@item @meta{variable}
Variable reference: it matches the value bound to @meta{variable} using
@func{equal?}.

@example
(let ((X 1))
  (match 1
    (X          #t)
    (else       #f)))
@result{} #t

(let ((X 1))
  (match 1
    (X          X)
    (else       #f)))
@result{} 1
@end example

@item (let @meta{variable})
Bind the value of the input expression to @meta{variable}, which must be
an identifier; the variable is immediately available to be referenced in
the following subpatterns.  The empty @code{let} pattern is a syntax
error; the @code{let} pattern with multiple subpatterns is a syntax
error, with the exception of the variable with ellipsis.

@example
(match 1
  ((let X)      X)
  (else         #f))
@result{} 1

(match 1
  ((let X)      #\A)
  (else         #f))
@result{} #\A

(match '(1)
  ((let X)      X)
  (else         #f))
@result{} (1)

(match '(1)
  (((let X))    X)
  (else         #f))
@result{} 1

(match '(1 2 3)
  (((let X) (let Y) (let Z))
   (vector X Y Z))
  (else #f))
@result{} #(1 2 3)

(match '(1 2)
  (((let X) (let Y) (let Z))
   (vector X Y Z))
  (else #f))
@result{} #f

(match '(1 (2 3))
  (((let X) (let X) (let X))
   X)
  (else #f))
@result{} 3

(match 123
  ((and (let X) (eval (positive? X)))
   X)
  (else #f))
@result{} 123

(match '(1 2 3)
  (((and (apply number?)
         (let N1))
    . (and (apply (lambda (obj)
                    (for-all number? obj)))
           (let N)))
   (vector N1 N))
  (else #f))
@result{} #(1 (2 3))
@end example

@item (let @meta{variable} ...)
This pattern can appear only as last subpattern of a list or vector
pattern.  Bind the rest of the input expression to @meta{variable},
which must be an identifier, as a list; the variable is immediately
available to be referenced in the following subpatterns.

@example
(match '(1 2 3 4 5)
  (((let X) (let Y) (let Z ...))
   (vector X Y Z))
  (else #f))
@result{} #(1 2 (3 4 5))

(match '(1 2)
  (((let X) (let Y) (let Z ...))
   (vector X Y Z))
  (else #f))
@result{} #(1 2 ())

(match '(1 2 . 3)
  (((let X) (let Y) (let Z ...))
   (vector X Y Z))
  (else #f))
@result{} #f

(match '(1 2 3 4 . 5)
  (((let X) (let Y) (let Z ...))
   (vector X Y Z))
  (else #f))
@result{} #f

(match '(1 2 3)
  ((let id ...)         #\A)
   (else                #\B))
@error{} &syntax

(match '(1 2 3 4)
  (((and (apply number?) (let N1))
    (and (apply number?) (let N))
    ...)
   (vector N1 N))
  (else #f))
@result{} (#(1 2) #(1 3) #(1 4))
@end example

@item (quote @meta{datum})
A quoted datum; it matches if it is equal to the input expression
according to @func{equal?}.  As special case: if @meta{datum} is a
symbol, it is compared to the input expression with @func{eq?}.

@example
(match '(1 2 3)
  ('(1 2 3)     #t)
  (else         #f))
@result{} #t

(match '(1 X 3)
  ('(1 X 3)     #t)
  (else         #f))
@result{} #t

(match '(1 X 3)
  ((1 'X 3)     #t)
  (else         #f))
@result{} #t
@end example

@item (quasiquote @meta{datum})
A quasiquoted datum; it matches if it the result of the quasiquotation
is equal to the input expression according to @func{equal?}.

@example
(let ((X 2))
  (match '(2 2)
    (`(1 ,X)    #\A)
    (`(2 ,X)    #\B)
    (`(3 ,X)    #\C)
    (else       #f)))
@result{} #\B
@end example

@item (syntax @meta{pattern})
@itemx (syntax @meta{pattern} (@meta{literal} @dots{}))
A @func{syntax-case} pattern with optional literal identifiers; the
matching code is built as follows:

@example
(syntax-case input-expr (@meta{literal} @dots{})
  (@meta{pattern}
   #;success)
  (_
   #;failure))
@end example

@noindent
the body of the clause can access pattern variables in the same way they
are accessed from the output expression of a @func{syntax-case} use.

@example
(match '(1 2 3)
  ((syntax (1 2 3))
   #t)
  (else #f))
@result{} #t

;;match an identifier
(let ((ciao #f))
  (match #'ciao
    ((syntax ciao (ciao))
     #t)
    (else #f)))
@result{} #t

;;match pattern variables
(let ((ciao #f))
  (match '(1 2 3)
    ((syntax (a b c))
     (syntax->datum #'b))
    (else #f)))
@result{} 2
@end example

@item ()
@itemx (@metai{pattern} --- @metan{pattern})
Null or proper list of @math{N} elements.

@example
(match '()
  (()
   #t)
  (else #f))
@result{} #t

(match '(1 2 3)
  ((1 2 3)
   #t)
  (else #f))
@result{} #t
@end example

@item (@metai{pattern} --- @metan{pattern} . @metani{pattern})
Improper list of @math{N} or more elements.

@example
(match '(1 . 2)
  ((1 . 2)
   #t)
  (else #f))
@result{} #t

(match '(1 2 3 . 4)
  ((1 2 3 . 4)
   #t)
  (else #f))
@result{} #t
@end example

@item (@metai{pattern} --- @metan{pattern} @metani{pattern} ...)
List of @math{N} or more elements with terminating ellipsis; each
element of remainder must match @metani{pattern}.  The body is evaluated
once for every element matched by the pattern before the ellipsis and
the results are returned in a list.

@example
(match '(1)
  ((1 ...)      #t)
  (else         #f))
@result{} (#t)

(match '(1 1)
  ((1 ...)      #t)
  (else         #f))
@result{} (#t #t)

(match '(1 1 1)
  ((1 ...)      #t)
  (else         #f))
@result{} (#t #t #t)

(match '(1 2)
  ((0 1 ...)    #t)
  (else         #f))
@result{} #f

(match '(1 2 3)
  (((let X) ...)
   (+ 10 X))
  (else #f))
@result{} (11 12 13)

(match '(1 2 3)
  (((let X) (let Y) ...)
   (vector X Y))
  (else #f))
@result{} (#(1 2) #(1 3))

(match '((1 2 3) (4 5 6) (7 8 9))
  ((((let X) (let Y) (let Z)) ...)
   (vector X Y Z))
  (else #f))
@result{} (#(1 2 3) #(4 5 6) #(7 8 9))

(match '((1 2 3)
         (4 5 6)
         (7 8 9))
  ((((let X) (let Y) ...) ...)
   (vector X Y))
  (else #f))
@result{} ((#(1 2) #(1 3))
    (#(4 5) #(4 6))
    (#(7 8) #(7 9)))
@end example

@item #(@metai{pattern} --- @metan{pattern})
Vector of @math{N} elements.

@example
(match '#(1 2 3)
  (#(1 2 3)
   #t)
  (else #f))
@result{} #t
@end example

@item #(@metai{pattern} --- @metan{pattern} @metani{pattern} ...)
Vector of @math{N} or more elements with terminating ellipsis; each
element of remainder must match @metani{pattern}.  The body is evaluated
once for every element matched by the pattern before the ellipsis and
the results are returned in a list.

@example
(match '#(1 1 1)
  (#(1 ...)       #t)
  (else           #f))
@result{} (#t #t #t)
@end example

@item (and @meta{pattern} ---)
Matches if each @meta{pattern} matches the input expression.  The empty
@code{and} succeeds.

@example
(match 123
  ((and (apply fixnum?) (apply positive?))
   #t)
  (else #f))
@result{} #t

(match 123
  ((and (apply fixnum?) (let X))
   X)
  (else #f))
@result{} 123

(match 123
  ((and (let X) X)
   X)
  (else #f))
@result{} 123
@end example

@item (or @meta{pattern} ---)
Matches if at least one @meta{pattern} matches the input expression.
The empty @code{or} fails.

@example
(match 1
  ((or 1 2)
   #t)
  (else #f))
@result{} #t

(match 1
  ((or (apply fixnum?) (apply bignum?))
   #t)
  (else #f))
@result{} #t
@end example

@item (not @meta{pattern})
Matches if the subpattern @meta{pattern} does @strong{not} match the
input expression.  The empty not fails.  The empty @code{not} pattern is
a syntax error; the @code{not} pattern with multiple subpatterns is a
syntax error.

@example
(match 9
  ((not 1)
   #t)
  (else #f))
@result{} #t

(match "ciao"
  ((not (apply fixnum?))
   #t)
  (else #f))
@result{} #t
@end example

@item (apply @meta{pred} ---)
Each @meta{pred} subpattern must be an expression; every time this
pattern is matched against an input expression: @meta{pred} is
evaluated; the value returned by @meta{pred} must be a predicate
function.  This pattern matches if all the predicate functions return
true when applied to the input expression; the empty @code{apply}
pattern is a syntax error.

@example
(match 1
  ((apply fixnum? positive?)
   #t)
  (else #f))
@result{} #t

(match 1
  ((apply (lambda (x)
            (and (fixnum?   x)
                 (positive? x))))
   #t)
  (else #f))
@result{} #t
@end example

@item (eval @meta{expr})
The subpattern @meta{expr} must be expression; every time this pattern
is matched against an input expression: @meta{expr} is evaluated.  This
pattern matches if the result of @meta{expr} is true.  The empty
@code{eval} pattern is a syntax error; the @code{eval} pattern with
multiple subpatterns is a syntax error.

@example
(match 1
  ((eval #t)
   #t)
  (else #f))
@result{} #t

(match 1
  ((eval #f)    #\A)
  (else         #f))
@result{} #t

(match #t
  ((and (let X) (eval X))
   #t)
  (else #f))
@result{} #t

(match #f
  ((and (let X) (eval X))
   #t)
  (else #f))
@result{} #f

(match '(1 2)
  (((let X) (eval X)) ;ignores 2, but consumes it
   X)
  (else #f))
@result{} 1

(match '(1 2 3)
  (((let X) (eval X) (let Y)) ;ignores 2, but consumes it
   (vector X Y))
  (else #f))
@result{} #(1 3)
@end example
@end table

When the escape identifier is present, it is bound to a thunk to be
evaluated to jump to matching the next pattern or to the ``no match''
error.

@example
(match '(1 2 3)
  ((1 2 3)
   (=> escape)
   #t)
  (else #f))
@result{} #t

(match '(1 2 0)
  ((1 2 3)
   (=> escape)
   #t)
  (else #f))
@result{} #f

(match '(1 2 3)
  ((1 2 3)
   (=> escape)
   (escape))
  (else #f))
@result{} #f

(match '(1 2 3)
  ((1 2 3)
   (=> escape)
   (escape))
  ((1 2 3)
   #t)
  (else #f))
@result{} #t

(match '(1 2 3)
  ((1 2 3)
   (=> escape)
   (escape)))
@error{} &error
@end example

@c page
@node sentinels
@section Sentinel values


@cindex @library{vicare language-extensions sentinels}, library
@cindex Library @library{vicare language-extensions sentinels}


The library @library{vicare language-extensions sentinels} defines
unique values and predicates to test them.  Sentinel values can be used
as terminators for sequences or as values for uninitialised storage
locations.


@defvr Constant sentinel
The sentinel value.
@end defvr


As usage example, the following form makes use of the sentinel as
terminator for a list:

@example
(let ((ell (list 1 2 3 4 5 sentinel)))
  (let loop ((ell ell)
             (res '()))
    (if (sentinel? (car ell))
        res
      (loop (cdr ell) (cons (car ell) res)))))
@result{} (5 4 3 2 1))
@end example

@noindent
the following form defines an iterator closure using the sentinel to
signal the end of the iteration:

@example
(let* ((ell  '(1 2 3 4 5))
       (iter (lambda ()
               (let ((ell ell))
                 (if (null? ell)
                     sentinel
                   (begin
                     (car ell)
                     (set! ell (cdr ell))))))))
  (let loop ((res '()))
    (let ((v (iter)))
      (if (sentinel? v)
          res
        (loop (cons v res))))))
@result{} (5 4 3 2 1)
@end example


@defun make-sentinel
Return a new sentinel value.  @func{sentinel?} will return @true{} when
applied to such a value, but new sentinel values are meant to be checked
with @func{eq?}.

New sentinels can be used in situations where a unique terminator is
needed: when we need to distinguish @samp{sentinel} from a temporary
sentinel we need for a specific operation.
@end defun


@defun sentinel? @var{obj}
Return @true{} if @var{obj} a sentinel value.
@end defun

@c ------------------------------------------------------------

@subsubheading Undefined value


@defvr Constant undefined
The undefined value.
@end defvr


@deffn {Integrable Function} undefined? @var{obj}
Return @true{} if @var{obj} is @func{eq?} to @code{undefined}; otherwise
return @false{}.
@end deffn


@deffn {Integrable Function} defined? @var{obj}
Return @true{} if @var{obj} is @strong{not} @func{eq?} to
@code{undefined}; otherwise return @false{}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Unspecified value


@defvr Constant unspecified
The unspecified value.
@end defvr


@deffn {Integrable Function} unspecified? @var{obj}
Return @true{} if @var{obj} is @func{eq?} to @code{unspecified};
otherwise return @false{}.
@end deffn


@deffn {Integrable Function} specified? @var{obj}
Return @true{} if @var{obj} is @strong{not} @func{eq?} to
@code{unspecified}; otherwise return @false{}.
@end deffn

@c page
@node namespaces
@section Identifiers namespaces


@cindex @library{vicare language-extensions namespaces}, library
@cindex Library @library{vicare language-extensions namespaces}


The library @library{vicare language-extensions namespaces} allows the
definition of @dfn{namespaces}; Vicare's namespaces are similar to
Vicare's modules, indeed a namespace definition expands into a module.
In addition: namespaces are associated to a macro which can be used as
``gate'' to access some of the bindings defined in, or visible from, the
namespace.

Here is a simple example of namespace:

@example
(import (vicare)
  (vicare language-extensions namespaces))

(define-namespace hellos::
  (export ciao salut)
  (define (ciao)
    'ciao)
  (define-syntax salut
    (syntax-rules ()
      ((_)
       'salut))))

(hellos:: ciao)         @result{} ciao
(hellos:: salut)        @result{} salut
@end example

@noindent
namespaces can be nested:

@example
(import (vicare)
  (vicare language-extensions namespaces))

(define-namespace hellos::
  (export ciao salut japanese::)
  (define (ciao)
    'ciao)
  (define (salut)
    'salut)
  (define-namespace japanese::
    (export ohayo)
    (define (ohayo)
      'ohayo)))

(hellos:: ciao)                 @result{} ciao
(hellos:: salut)                @result{} salut
(hellos:: japanese:: ohayo)     @result{} ohayo
@end example

@noindent
the syntax @func{using} can ``import'' bindings from a namespace into
the current lexical context:

@example
(import (vicare)
  (vicare language-extensions namespaces))

(define-namespace hellos::
  (export ciao salut)
  (define (ciao)
    'ciao)
  (define-syntax salut
    (syntax-rules ()
      ((_)
       'salut))))

(using hellos::)
(ciao)          @result{} ciao
(salut)         @result{} salut
@end example

@noindent
while not enforced it seems a good idea to suffix namespace names with
@code{::}.

The following bindings are exported by the library @library{vicare
language-extensions namespaces}.


@deffn Syntax define-namespace @meta{name} (export @meta{member} @dots{}) @meta{body} @dots{}
@deffnx {Auxiliary Syntax} export
Define a new namespace wrapping a module and a gate syntax bound to
@meta{name}.  The identifier @func{export} is the one exported by
@library{vicare}.  The forms @meta{body} are evaluated inside the
module.

The identifiers @meta{member} are ``public'': they can be accessed with
the syntax:

@example
(@meta{name} @meta{member} @meta{arg} ...)
@end example

@noindent
where the optional arguments @meta{arg} are handed to @meta{member}
untouched; only the ``application'' syntax is available.  Notice that,
while we cannot access variables from a namespace with the normal
variable access syntax, we can export parameter functions and also
define variable setter and getter syntaxes as follows:

@example
(define-syntax-rule (define-variable ?name ?init-value)
  (define the-variable ?init-value)
  (define-syntax ?name
    (syntax-rules ()
      ((_)
       the-variable)
      ((_ ?new-value)
       (set! the-variable ?new-value)))))

(define-variable blue 123)
(blue)          @result{} 123
(blue 456)
(blue)          @result{} 456
@end example
@end deffn


@deffn Syntax using @metao{name} @meta{name} @dots{}
Import public bindings from one or more namespaces into the current
lexical context.
@end deffn

@c page
@node variables
@section Defining storage locations


@cindex @library{vicare language-extensions variables}, library
@cindex Library @library{vicare language-extensions variables}


The library @library{vicare language-extensions variables} provides a
way to define simple storage locations similar to the variables used in
many languages.  The @objtype{variable} type is disjoint from the other
types.

The following bindings are exported by the library @library{vicare
language-extensions variables}; the bindings whose name is prefixed with
@code{$} are unsafe operations: they do @strong{not} validate their
arguments before accessing them.


@defun make-variable
@defunx make-variable @var{obj}
Build and return a new @objtype{variable} object.  The
@objtype{variable} is initialised to @var{obj}, which defaults to the
return value of @code{(void)}.
@end defun


@defun variable? @var{obj}
Return @true{} if @var{obj} is a @objtype{variable} object, else return
@false{}.
@end defun


@defun variable-set! @var{variable} @var{obj}
@defunx variable-ref @var{variable}
@defunx $variable-set! @var{variable} @var{obj}
@defunx $variable-ref @var{variable}
Setter and getter for the value of @objtype{variable} objects.
@end defun


@deffn Syntax define-variable @meta{name}
@deffnx Syntax define-variable @meta{name} @var{obj}
@deffnx Syntax define-variable (@meta{name} . @meta{formals}) @meta{body}
Like @func{define}, but store the value in a newly built
@objtype{variable} object, which is then bound to @meta{name}.  Example:

@example
(import (vicare)
  (vicare language-extensions variables))

(define-variable v 123)
v @result{} 123
(set! v 456)
v @result{} 456
@end example

While @func{define} defines a binding which, when exported by a library,
cannot be modified, @func{define-variable} allocates a storage location,
so the value bound to @meta{name} can be modified at will.
@end deffn


@deffn Syntax define-variable-alias @meta{name} @meta{variable-expr}
@deffnx Syntax $define-variable-alias @meta{name} @meta{variable-expr}
Like the second form of @func{define-variable}, but accept as second
argument an expression which, when evaluated, returns a
@objtype{variable} object.
@end deffn

@c page
@node syntaxes
@section Language syntactic extensions


@cindex Library @library{vicare language-extensions syntaxes}
@cindex @library{vicare language-extensions syntaxes}, library


The library @library{vicare language-extensions syntaxes} provides
bindings to macros that extend the Scheme language implemented by
@library{vicare} and @library{rnrs}.

@menu
* syntaxes defines::            Special definitions.
* syntaxes bindings::           Special local bindings.
* syntaxes sequencing::         Sequencing execution.
* syntaxes conversion::         Converting common arguments.
* syntaxes args::               Arguments validation.
* syntaxes misc::               Miscellaneous syntaxes.
@end menu

@c page
@node syntaxes defines
@subsection Special definitions


The following bindings are exported by the library @library{vicare
language-extensions syntaxes}.


@defmac define-exact-integer->symbol-function @meta{who} (@meta{code} ...)
Define a function used to convert exact intgers to the corresponding
symbolic name.  Expand to:

@example
(define (@meta{who} code)
  (define who '@meta{who})
  (with-arguments-validation (who)
      ((exact-integer      code))
    (case code
      ((@meta{code})     '@meta{code})
      ...
      (else #f))))
@end example
@end defmac

@c page
@node syntaxes bindings
@subsection Special local bindings


The following bindings are exported by the library @library{vicare
language-extensions syntaxes}.


@defmac let-inline ((@meta{var} @meta{expr}) ...) @metao{body} . @meta{body}
Wrapper for @func{let-syntax}, expand to:

@example
(let-syntax ((@meta{var} (identifier-syntax @meta{expr}))
             ...)
  @metao{body} . @meta{body})
@end example
@end defmac


@defmac {let*-inline} () @metao{body} . @meta{body}
@defmacx {let*-inline} ((@metao{var} @metao{expr}) (@meta{var} @meta{expr}) ...) @metao{body} . @meta{body}
Wrapper for @func{let-syntax}, expand to:

@example
(let-syntax ((@metao{var} (identifier-syntax @meta{expr})))
  (let*-inline ((@meta{var} @meta{expr})
                ...)
    @metao{body} . @meta{body}))
@end example
@end defmac

@c page
@node syntaxes sequencing
@subsection Sequencing execution


The following bindings are exported by the library @library{vicare
language-extensions syntaxes}.


@defmac begin0-let ((@metao{var} @metao{init}) (@meta{var} @meta{init}) ...) @metao{form} @meta{form} ...
Expand to:

@example
(let ((@metao{var} @metao{init})
      (@meta{var}  @meta{init})
      ...)
  @metao{form} @meta{form} ...
  @metao{var})
@end example
@end defmac

@c page
@node syntaxes conversion
@subsection Converting common arguments


The following bindings are exported by the library @library{vicare
language-extensions syntaxes}.


@defmac with-pathnames ((@meta{pathname.bv} @meta{pathname}) ...) . @meta{body}
Used to preprocess function arguments which must be bytevectors or
strings representing pathnames; the strings are converted to
bytevectors.  This macro assumes that the arguments have already been
validated.  Expand to:

@example
(let ((@meta{pathname.bv} (let ((pathname @meta{pathname}))
                      (if (bytevector? pathname)
                          pathname
                        ((string->filename-func) pathname))))
      ...)
  . @meta{body})
@end example
@end defmac


@defmac with-bytevectors ((@meta{value.bv} @meta{value}) ...) . @meta{body}
Used to preprocess function arguments which must be bytevectors or
strings; the strings are converted to bytevectors.  This macro assumes
that the arguments have already been validated.  Expand to:

@example
(let ((@meta{value.bv} (let ((V @meta{value}))
                   (if (bytevector? V)
                       V
                     (string->latin1 V))))
      ...)
  . @meta{body})
@end example
@end defmac


@defmac with-bytevectors/or-false ((@meta{value.bv} @meta{value}) ...) . @meta{body}
Used to preprocess function arguments which must be bytevectors, strings
or false; the strings are converted to bytevectors.  This macro assumes
that the arguments have already been validated.  Expand to:

@example
(let ((?value.bv (let ((V ?value))
                   (cond ((bytevector? V)
                          V)
                         ((string? V)
                          (string->latin1 V))
                         (else V))))
      ...)
  . ?body)
@end example
@end defmac

@c page
@node syntaxes args
@subsection Arguments validation


The following bindings are imported and reexported by @library{vicare
language-extension syntaxes} from the library @library{vicare arguments
validation}:

@example
define-argument-validation
with-arguments-validation
with-dangerous-arguments-validation
arguments-validation-forms
@end example

@c page
@node syntaxes misc
@subsection Miscellaneous syntaxes


The following bindings are exported by the library @library{vicare
language-extensions syntaxes}.


@defmac callet @meta{func} @meta{arg} ...
Expand to a call to @meta{func}, which must evaluate to a function,
applied to the arguments resulting from processing the @var{arg}
syntaxes; @var{arg} can be one among:

@example
@meta{expr}
(@meta{name} @meta{expr})
@end example

@noindent
where @meta{expr} is an expression that will become the actual argument
and @meta{name} must be an identifier used to comment the meaning of the
arguments.  Examples:

@example
(callet printf
        (string "ciao ~a")
        (arg    123))
@expansion{} (printf "ciao ~a" 123)
@end example
@end defmac


@defmac callet* @meta{func} @meta{arg} ...
Like @func{callet}, but define local @func{let*} bindings for the
@var{arg} with name.  Example:

@example
(callet printf
        (string "ciao ~a")
        (arg    123))
@expansion{} (let* ((string "ciao ~a")
           (arg    123))
      (printf string arg))
@end example
@end defmac

@c page
@node makers
@section Maker syntaxes


@cindex @library{vicare language-extensions makers}, library
@cindex Library @library{vicare language-extensions makers}


The library @library{vicare language-extensions makers} provides a
constructor for macro definitions; its nominal purpose is to define
macros which wrap constructors for records and similar entities,
allowing the use of ``keywords'' to specify non--positional arguments.

To avoid identifiers collision, it is suggested to import this library
with prefix @samp{mk.}, as in:

@example
(import (vicare)
  (prefix (vicare language-extensions makers) mk.))
@end example

@menu
* makers intro::                Introduction to maker macros.
* makers api::                  Defining makers.
@end menu

@c page
@node makers intro
@subsection Introduction to maker macros


It happens to define a function or macro accepting a number of arguments
greater than 3:

@example
(define (the-func a b c d e f g h i)
  ...)
@end example

@noindent
in these cases it can be difficult to remember the order of the
arguments; it can also be desirable to define default values for some or
all of the arguments, so that at the call site some arguments can be
omitted in the source code.  The syntax @func{define-maker} implements a
solution to this problem.

The following examples show the expansion of a simple maker with neither
fixed nor variable arguments, only optional clauses arguments:

@example
(import (vicare)
  (prefix (vicare language-extensions makers) mk.))

(define-auxiliary-syntaxes alpha: beta: gamma:)

(define-maker doit
  list ((alpha:     1)
        (beta:      2)
        (gamma:     3)))

(doit)                  @expansion{} (list 1 2 3)

(doit (alpha:   10))    @expansion{} (list 10 2 3)
(doit (beta:    20))    @expansion{} (list 1 20 3)
(doit (gamma:   30))    @expansion{} (list 1 2 30)

(doit (alpha:   10)
      (beta:    20))    @expansion{} (list 10 20 3)

(doit (alpha:   10)
      (gamma:   30))    @expansion{} (list 10 2 30)

(doit (gamma:   30)
      (beta:    20))    @expansion{} (list 1 20 30)

(doit (alpha:   10)
      (beta:    20)
      (gamma:   30))    @expansion{} (list 10 20 30)

(let ((b 7))
  (doit (beta:  (+ 6 (* 2 b)))
        (alpha: (+ 2 8)))
  @expansion{} (list (+ 2 8)
            (+ 6 (* 2 b))
            3)
  #f)

(doit (alpha: 10 20 30))
@expansion{} (list 1 (list 10 20 30) 3)
@end example

@noindent
notice the last example: when multiple values are used in an argument's
clause, they are enclosed in a @func{list} form; the following examples
show the expansion of a maker with both fixed and variable arguments,
plus optional clauses arguments:

@example
(import (vicare)
  (prefix (vicare language-extensions makers) mk.))

(define-auxiliary-syntaxes alpha: beta: gamma:)

(define-maker (doit a b)
    (list #\a #\b)
  ((alpha:  1)
   (beta:   2)
   (gamma:  3)))


(doit #\p #\q)          @expansion{} (list #\a #\b #\p #\q 1 2 3)

(doit #\p #\q
      (alpha: 10))      @expansion{} (list #\a #\b #\p #\q 10 2 3)

(doit #\p #\q
      (beta: 20))       @expansion{} (list #\a #\b #\p #\q 1 20 3)

(doit #\p #\q
      (gamma: 30))      @expansion{} (list #\a #\b #\p #\q 1 2 30)

(doit #\p #\q
      (alpha: 10)
      (beta:  20))      @expansion{} (list #\a #\b #\p #\q 10 20 3)

(doit #\p #\q
      (alpha: 10)
      (gamma: 30))      @expansion{} (list #\a #\b #\p #\q 10 2 30)

(doit #\p #\q
      (gamma: 30)
      (beta:  20))      @expansion{} (list #\a #\b #\p #\q 1 20 30)
@end example

Each default value can be any expression and it is evaluated every time
the maker is used:

@example
(import (vicare)
  (prefix (vicare language-extensions makers) mk.))

(define-auxiliary-syntaxes alpha: beta: gamma:)

(define g
  (let ((counter 0))
    (lambda ()
      (set! counter (+ 1 counter))
      counter)))

(define default2 (- (/ 9 3) 1))

(define-maker doit
  list ((alpha:     1)
        (beta:      default2)
        (gamma:     (g))))

(doit)                  @result{} ( 1  2  1)
(doit (alpha: 10))      @result{} (10  2  2)
(doit (beta:  20))      @result{} ( 1 20  3)
(doit (gamma: 30))      @result{} ( 1  2 30)
@end example

A maker invocation can expand itself into another macro use; this allows
us to detect whether an optional argument was used or not:

@example
(import (vicare)
  (prefix (vicare language-extensions makers) mk.)
  (vicare language-extensions sentinels))

(define-auxiliary-syntaxes alpha: beta: gamma:)

(define-maker doit
    subdoit
  ((alpha:  1)
   (beta:   2)
   (gamma:  sentinel)))

(define-syntax subdoit
  (lambda (stx)
    (syntax-case stx ()
      ((_ ?alpha ?beta ?gamma)
       (and (identifier? #'?gamma)
            (free-identifier=? #'?gamma #'sentinel))
       #'(list ?alpha ?beta 3))
      ((_ ?alpha ?beta ?gamma)
       #'(list ?alpha ?beta ?gamma))
      )))

(doit)                  @result{} ( 1  2  3)
(doit (alpha: 10))      @result{} (10  2  3)
(doit (beta:  20))      @result{} ( 1 20  3)
(doit (gamma: 30))      @result{} ( 1  2 30)
@end example

@noindent
and also to ``unpack'' multiple values used in the same argument clause:

@example
(import (vicare)
  (prefix (vicare language-extensions makers) mk.)
  (vicare language-extensions sentinels))

(define-auxiliary-syntaxes alpha: beta: gamma:)

(define-maker doit
  subdoit ((alpha:  1)
           (beta:   2)
           (gamma:  3)))

(define-syntax subdoit
  (lambda (stx)
    (syntax-case stx (list)
      ((_ ?alpha (list ?beta0 ...) ?gamma)
       #'(list ?alpha ?beta0 ... ?gamma))
      ((_ ?alpha ?beta ?gamma)
       #'(list ?alpha ?beta ?gamma))
      )))

(doit (alpha: 10)
       (beta: #\a #\b #\c)
       (gamma: 30))
@result{} (10 #\a #\b #\c 30)
@end example

We can define a maker in the body of a library and export it; we just
have to remember to export the auxiliary syntaxes, too:

@example
(library (the-lib)
  (export doit alpha beta gamma)
  (import (vicare)
    (prefix (vicare language-extensions makers) mk.))
  (define-auxiliary-syntaxes alpha beta gamma)
  (define-maker doit
    list ((alpha     1)
          (beta      2)
          (gamma     3))))

(library (exec)
  (export)
  (import (rnrs)
    (prefix (the-lib) lib.))
  (lib.doit)                  @expansion{} (list 1 2 3)
  (lib.doit (lib.alpha   10)) @expansion{} (list 10 2 3)
  (lib.doit (lib.beta    20)) @expansion{} (list 1 20 3)
  (lib.doit (lib.gamma   30)) @expansion{} (list 1 2 30)
  )
@end example

A number of options can be specified to customise the parsing of
clauses.  We can specify if a clause is mandatory or optional:

@example
(import (vicare)
  (prefix (vicare language-extensions makers) mk.))

(define-auxiliary-syntaxes alpha: beta: gamma:)

(define-maker doit
  list ((alpha:     1 (mk.mandatory))
        (beta:      2 (mk.optional))
        (gamma:     3)))

(doit (alpha: 10))              @expansion{} (list 10 2 3)
(doit (beta:  20))              @error{} missing clause "alpha:"
@end example

@noindent
the default is for all the clauses to be optional.  We can specify that
a clause must be used along one or more other clauses:

@example
(import (vicare)
  (prefix (vicare language-extensions makers) mk.))

(define-auxiliary-syntaxes alpha: beta: gamma:)

(define-maker doit
  list ((alpha:     1 (mk.with beta: gamma:))
        (beta:      2)
        (gamma:     3)))

(doit (alpha: 10)
      (beta:  20)
      (gamma: 30))              @expansion{} (list 10 20 30)

(doit (beta: 20))               @expansion{} (list 1 20 3)

(doit (alpha: 10)
      (gamma: 30))              @error{} missing clause "beta:"
@end example

@noindent
or we can specify that a clause must not be used along one or more other
clauses:

@example
(import (vicare)
  (prefix (vicare language-extensions makers) mk.))

(define-auxiliary-syntax alpha: beta: gamma:)

(define-maker doit
  list ((alpha:     1 (mk.without beta: gamma:))
        (beta:      2)
        (gamma:     3)))

(doit (alpha: 10)
      (beta:  20)
      (gamma: 30))              @error{} invalid clauses mix

(doit (beta: 20))               @expansion{} (list 1 20 3)
@end example

@c page
@node makers api
@subsection Defining makers


The following bindings are exported by the @library{vicare
language-extensions makers} library.


@deffn Macro define-maker @var{name-spec} @var{maker-sexp} @var{keywords-defaults-options}
@deffnx {Auxiliary Syntax} mandatory
@deffnx {Auxiliary Syntax} optional
@deffnx {Auxiliary Syntax} with @var{identifier} ...
@deffnx {Auxiliary Syntax} without @var{identifier} ...
Define a new maker macro.  @var{name-spec} has one of the forms:

@example
@var{name-identifier}
(@var{name-identifier} @var{positional-arg} ...)
@end example

@noindent
where @var{name-identifier} is the name of the defined macro and each
@var{positional-arg} is an identifier, name of a mandatory positional
argument for the macro.

@var{maker-sexp} has one of the forms:

@example
@varo{maker-expr}
(@varo{maker-expr} @var{maker-expr} ...)
@end example

@noindent
where each @var{maker-expr} is a macro keyword or an expression
evaluated in the lexical context of the @func{define-maker} macro use;
the expressions are evaluated every time the maker is used.

@var{keywords-defaults-options} defines optional arguments selected with an
auxiliary syntax and a value; it has the form:

@example
(@var{clause-spec} ...)
@end example

@noindent
where each @var{clause-spec} has the form:

@example
(@var{auxiliary-syntax} @var{default-expr})
(@var{auxiliary-syntax} @var{default-expr} @var{option} ...)
@end example

@noindent
where each @var{auxiliary-syntax} is an identifier and
@var{default-expr} is an expression representing the default value for
the argument; the expressions are all evaluated in the lexical context
of the @func{define-maker} macro use, the expressions are evaluated
every time the maker is used.

Notice that the @var{auxiliary-syntax} identifiers are matched against
the values in the macro use by comparing the syntax objects with
@func{free-identifier=?}.

Each of the @var{option} forms can be one among:

@example
(mandatory)
(optional)
(with @var{identifier} ...)
(without @var{identifier} ...)
@end example

@noindent
where the first two specify if the current clause is mandatory or
optional; the @func{with} option selects a list of clauses that must be
present when the current clause is used; the @func{without} option
selects a list of clauses that must not be present when the current
clause is used.  Each clause can be used at most once;
@clause{mandatory} cannot appear along with @clause{optional}.

When the new macro is used without optional auxiliary syntaxes, it is
expanded to:

@example
;; single maker expression, no positional arguments
(@var{maker-expr-result})

;; single maker expression, positional arguments
(@var{maker-expr-result}
 @varo{positional-arg} @var{positional-arg} ...)

;; multiple maker expressions, no positional arguments
(@varo{maker-expr-result} @var{maker-expr-result} ...)

;; multiple maker expressions, positional arguments
(@varo{maker-expr-result} @var{maker-expr-result} ...
 @varo{positional-arg} @var{positional-arg} ...)
@end example

When the new macro is defined with optional auxiliary syntaxes, the
expressions in the given syntax clauses, or the default expressions, are
appended to the output form in the same order as the corresponding
syntaxes in @var{keywords-defaults-options}.

It is an error if the generated maker is invoked with a clause used
multiple times.

When the clause of a generated maker is used with multiple values: the
values are enclosed in a @func{list} form and the result is used as
argument for the maker expression; for example:

@example
(import (vicare)
  (prefix (vicare language-extensions makers) mk.))

(define-syntax alpha:)

(mk.define-maker doit
    vector
  ((alpha: (list 1 2 3))))

(doit)                   @expansion{} (vector (list 1 2 3))
(doit (alpha: 10 20 30)) @expansion{} (vector (list 10 20 30))
@end example
@end deffn

@c page
@node custom-ports
@section Custom ports


@cindex Library @library{vicare language-extensions custom-ports}
@cindex @library{vicare language-extensions custom-ports}, library

The library @library{vicare language-extensions custom-ports} implements
special custom Scheme input and output ports.

@menu
* custom-ports pairs::          Port pairs.
@end menu

@c page
@node custom-ports pairs
@subsection Port pairs


Port pairs are Scheme ports connected together so that data written to
one port is read from the other port.

Forking a @value{PRJNAME} process does @strong{not} allow the use of
port pairs to communicate between processes; it is rather possible to
use port pairs to communicate among coroutines, @vicareref{iklib
coroutines, Running coroutines}.  To communicate between processes we
have to use the @posix{} library and create pipes (@pxref{posix fd pipe,
pipe}) or socket pairs (@pxref{posix socket socket, socketpair}).

The following bindings are exported by the library @library{vicare
language-extensions custom-ports}.


@defun open-binary-input-port-pair
Return two values being binary ports: input the first, output the
second.  Such ports are connected together so that data written to the
output port is read from the input port.
@end defun


@defun open-binary-output-port-pair
Return two values being binary ports: output the first, input the
second.  Such ports are connected together so that data written to the
output port is read from the input port.
@end defun


@defun open-binary-input/output-port-pair
Return two values being binary ports: input/output the first,
input/output the second.  Such ports are connected together so that data
written to one port is read from the other port.
@end defun


@defun open-textual-input-port-pair
Return two values being textual ports: input the first, output the
second.  Such ports are connected together so that data written to the
output port is read from the input port.
@end defun


@defun open-textual-output-port-pair
Return two values being textual ports: output the first, input the
second.  Such ports are connected together so that data written to the
output port is read from the input port.
@end defun


@defun open-textual-input/output-port-pair
Return two values being textual ports: input/output the first,
input/output the second.  Such ports are connected together so that data
written to one port is read from the other port.
@end defun

@c page
@node asciis
@section Utilities for @ascii{} characters


@cindex @library{vicare language-extensions ascii-chars}, library
@cindex Library @library{vicare language-extensions ascii-chars}


The library @library{vicare language-extensions ascii-chars} provides
functions and macros dealing with fixnums representing characters in
@ascii{} encoding range.

@menu
* asciis generic::              Generic utilities.
* asciis conversion::           Conversion utilities.
* asciis predicates::           Character predicates.
* asciis uri::                  Character predicates related to @rfc{}
                                3986, Uniform Resource Identifiers.
@end menu

@c page
@node asciis generic
@subsection Generic utilities


The following bindings are exported by the library @library{vicare
language-extensions ascii-chars}.  The identifiers whose name is
prefixed with @samp{$} are bound to unsafe operations: they do
@strong{not} validate the arguments and applying them to invalid
arguments leads to undefined behaviour.


@deffn Function fixnum-in-ascii-range? @var{obj}
@deffnx Syntax $fixnum-in-ascii-range? @var{obj}
Return @true{} if @var{obj} is a fixnum representing a character in
@ascii{} encoding.
@end deffn


@deffn Function fixnum-in-base10-range? @var{obj}
@deffnx Syntax $fixnum-in-base10-range? @var{obj}
Return @true{} if @var{obj} is a fixnum in the range @math{[0, 9]}.
@end deffn


@deffn Function fixnum-in-base16-range? @var{obj}
@deffnx Syntax $fixnum-in-base16-range? @var{obj}
Return @true{} if @var{obj} is a fixnum in the range @math{[0, 15]}.
@end deffn


@deffn Function ascii-upper-case? @var{fx}
@deffnx Function ascii-lower-case? @var{fx}
@deffnx Function ascii-title-case? @var{fx}
@deffnx Syntax $ascii-upper-case? @var{fx}
@deffnx Syntax $ascii-lower-case? @var{fx}
@deffnx Syntax $ascii-title-case? @var{fx}
Return @true{} if @var{fx} represents an upper case or lower case letter
character, otherwise return @false{}.
@end deffn


@deffn Function ascii-cased? @var{fx}
@deffnx Syntax $ascii-cased? @var{fx}
Return @true{} if @var{fx} represents a letter character, which can be
converted to upper or lower case, otherwise return @false{}.
@end deffn


@deffn Function ascii-alphabetic? @var{fx}
@deffnx Syntax $ascii-alphabetic? @var{fx}
Return @true{} if @var{fx} represents a letter character, otherwise
return @false{}.
@end deffn


@deffn Function ascii-dec-digit? @var{fx}
@deffnx Syntax $ascii-dec-digit? @var{fx}
Return @true{} if @var{fx} represents a decimal digit character,
otherwise return @false{}.
@end deffn


@deffn Function ascii-hex-digit? @var{fx}
@deffnx Syntax $ascii-hex-digit? @var{fx}
Return @true{} if @var{fx} represents a hexadecimal digit character,
otherwise return @false{}.
@end deffn


@deffn Function ascii-alpha-digit? @var{fx}
@deffnx Syntax $ascii-alpha-digit? @var{fx}
Return @true{} if @var{fx} represents a letter or a decimal digit
character, otherwise return @false{}.
@end deffn


@deffn Function ascii-upcase @var{fx}
@deffnx Function ascii-downcase @var{fx}
@deffnx Function ascii-titlecase @var{fx}
@deffnx Syntax $ascii-upcase @var{fx}
@deffnx Syntax $ascii-downcase @var{fx}
@deffnx Syntax $ascii-titlecase @var{fx}
Return a fixnum representing the upper case or lower case version of
@var{fx}; return @var{fx} itself if it represents an uncased character.
@end deffn

@c page
@node asciis conversion
@subsection Conversion utilities


The following bindings are exported by the library @library{vicare
language-extensions ascii-chars}.  The identifiers whose name is
prefixed with @samp{$} are bound to unsafe operations: they do
@strong{not} validate the arguments and applying them to invalid
arguments leads to undefined behaviour.


@deffn Function ascii-dec->fixnum @var{fx}
@deffnx Syntax $ascii-dec->fixnum @var{fx}
Given a fixnum representing a decimal digit in @ascii{} encoding: return
the corresponding fixnum in the range @math{[0, 9]}.

@example
(ascii-dec->fixnum (char->integer #\5))
@result{} 5
@end example
@end deffn


@deffn Function fixnum->ascii-dec @var{fx}
@deffnx Syntax $fixnum->ascii-dec @var{fx}
Given a fixnum in the range @math{[0, 9]}: return the corresponding
fixnum representing the decimal digit in @ascii{} encoding.

@example
(fixnum->ascii-dec 5)
@result{} (char->integer #\5)
@end example
@end deffn


@deffn Function ascii-hex->fixnum @var{fx}
@deffnx Syntax $ascii-hex->fixnum @var{fx}
Given a fixnum representing a hexadecimal digit in @ascii{} encoding:
return the corresponding fixnum in the range @math{[0, 15]}.

@example
(ascii-hex->fixnum (char->integer #\5))
@result{} 5

(ascii-hex->fixnum (char->integer #\A))
@result{} 10
@end example
@end deffn


@deffn Function fixnum->ascii-hex @var{fx}
@deffnx Syntax $fixnum->ascii-hex @var{fx}
Given a fixnum in the range @math{[0, 15]}: return the corresponding
fixnum representing the hexadecimal digit in @ascii{} encoding.

@example
(fixnum->ascii-hex 5)
@result{} (char->integer #\5)

(fixnum->ascii-hex 10)
@result{} (char->integer #\A)
@end example
@end deffn

@c page
@node asciis predicates
@subsection Character predicates


The following bindings are exported by the library @library{vicare
language-extensions ascii-chars}.  The identifiers whose name is
prefixed with @samp{$} are bound to unsafe operations: they do
@strong{not} validate the arguments and applying them to invalid
arguments leads to undefined behaviour.


@deffn Syntax $ascii-chi-V? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{V} in @ascii{} encoding.
@end deffn


@deffn Syntax $ascii-chi-v? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{v} in @ascii{} encoding.
@end deffn


@deffn Syntax $ascii-chi-ampersand? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{&} in @ascii{} encoding.
@end deffn


@deffn Syntax $ascii-chi-at-sign? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{@@} in @ascii{} encoding.
@end deffn


@deffn Syntax $ascii-chi-open-bracket? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{[} in @ascii{} encoding.
@end deffn


@deffn Syntax $ascii-chi-close-bracket? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{]} in @ascii{} encoding.
@end deffn


@deffn Syntax $ascii-chi-open-paren? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{(} in @ascii{} encoding.
@end deffn


@deffn Syntax $ascii-chi-close-paren? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{)} in @ascii{} encoding.
@end deffn


@deffn Syntax $ascii-chi-dot? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{.} in @ascii{} encoding.
@end deffn


@deffn Syntax $ascii-chi-comma? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{,} in @ascii{} encoding.
@end deffn


@deffn Syntax $ascii-chi-colon? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{:} in @ascii{} encoding.
@end deffn


@deffn Syntax $ascii-chi-semicolon? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{;} in @ascii{} encoding.
@end deffn

@c ------------------------------------------------------------

@deffn Syntax $ascii-chi-bang? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{!} in @ascii{} encoding.
@end deffn


@deffn Syntax $ascii-chi-dollar? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{$} in @ascii{} encoding.
@end deffn


@deffn Syntax $ascii-chi-question-mark? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{?} in @ascii{} encoding.
@end deffn


@deffn Syntax $ascii-chi-number-sign? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{#} in @ascii{} encoding.
@end deffn


@deffn Syntax $ascii-chi-percent? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{%} in @ascii{} encoding.
@end deffn

@c ------------------------------------------------------------

@deffn Syntax $ascii-chi-equal? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{=} in @ascii{} encoding.
@end deffn


@deffn Syntax $ascii-chi-plus? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{+} in @ascii{} encoding.
@end deffn


@deffn Syntax $ascii-chi-minus? @var{fx}
@deffnx Syntax $ascii-chi-dash? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{-} in @ascii{} encoding.
@end deffn

@c ------------------------------------------------------------

@deffn Syntax $ascii-chi-underscore? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{_} in @ascii{} encoding.
@end deffn


@deffn Syntax $ascii-chi-tilde? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{~} in @ascii{} encoding.
@end deffn

@c ------------------------------------------------------------

@deffn Syntax $ascii-chi-quote? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{'} in @ascii{} encoding.
@end deffn


@deffn Syntax $ascii-chi-slash? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{/} in @ascii{} encoding.
@end deffn


@deffn Syntax $ascii-chi-star? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing the character
@samp{*} in @ascii{} encoding.
@end deffn

@c page
@node asciis uri
@subsection Character predicates related to @rfc{} 3986, Uniform Resource Identifiers


The following bindings are exported by the library @library{vicare
language-extensions ascii-chars}.  The identifiers whose name is
prefixed with @samp{$} are bound to unsafe operations: they do
@strong{not} validate the arguments and applying them to invalid
arguments leads to undefined behaviour.


@deffn Syntax $ascii-uri-reserved? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing a reserved
character in @ascii{} encoding according to @rfc{} 3986.
@end deffn


@deffn Syntax $ascii-uri-unreserved? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing an unreserved
character in @ascii{} encoding according to @rfc{} 3986.
@end deffn


@deffn Syntax $ascii-uri-gen-delim? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing a @code{gen-delim}
character in @ascii{} encoding according to @rfc{} 3986.
@end deffn


@deffn Syntax $ascii-uri-sub-delim? @var{fx}
Evaluate to true if @var{fx} is a fixnum representing a @code{sub-delim}
character in @ascii{} encoding according to @rfc{} 3986.
@end deffn


@deffn Syntax $ascii-uri-pct-encoded? @meta{chi} @meta{bv} @meta{i}
The argument @meta{chi} must be a fixnum representing the octet at index
@meta{i} in the bytevector @meta{bv}; @meta{bv} and @meta{i} must be
identifiers.  Return @true{} if the @math{3} bytes at offset @meta{i}
represent a percent--encoded sequence and increment @meta{i} to
reference the third octet; otherwise return @false{} and set @meta{i} to
the offset of the offending octet; if there are not enough octets:
return @false{} and leave @meta{i} unchanged.

@example
#!vicare
(import (vicare)
  (vicare language-extensions ascii-chars))

(let* ((bv  '#ve(ascii "ciao"))
       (i   0)
       (chi (bytevector-u8-ref bv i))
       (R   ($ascii-uri-pct-encoded? chi bv i)))
  (values R i))
@result{} #f 0

(let* ((bv  '#ve(ascii "c%ABo"))
       (i   1)
       (chi (bytevector-u8-ref bv i))
       (R   ($ascii-uri-pct-encoded? chi bv i)))
  (values R i))
@result{} #t 3

(let* ((bv  '#ve(ascii "c%AB"))
       (i   1)
       (chi (bytevector-u8-ref bv i))
       (R    ($ascii-uri-pct-encoded? chi bv i)))
  (values R i))
@result{} #t 3

(let* ((bv  '#ve(ascii "c%AZ"))
       (i   1)
       (chi (bytevector-u8-ref bv i))
       (R   ($ascii-uri-pct-encoded? chi bv i)))
  (values R i))
@result{} #f 3

(let* ((bv  '#ve(ascii "c%ZA"))
       (i   1)
       (chi (bytevector-u8-ref bv i))
       (R   ($ascii-uri-pct-encoded? chi bv i)))
  (values R i))
@result{} #f 2

(let* ((bv  '#ve(ascii "c%A"))
       (i   1)
       (chi (bytevector-u8-ref bv i))
       (R   ($ascii-uri-pct-encoded? chi bv i)))
  (values R i))
@result{} #f 1
@end example
@end deffn


@deffn Syntax $ascii-uri-pchar-not-percent-encoded? @var{fx}
Evaluate to true if @var{fx} is a fixnum matching the @code{pchar}
component in @ascii{} encoding, with the exception of the
percent--encoded sequence as defined by @rfc{} 3986.
@end deffn


@deffn Syntax $ascii-uri-pchar? @meta{chi} @meta{bv} @meta{i}
The argument @meta{chi} must be a fixnum representing the octet at index
@meta{i} in the bytevector @meta{bv}; @meta{bv} and @meta{i} must be
identifiers.  Return @true{} if the octet @meta{chi} or the @math{3}
bytes at offset @meta{i} represent @code{pchar} component in @ascii{}
encoding; if successful increment @meta{i} to reference the last
matching octet; otherwise return @false{} and set @meta{i} to the offset
of the offending octet; if there are not enough octets: return @false{}
and leave @meta{i} unchanged.
@end deffn

@c page
@node hooks
@section Running lists of functions


@cindex @library{vicare language-extensions hooks}, library
@cindex Library @library{vicare language-extensions hooks}


The library @library{vicare language-extensions hooks} exports an @api{}
defining @dfn{hooks}: opaque Scheme objects, disjoint from other types,
referencing a list of functions which can be applied to arguments at a
specified point in a program.  @value{PACKAGE} hooks are somewhat
similar to @gnu{} Guile hooks.


@defun make-hook
Build and return a new hook object.
@end defun


@defun hook? @var{obj}
Return @true{} if @var{obj} is a hook object, otherwise @false{}.
@end defun


@defun hook-empty? @var{hook}
Return @true{} if @var{hook} is a hook object and it is empty, otherwise
@false{}.
@end defun


@defun add-hook! @var{hook} @var{proc}
@defunx add-hook! @var{hook} @var{proc} @var{last?}
Register @var{proc} as hook function; return unspecified values.  If
@var{last?} is @false{} or not used: the new function is registered as
first, else it is registered as last.
@end defun


@defun remove-hook! @var{hook} @var{proc}
Remove a previously registered hook function.  Return unspecified
values.
@end defun


@defun reset-hook! @var{hook}
Remove all the previously registered hooks.
@end defun


@defun hook->list @var{hook}
Return the list of registered functions.
@end defun


@defun run-hook @var{hook} @var{arg} @dots{}
Run all the hook functions applying them to the given arguments.  Return
unspecified values.
@end defun

@c page
@node callables
@section Callable objects


@cindex @library{vicare language-extensions callables}, library
@cindex Library @library{vicare language-extensions callables}


The library @library{vicare language-extensions callables} allows the
definition of @dfn{callable objects}: closure objects associated to an
object used as first argument in every call.  Here is an example of
callable object:

@example
(import (vicare)
  (vicare language-extensions callables))

(define C
  (callable 123 (lambda (self delta)
                  (+ delta self))))

(callable? C)           @result{} #t
(callable-object C)     @result{} 123
(C 9000)                @result{} 9123
@end example


@deffn Syntax callable @meta{object} @meta{function}
Build and return a new callable object associated to @meta{object} and
having @meta{function} as callable procedure.
@end deffn


@defun callable? @var{obj}
Return @true{} if @var{obj} is a callable object, otherwise return
@false{}.  Notice that a callable object satisfies @func{procedure?}.
@end defun


@deffn {Validation Clause} callable @var{obj}
@deffnx {Validation Clause} callable/false @var{obj}
Validation clause to be used with the facilities of the library
@library{vicare arguments validation}.  Succeed if @var{obj} is a
callable object; the second clause also accepts @false{}.
@end deffn


@defun callable-object @var{callable}
@defunx $callable-object @var{callable}
Return the object associated to the callable object @var{callable}.
@func{$callable-object} is the unsafe version which does not validate
its argument prior to accessing its internal fields.
@end defun

@c page
@node c-enums
@section C language flags and flags combinations


@cindex @library{vicare language-extensions c-enumerations}, library
@cindex Library @library{vicare language-extensions c-enumerations}


The following bindings are exported by the library @library{vicare
language-extensions c-enumerations}.


@deffn Syntax define-c-flags @meta{name} (@metao{flag} @meta{flag} ...) (@metao{symbol} @meta{symbol} ...)
Define a new enumeration type and a couple of functions to convert
between enumeration sets of this type and other objects.  Usage example:

@example
(define A 1)
(define B 2)
(define C 3)

(define-c-flags things
  (A B C)
  (a b c))

(things->value (things a)) @result{} 1
(things->value (things b)) @result{} 2
(things->value (things c)) @result{} 3

(value->things 1) @result{} (things a)
(value->things 2) @result{} (things b)
(value->things 3) @result{} (things c)
@end example

@noindent
when used in a library, we can do the following to export the interface:

@example
(library (things)
  (export things things->value value->things)
  (import (rnrs))
  (define A 1)
  (define B 2)
  (define C 3)
  (define-c-flags things
    (A B C)
    (a b c)))
@end example

The typical use of this syntax is to define an interface for C language
foreign constants.

@meta{name} must be an identifier to which an enumeration set
constructor syntax is bound; the syntax accepts only a single symbol as
argument and it expands to an enumeration set with that symbol as
element.

The enumeration type is @code{enum-@meta{name}} and the original
constructor syntax accepting any number of arguments is
@code{%@meta{name}}.

The @meta{flag} arguments are meant to be identifiers bound to any
Scheme value, but they can be any value.  The @meta{symbol} arguments
must be Scheme symbols which are used to define (in the given order) the
universe of the enumeration.

The function which converts from an enumeration set (holding a single
argument) to the corresponding value is bound to
@code{@meta{name}->value}.  The function which converts from a value to
the enumeration set (holding a single argument) is bound to
@code{value->@meta{name}}.
@end deffn


@deffn Syntax define-c-ior-flags @meta{name} (@metao{flag} @meta{flag} ...) (@metao{symbol} @meta{symbol} ...)
Define a new enumeration type and a couple of functions to convert
between enumeration sets of this type and a bitwise, inclusive, OR
combination of exact integers.  Usage example:

@example
(define A (bitwise-arithmetic-shift-left 1 0))
(define B (bitwise-arithmetic-shift-left 1 1))
(define C (bitwise-arithmetic-shift-left 1 2))

(define-c-ior-flags things
  (A B C)
  (a b c))

(things->value (things a))      @result{} 1
(things->value (things b))      @result{} 2
(things->value (things a b))    @result{} 3
(things->value (things c))      @result{} 4
(things->value (things a c))    @result{} 5
(things->value (things b c))    @result{} 6
(things->value (things a b c))  @result{} 7

(value->things 1) @result{} (things a)
(value->things 2) @result{} (things b)
(value->things 5) @result{} (things a c)
@end example

@noindent
when used in a library, we can do the following to export the interface:

@example
(library (things)
  (export things things->value value->things)
  (import (rnrs))
  (define A (bitwise-arithmetic-shift-left 1 0))
  (define B (bitwise-arithmetic-shift-left 1 1))
  (define C (bitwise-arithmetic-shift-left 1 2))
  (define-c-ior-flags things
    (A B C)
    (a b c)))
@end example

The typical use of this syntax is to define an interface for C language
foreign constants used as flags in inclusive OR combinations.

@meta{name} must be an identifier to which an enumeration set
constructor syntax is bound; the syntax accepts any number of symbols as
arguments and it expands to an enumeration set with that symbols as
elements.  The enumeration type is @code{enum-@meta{name}}.

The @meta{flag} arguments must be identifiers bound to exact integers.
The @meta{symbol} arguments must be Scheme symbols which are used to
define (in the given order) the universe of the enumeration.

The function which converts from an enumeration set to the corresponding
bitwise, inclusive OR combination is bound to
@code{@meta{name}->value}.  An assertion violation is raised if this
function is applied to an enumeration set of the wrong type.

The function which converts from a bitwise, inclusive OR combination to
the enumeration set is bound to @code{value->@meta{name}}.  If this
function is applied to an integer holding bits outside the ones coded in
the definition of the enumeration, no error is raised.
@end deffn

@c page

@include libs-streams.texi
@include libs-loops.texi
@include libs-comparisons.texi
@include libs-conditions-and-restarts.texi

@c end of file

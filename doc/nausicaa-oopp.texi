@node oopp
@chapter Object--Oriented Perfumed Programming


@cindex @library{nausicaa language oopp}, library
@cindex Library @library{nausicaa language oopp}


The library @library{nausicaa language oopp} is an alternative to the
@rsixlibrary{records syntactic} library; it is built upon
@rsixlibrary{records syntactic} and @rsixlibrary{records procedural} and
it adds some features like object--oriented perfumed programming
(@oopp{}) notation to access fields and methods.

The library is designed to work with type definitions imported for the
@code{run} phase.  The facilities of the library work only on class
types defined with @func{define-class} and label types defined by
@func{define-label}.

In code that defines new types: it is possible to use the facilities by
just importing @library{nausicaa language oopp}, but the recommended
way is to import the full @library{nausicaa} language.  Once a type is
defined, it is possible to make full use of it by just importing its
identifier.

To make the syntax shorter we should put the Scheme reader in
@code{#!vicare} mode; this way the reader will convert braces @samp{@{
... @}} into @func{brace} syntaxes, @vicareref{iklib reader mode,
#!vicare}.

@menu
* oopp overview::               Overview of labels and classes.
* oopp notation::               Special syntax for labels and classes.
* oopp define::                 Defining class and label types.
* oopp parent::                 Type hierarchies.
* oopp abstract::               Abstract class types.
* oopp protocol::               Defining constructor protocols.
* oopp maker::                  Defining custom makers.
* oopp finaliser::              Defining custom finalisers.
* oopp predicate::              Defining custom predicates.
* oopp fields::                 Defining concrete and virtual fields.
* oopp method::                 Defining classes having methods.
* oopp getter::                 Defining classes having custom getters.
* oopp setter::                 Defining classes having custom setters.
* oopp mixins::                 Composing with mixins.
* oopp satisfy::                Verifying definition constraints.
* oopp shadow::                 Label shadowing.
* oopp is-a::                   Testing a value's type.
* oopp slots::                  Accessors and mutators.
* oopp inspect::                Tags and objects inspection.
* oopp bindings::               Defining bindings in @oopp{} notation.
* oopp misc::                   Miscellaneous syntaxes.
@end menu

@c page
@node oopp overview
@section Overview of labels and classes


With the facilities of the library @rsixlibrary{records syntactic} we
can define a new record type with the syntax:

@example
(define-record-type <alpha>
  (fields (mutable   a)
          (immutable b)))

(define (<alpha>-sum O)
  (+ (<alpha>-a O)
     (<alpha>-b O)))
@end example

@noindent
and then use it with code like:

@example
(define O (make-<alpha> 1 2))
(<alpha>? O)            @result{} #t
(<alpha>-a O)           @result{} 1
(<alpha>-a-set! O 10)
(<alpha>-b O)           @result{} 2
(<alpha>-sum O)         @result{} 3
@end example

@noindent
we notice that:

@itemize
@item
If we define a type in a library and then we want to use it in another
library, we have to export all the associated identifiers:
@class{alpha}, @func{<alpha>?}, @func{<alpha>-a}, @func{<alpha>-b},
@func{<alpha>-a-set!}, @func{<alpha>-sum}.

@item
There is no way to define a function tied to this record type, neither a
syntax to use such function: functions acting on @rnrs{6} records, like
@func{<alpha>-sum}, are just ordinary Scheme functions.

@item
If we use @class{alpha} in a chunk of code and later we change the
record type name to something else: we have to change all the function
names; there is no syntax to define interfaces implemented by multiple
types.
@end itemize

Some of these shortcomings are mitigated by syntaxes exported by
@library{vicare}, with which we can write:

@example
(define O (make-<alpha> 1 2))
(is-a? O <alpha>)               @result{} #t
(slot-ref  O a <alpha>)         @result{} 1
(slot-set! O a <alpha> 10)
(slot-ref  O b <alpha>)         @result{} 2
(<alpha>-sum O)                 @result{} 3
@end example

@noindent
the syntaxes @func{is-a?}, @func{slot-ref} and @func{slot-set!} work on
any @rnrs{6} record type (and @value{PRJNAME} struct type).  These
syntaxes are quite verbose.

Now let's look at the same definition using the facilities of the
library @library{nausicaa language oopp}, adapted by the library
@library{nausicaa}; to define a class:

@example
#!vicare
(import (nausicaa))

(define-class <alpha>
  (fields (mutable   a)
          (immutable b))
  (method (sum @{O <alpha>@})
     (+ (O a) (O b))))
@end example

@noindent
it is pretty similar; we can use this type with code like:

@example
(define @{O <alpha>@} (<> (1 2)))
(is-a? O <alpha>)       @result{} #t
(O a)                   @result{} 1
(set! (O a) 11)
(O b)                   @result{} 2
(O sum)                 @result{} 3
@end example

@noindent
or using only the type identifier @class{alpha}:

@example
(<alpha> O (<> (1 2)))
(<alpha> #:is-a? O)     @result{} #t
(O a)                   @result{} 1
(set! (O a) 11)
(O b)                   @result{} 2
(O sum)                 @result{} 3
@end example

@noindent
the syntaxes defined by @library{vicare} are still usable:

@example
(is-a? O <alpha>)               @result{} #t
(slot-ref  O a <alpha>)         @result{} 1
(slot-set! O a <alpha> 10)
(slot-ref  O b <alpha>)         @result{} 2
@end example

@noindent
there are differences with the @rnrs{6} code:

@itemize
@item
If we define a type in a library and then we want to use it in another
library: we need to export only the type identifier @class{alpha}.

@item
It is possible to define methods associated to the class type and there
is an @oopp{} syntax to use them.

@item
If we change the code to use a different type: we need to change only
the type name, which appears in few places; it is possible to define
interfaces implemented by multiple types.
@end itemize

Notice that the @rnrs{6}--style bindings defined by
@func{define-record-type} are also available with the facilities of
@library{nausicaa language oopp}:

@example
#!vicare
(import (nausicaa))

(define-class <alpha>
  (fields (mutable   a)
          (immutable b))
  (method (sum @{o <alpha>@})
     (+ (o a) (o b))))

(define o (make-<alpha> 1 2))
(<alpha>? o)            @result{} #t
(<alpha>-a o)           @result{} 1
(<alpha>-b o)           @result{} 2
(<alpha>-sum o))        @result{} 3
@end example

@noindent
so it is easy to convert existing record type definitions to classes
definitions; notice, however, that it is not possible to just substitute
@func{define-record-type} with @func{define-class}: some clauses of the
former are not supported by the latter (most notably
@clause{parent-rtd}).

So, classes can be used to define new record types when we would use
@func{define-record-type} in plain @rnrs{6} code; @library{nausicaa
language oopp} also allows us to define ``labels''.  Label
definitions are similar to class definitions, but, while the latter
defines a record type, the former only defines identifier syntaxes to
handle any value.

The following example defines a tag to handle immutable pair values:

@example
#!vicare
(import (nausicaa))

(define-label <pair>
  (protocol (lambda () cons))
  (predicate pair?)
  (virtual-fields (immutable car car)
                  (immutable cdr cdr)))

(define @{P <pair>@} '(1 . 2))
(is-a? P <pair>)        @result{} #t
(P car)                 @result{} 1
(P cdr)                 @result{} 2
@end example

When writing a library implementing classes and labels for Nausicaa: we
must enable the option @code{visit-upon-loading} in the options clause
of the @code{library} form; @vicareref{iklib syntaxes libraries,
Extended @code{library} syntax}.  Without this option the properties of
the type identifiers may not be defined properly.

@c page
@node oopp notation
@section Special syntax for labels and classes


@cindex @oopp{} notation
@cindex Syntax of @oopp{} identifiers
@cindex Tagged variable syntax
@cindex Identifer syntax, @oopp{}
@cindex @oopp{}, identifer syntax
@cindex @oopp{}, tagged variable syntax


After defining a class or label type with @library{nausicaa language
oopp} we can ``tag'' variables to be of such type: the variable is an
identifier syntax implementing @oopp{} notation.

@menu
* oopp notation conventions::   @oopp{} syntax: notation conventions.
* oopp notation type::          @oopp{} syntax: how to use type tags.
* oopp notation var::           @oopp{} syntax: how to use tagged
                                variables.
* oopp notation nesting::       @oopp{} syntax: nesting forms.
@end menu

@c page
@node oopp notation conventions
@subsection @oopp{} syntax: notation conventions


To describe the @oopp{} syntax we assume the following definitions:

@table @asis
@item @meta{type}
It is the identifier of the class or label.

@item @meta{var}
It is the identifier syntax we use to handle a type instance.

@item @meta{expr}
It is a generic expression.

@item @code{<>}
It is the fluid syntax exported by @library{vicare} and reexported by
both @library{nausicaa language oopp} and @library{nausicaa language
auxiliary-syntaxes}.

@item @meta{member-id}
It is an identifier used to select a type's method or field name.  When
the @oopp{} syntax transformers attempt to match it against method and
field names: the identifier is first converted to symbol, with
@func{syntax->datum}, and then compared to method and field name symbols
with @func{eq?}.  Notice that methods and fields cannot have the same
name in a type definition.

@item @meta{form}
It is a generic form: an expression, an auxiliary syntax, @dots{}.
@end table

@c page
@node oopp notation type
@subsection @oopp{} syntax: how to use type tags


@menu
* oopp notation type maker::    Instantiating a tag type.
* oopp notation type pred::     Using the tag predicate.
* oopp notation type define::   Internal definitions of tagged
                                variables.
* oopp notation type expr::     Applying @oopp{} syntax to any
                                expression.
* oopp notation type cast::     Casting a value for @oopp{} syntax.
* oopp notation type leaking::  @oopp{} syntax allows interface leaking.
@end menu

@c page
@node oopp notation type maker
@subsubsection Instantiating a tag type


To build the intance of a tag @meta{type} we write:

@example
(@meta{type} (@meta{form} ...))
@end example

@noindent
if @meta{type} implements a maker: apply the maker transformer function
to the whole form.  If @meta{type} has no maker: this syntax expands to
the public constructor function of @meta{type} applied to the results of
evaluating the @meta{form} forms.  If the maker syntax is used as first
subform of an enclosing form, the nested @oopp{} syntax is available.

Examples with the public constructor:

@example
(define-label <a-pair>
  (protocol (lambda () cons)))

(define-label <a-list>
  (protocol (lambda () list)))

(<a-pair> (1 2))          @result{} (1 . 2)
(<a-list> (1 2 3))        @result{} (1 2 3)
@end example

@noindent
we can think of this syntax as implementing the following expansion:

@example
(<a-pair> (1 2)) @expansion{} (make-<a-pair> 1 2) @equiv{} (cons 1 2)
@end example

If the constructor takes no arguments: we just use null as second form
in the syntax; example:

@example
(define-class <alpha>
  (parent <top>)
  (fields a b)
  (protocol (lambda (make-top)
              (lambda ()
                ((make-top) 1 2)))))

(define O (<alpha> ()))
(<alpha>-a O)           @result{} 1
(<alpha>-b O)           @result{} 2
@end example

Example using the maker transformer:

@example
(define-auxiliary-syntaxes pair)

(define-label <a-pair>
  (maker (lambda (stx)
           (syntax-case stx (pair car cdr)
             ((?type (pair (car ?a) (cdr ?d)))
              #'(?type (?a ?d)))
             ((?type (?a ?d))
              #'(cons ?a ?d)))))
  (virtual-fields (immutable car car)
                  (immutable cdr cdr)))

(<a-pair> (pair
            (car 1)
            (cdr 2)))
@result{} (1 . 2)

(<a-pair> (1 2))
@result{} (1 . 2)
@end example

Example of using nested @oopp{} syntax:

@example
(define-label <a-pair>
  (protocol (lambda () cons))
  (virtual-fields (immutable car car)
                  (immutable cdr cdr)))

((<a-pair> (1 2)) car)  @result{} 1
((<a-pair> (1 2)) cdr)  @result{} 2
@end example

@c page
@node oopp notation type pred
@subsubsection Using the tag predicate


To use the type predicate we write:

@example
(@meta{type} #:predicate)
@end example

@noindent
it expands to a reference to the type predicate, if any; when the type
has no predicate: the result is a function taking one argument and
always returning @true{}.  Examples:

@example
#!vicare
(import (nausicaa))

(define-label <a-pair>
  (predicate pair?))

(define-label <any>)  ;no predicate

((<a-pair> #:predicate) '(1 . 2)) @result{} #t
((<a-pair> #:predicate) "ciao")   @result{} #f

((<any> #:predicate) "ciao")    @result{} #t

(for-all (<a-pair> #:predicate)
  '((1 . 2) (3 . 4)))           @result{} #t
@end example

We can also directly apply the predicate to the result of an expression
as follows:

@example
#!vicare
(import (nausicaa))

(define-label <a-pair>
  (predicate pair?))

(<a-pair> #:is-a? '(1 . 2))     @result{} #t
(<a-pair> #:is-a? "12")         @result{} #f
@end example

Furthermore we can use the @func{is-a?} syntax (@vicarepref{iklib
syntaxes predicates, is-a?}):

@example
#!vicare
(import (nausicaa))

(define-label <a-pair>
  (predicate pair?))

(is-a? '(1 . 2) <a-pair>)       @result{} #t
(is-a? "12"     <a-pair>)       @result{} #f

((is-a? <> <a-pair>) '(1 . 2))  @result{} #t

(for-all (is-a? <> <a-pair>)
  '((1 . 2) (3 . 4)))           @result{} #t
@end example

@c page
@node oopp notation type define
@subsubsection Internal definitions of tagged variables


To define a tagged variable we write:

@example
(@meta{type} @meta{var})
(@meta{type} @meta{var} @meta{expr})
(define/tags (brace @meta{var} @meta{type}))
(define/tags (brace @meta{var} @meta{type}) @meta{expr})
@end example

@noindent
where @func{define/tags} is exported by @library{nausicaa language oopp}
and reexported renamed to @func{define} by @library{nausicaa};
@func{brace} is the binding exported by @library{vicare} and reexported
by both @library{nausicaa language oopp} and @library{nausicaa},
@vicareref{iklib syntaxes misc, brace}.

These syntaxes expand to internal definitions that bind @meta{var} to
intances of @meta{type}; that if values validation is turned on: the
result of evaluating @meta{expr}, and values that are later assigned to
@meta{var}, must be instances of @meta{type} according to its predicate
(if any).

@itemize
@item
The first form defines an identifier syntax for an uninitialised tagged
variable; example:

@example
#!vicare
(import (nausicaa))

(define-label <a-pair>
  (predicate pair?))

(<a-pair> O)
@end example

@noindent
we can think of the last form as expanding to:

@example
(define G0)
(define-syntax O
  (make-variable-transformer
    (lambda (stx)
      --- #'G0 ---)))
@end example

@noindent
where @code{G0} is an automatically generated identifier.

@item
The second form defines an identifier syntax for a tagged variable
initialised to the result of evaluating @meta{expr}; example:

@example
#!vicare
(import (nausicaa))

(define-label <a-pair>
  (predicate pair?))

(<a-pair> O '(1 . 2))
@end example

When an initialisation expression @meta{expr} is used: the fluid syntax
@func{<>} is bound to a synonym of @meta{type} while the expansion of
@meta{expr} is performed.  We can think of the last form as expanding
to:

@example
(define G0
  (fluid-let-syntax
      ((<> (make-synonym-transformer #'<a-pair>)))
    '(1 . 2)))
(define-syntax O
  (make-variable-transformer
    (lambda (stx)
      --- #'G0 ---)))
@end example

@noindent
where @code{G0} is an automatically generated identifier.

@item
The third and fourth forms are equivalent to the first and second:

@example
(define/tags (brace @meta{var} @meta{type}))
@expansion{} (@meta{type} @meta{var})

(define/tags (brace @meta{var} @meta{type}) @meta{expr})
@expansion{} (@meta{type} @meta{var} @meta{expr})
@end example
@end itemize

The fluid syntax @func{<>} allows us to build an instance of @meta{type}
without retyping the identifier @meta{type} in the initialisation
expression @meta{expr}; example:

@example
#!vicare
(import (nausicaa))

(define-label <a-pair>
  (protocol (lambda () cons))
  (predicate pair?))

(define @{O <a-pair>@}
  (<> (1 2)))
@end example

@noindent
we can think of the last form as expanding to:

@example
(define @{O <a-pair>@}
  (<a-pair> (1 2)))
@end example

@noindent
and so to:

@example
(define G0 (make-<a-pair> 1 2))
(define-syntax O
  (make-variable-transformer
    (lambda (stx)
      --- #'G0 ---)))
@end example

@noindent
where @code{G0} is an automatically generated identifier.

The initialisation expression can be more complex:

@example
#!vicare
(import (nausicaa))

(define-label <a-pair>
  (protocol (lambda () cons))
  (predicate pair?))

(define @{O <a-pair>@}
  (let ((a 1)
        (d 2))
    (<> (a d))))

(define @{Q <a-pair>@}
  ((lambda (a d)
     (<> (a d)))
   1 2))
@end example

@c page
@node oopp notation type expr
@subsubsection Applying @oopp{} syntax to any expression


It is possible to use the @oopp{} notation not only with tagged
variables, but with any expression evaluating to an object of a specific
@meta{type}; for an introduction to @oopp{} syntax @ref{oopp notation
var, How to use tagged variables}.  This is achieved by using some
keyword objects as arguments for the type tag.

@cindex oopp-syntax, keyword
@cindex Keyword oopp-syntax
The syntax:

@example
(@meta{type} #:oopp-syntax (@metao{expr} @meta{expr} ...))
@end example

@noindent
can interpret @metao{expr} as an expression evaluating to a Scheme
object of type @meta{type}; the form:

@example
(@metao{expr} @meta{expr} ...)
@end example

@noindent
is expanded according to the rules of @oopp{} syntax.  Examples:

@example
(<fixnum> #:oopp-syntax (123 positive?))
@result{} #t

(<string> #:oopp-syntax ("123" length))
@result{} 3

(<string> #:oopp-syntax ("01234" substring 1 3))
@result{} "12"
@end example

@cindex nested-oopp-syntax, keyword
@cindex Keyword nested-oopp-syntax
The syntax:

@example
(@meta{type} #:nested-oopp-syntax @meta{expr})
@end example

@noindent
will interpret @meta{expr} as an expression evaluating to a Scheme
object of type @meta{type}.  This syntax allows nested @oopp{} syntax
expansion if it appears as first subform, with the following expansion:

@example
((@meta{type} #:nested-oopp-syntax @meta{expr}) @meta{arg} ...)
@expansion{} (@meta{type} #:oopp-syntax (@meta{expr} @meta{arg} ...))
@end example

@noindent
examples:

@example
((<fixnum> #:nested-oopp-syntax 123) positive?)
@result{} #t

((<string> #:nested-oopp-syntax "01234") length)
@result{} 5

;; getter
((<string> #:nested-oopp-syntax "01234") [3])
@result{} #\3
@end example

@c page
@node oopp notation type cast
@subsubsection Casting a value for @oopp{} syntax


It is possible to use @oopp{} syntaxes with data values, too; we use the
``cast'' syntax:

@example
((@meta{type}) @meta{expr})
@end example

@noindent
whenever this syntax appears as first subform of an enclosing form, the
following chain of expansions takes place:

@example
(((@meta{type}) @meta{expr}) @meta{arg} ...)
@expansion{} ((@meta{type} #:nested-oopp-syntax @meta{expr}) @meta{arg} ...)
@expansion{} (@meta{type} #:oopp-syntax (@meta{expr} @meta{arg} ...))
@end example

@noindent
otherwise the expansion is just:

@example
((@meta{type}) @meta{expr})
@expansion{} @meta{expr}
@end example

This syntax allows expressions like:

@example
((<fixnum>) 123)                @result{} 123
(((<fixnum>) 123) add1)         @result{} 124
(((<fixnum>) 123) <= 200)       @result{} #t
(((<fixnum>) 123) <= 100)       @result{} #f
@end example

@c page
@node oopp notation type leaking
@subsubsection @oopp{} syntax allows interface leaking


It is possible to access the members of a class or label defined by a
tag that is not imported in the current lexical environment; this
constitutes, in practice, an @api{} leaking between contexts.  It
happens as follows:

@example
#!vicare
(library (leaking-demo)
  (export doit)
  (import (nausicaa))
  (define-class <alpha>
    (fields a b))
  (define (@{doit <alpha>@} a b)
    (<alpha> (a b))))
@end example

@noindent
the library @library{leaking-demo} exports the function @func{doit} but
not the class identifier @class{alpha}.  Despite this, when we import
the library and call @func{doit} we can access the members @code{a} and
@code{b} of the returned @class{alpha} instance:

@example
(import (nausicaa)
  (leaking-demo))

((doit 1 2) a)          @result{} 1
((doit 3 4) b)          @result{} 4
@end example

This behaviour may change in the future.

@c page
@node oopp notation var
@subsection @oopp{} syntax: how to use tagged variables


@menu
* oopp notation var reference::         Referencing tagged variables.
* oopp notation var mutation::          Mutating tagged variables.
* oopp notation var member access::     Accessing tag members of tagged
                                        variables.
* oopp notation var member mutation::   Accessing tag members of tagged
                                        variables.
* oopp notation var getter::            Using the getter of tagged
                                        variables.
* oopp notation var setter::            Using the setter of tagged
                                        variables.
@end menu

@c page
@node oopp notation var reference
@subsubsection Referencing tagged variables


Referencing a tagged variable @meta{var}, of type @meta{type}, works
just like referencing any Scheme variable, we just write its identifier:

@example
@meta{var}
@end example

@noindent
example:

@example
#!vicare
(import (nausicaa))

(define-label <a-pair>
  (predicate pair?))

(define @{O <a-pair>@} '(1 . 2))

O   @result{} (1 . 2)
@end example

@c page
@node oopp notation var mutation
@subsubsection Mutating tagged variables


Mutating a tagged variable @meta{var}, of type @meta{type}, works almost
like mutating any Scheme variable, we just use the @func{set!/tags}
syntax rather than the @func{set!} syntax:

@example
(set!/tags @meta{var} @meta{expr})
@end example

@noindent
this syntax expands to the use of @func{set!} as defined by @rnrs{6}:
the result of evaluating @meta{expr} becomes the new value of
@meta{var}; @func{set!/tags} is exported by @library{nausicaa language
oopp} and reexported renamed to @func{set!} by @library{nausicaa}.  If
values validation is turned on: the new value must be an instance of
@meta{type} according to its predicate (if any).  Example:

@example
#!vicare
(import (nausicaa))

(define-label <a-pair>
  (predicate pair?))

(define @{O <a-pair>@} '(1 . 2))
(set! O '(3 . 4))
O                       @result{} (3 . 4)

(set! O "ciao")    @error{} &tagged-binding-violation
@end example

@c page
@node oopp notation var member access
@subsubsection Accessing tag member of tagged variables


To access a type member from a tagged variable @meta{var}, of type
@meta{type}, we write a form beginning with @meta{var} and followed by
the member name:

@example
(@meta{var} @meta{member-id})
@end example

@noindent
it expands according to the following rules, in the given order:

@enumerate
@item
If the type has a method named @meta{member-id}: this syntax expands to
a call to such method with no arguments.  The first argument of the
method call is @meta{var} itself.

@item
If the type has a field named @meta{member-id}: this syntax expands to a
call to the field's accessor.

@item
If @meta{member-id} has a string name prefixed with @samp{$} and the
type has a @strong{concrete} field named @meta{member-id} with the
@samp{$} stripped: this syntax expands to a call to the field's unsafe
accessor (an accessor that does @strong{not} validate its argument).
@end enumerate

Examples:

@example
#!vicare
(import (nausicaa))

(define-label <a-pair>
  (virtual-fields (immutable car car))
  (method (cdr O)
    (cdr O)))

(define @{O <a-pair>@} '(1 . 2))
(O car)         @result{} 1     ;field accessor application
(O cdr)         @result{} 2     ;method application

(define-class <alpha>
  (fields a))

(define @{O <alpha>@} 1)
(A a)           @result{} 1     ;field accessor application
(A $a)          @result{} 1     ;unsafe field accessor application
@end example

@c page
@node oopp notation var member mutation
@subsubsection Accessing tag member of tagged variables


To mutate a tag member from a tagged variable @meta{var}, of type
@meta{type}, we write:

@example
(set!/tags (@meta{var} @meta{member-id}) @meta{expr})
@end example

@noindent
it expands according to the following rules, in the given order:

@enumerate
@item
If the type has a field named @meta{member-id}: this syntax expands to a
call to the field's mutator.

@item
If @meta{member-id} has a string name prefixed with @samp{$} and the
type has a @strong{concrete} field named @meta{member-id} with the
@samp{$} stripped: this syntax expands to a call to the field's unsafe
mutator (a mutator that does @strong{not} validate its first argument).

@item
If @meta{member-id} is not the name of a field or it is the name of an
immutable field: this syntax causes a syntax violation to be raised at
expand time.
@end enumerate

@noindent
@func{set!/tags} is exported by @library{nausicaa language oopp} and
reexported renamed to @func{set!} by @library{nausicaa}.

Example:

@example
#!vicare
(import (nausicaa))

(define-label <a-pair>
  (virtual-fields (mutable car car set-car!)
                  (mutable cdr cdr set-cdr!)))

(define @{O <a-pair>@} (cons 1 2))
(O car)         @result{} 1
(O cdr)         @result{} 2

(set! (O car) 77)
(set! (O cdr) 99)
O               @result{} (77 . 99)

(define-class <alpha>
  (fields (mutable a)))

(define @{A <alpha>@} (<> (1)))
(set! (A a)  2)         ;field mutator application
(set! (A $a) 3)         ;field unsafe mutator application
@end example

@c page
@node oopp notation var getter
@subsubsection Using the getter of tagged variables


To use the getter of a tagged variable @meta{var}, of type @meta{type},
we write:

@example
(@meta{var} (@metao{key} ...) (@meta{key} ...) ...)
@end example

@noindent
it expands to the result of applying the type's getter transformer to
the syntax object (lookout for the parentheses):

@example
#'(@meta{var} ((@metao{key} ...) (@meta{key} ...) ...))
@end example

@noindent
if the type has no getter: this syntax causes a syntax violation
exception to be raised at expand time.  Examples:

@example
#!vicare
(import (nausicaa))

(define-label <a-vector>
  (getter (lambda (stx tag)
            (syntax-case stx ()
              ((?expr ((?idx)))
               #'(vector-ref ?expr ?idx))))))

(define-label <a-matrix>
  (getter (lambda (stx tag)
            (syntax-case stx ()
              ((?expr ((?row) (?col)))
               #'(vector-ref
                    (vector-ref ?expr ?row)
                    ?col))))))

(define @{V <a-vector>@}
  '#(1 2 3))

(define @{M <a-matrix>@}
  '#(#(1 2 3) #(4 5 6)))

(V[0])                  @result{} 1
(V[1])                  @result{} 2
(V[2])                  @result{} 3

(M[0][2])               @result{} 3
(M[1][1])               @result{} 5
@end example

We can use nested @oopp{} syntax whenever the getter evaluates to an
object of a known type; here is an example using the built--in label
@class{char}:

@example
#!vicare
(import (nausicaa))

(define-label <a-string>
  (getter
    (lambda (stx tag)
      (syntax-case stx ()
        ((?expr ((?idx)))
         #'(<char> #:nested-oopp-syntax
              (string-ref ?expr ?idx)))
        ))))

(define @{S <a-string>@}
  "abc")

(S[0])                  @result{} #\a
(S[1])                  @result{} #\b
(S[2])                  @result{} #\c

((S[1]) upcase)         @result{} #\B
@end example

@c page
@node oopp notation var setter
@subsubsection Using the setter of tagged variables


To use the setter of a tagged variable @meta{var}, of type @meta{type},
we write one of the following equivalent syntaxes:

@example
(set!/tags (@meta{var} (@metao{form} ...) (@meta{form} ...) ...) @meta{expr})
(set!/tags @meta{var} (@metao{form} ...) (@meta{form} ...) ... @meta{expr})
@end example

@noindent
it expands to the result of applying the type's setter transformer to
the syntax object (lookout for the parentheses):

@example
#'(@meta{var} ((@metao{form} ...) (@meta{form} ...) ...) @meta{expr})
@end example

@noindent
if the type has no setter transformer: this syntax causes a syntax
violation exception to be raised at expand time.  @func{set!/tags} is
exported by @library{nausicaa language oopp} and reexported renamed to
@func{set!} by @library{nausicaa}.

Examples:

@example
#!vicare
(import (nausicaa))

(define-label <a-vector>
  (setter (lambda (stx tag)
            (syntax-case stx ()
              ((?expr ((?idx)) ?expr)
               #'(vector-set! ?expr ?idx ?expr))))))

(define-label <a-matrix>
  (setter (lambda (stx tag)
            (syntax-case stx ()
              ((?expr ((?row) (?col)) ?expr)
               #'(vector-set!
                    (vector-ref ?expr ?row)
                    ?col ?expr))))))

(define @{V <a-vector>@}
  (vector 1 2 3))

(define @{M <a-matrix>@}
  (vector (vector 1 2 3)
          (vector 4 5 6)))

(set! V[1] 77)
(set! (V[2]) 99)
V               @result{} #(1 77 99)

(set! M[0][2] 77)
(set! (M[1][1]) 99)
M               @result{} #(#(1 2 77) #(4 99 6))
@end example

@c page
@node oopp notation nesting
@subsection @oopp{} syntax: nesting forms


Whenever an expression in @oopp{} syntax appears as first subform, it
has a single return value and such return value is tagged: the result of
its expansion is spliced in the enclosing form; this allows a more
natural @oop{}--like syntax to access supertype members.  It is clearly
not ``Schemey''.

Here are some examples using the built--in label @class{spine}:

@example
#!vicare
(import (nausicaa))

(<spine> L '(0 1 2 3 4))

(L car)                              @result{} 0
(L cdr)                              @result{} (1 2 3 4)
((L cdr) car)                        @result{} 1
((L cdr) cdr)                        @result{} (2 3 4)
(((L cdr) cdr) car)                  @result{} 2
(((L cdr) cdr) cdr)                  @result{} (3 4)
((((L cdr) cdr) cdr) car)            @result{} 3
((((L cdr) cdr) cdr) cdr)            @result{} (4)
(((((L cdr) cdr) cdr) cdr) car)      @result{} 4
(((((L cdr) cdr) cdr) cdr) cdr)      @result{} ()
@end example

@noindent
here is an example of nested getter syntax using the built--in label
@class{vector}:

@example
#!vicare
(import (nausicaa))

(define-label <vector-of-vectors>
  (parent <vector>)
  (getter
    (lambda (stx tag)
      (syntax-case stx ()
        ((?expr ((?idx)))
         #'(<vector> #:nested-oopp-syntax
                     (vector-ref ?expr ?idx)))))))

(define @{V <vector-of-vectors>@}
  '#(#(11 12 13)
     #(21 22 23)
     #(31 32 33)))

(V[0])          @result{} '#(11 12 13))
(V[1])          @result{} '#(21 22 23))
(V[2])          @result{} '#(31 32 33))

((V[0]) [0])    @result{} 11)
((V[0]) [1])    @result{} 12)
((V[0]) [2])    @result{} 13)

((V[2]) [2])    @result{} 33)
@end example

@noindent
here is an example using the tagged return value from a function using
the built--in label @class{string}:

@example
#!vicare
(import (nausicaa))

(define (@{the-str <string>@})
  "ciao")

((the-str) upcase)      @result{} "CIAO"
((the-str) [1])         @result{} #\i
@end example

The built--in tags @class{top} and @class{procedure} are special because
they do @strong{not} splice, to allow a natural function invocation
syntax:

@example
#!vicare
(import (nausicaa))

(define-class <alpha>
  (fields (immutable @{fun <procedure>@})))

(define-class <beta>
  (fields (immutable @{fun <top>@})))

(<alpha> A (<> (+)))
(<beta>  B (<> (*)))

((A fun) 1 2 3)         @result{} 6
((B fun) 1 2 3)         @result{} 6
@end example

@noindent
with splicing the expansion would have been:

@example
;; this does NOT happen
((A fun) 1 2 3) @expansion{} (A fun 1 2 3)
@end example

An untagged member is equivalent to a member tagged with @class{top}, so
it does not splice:

@example
#!vicare
(import (nausicaa))

(define-class <gamma>
  (fields (immutable fun)))

(<gamma> G (<> (*)))

((G fun) 1 2 3)         @result{} 6
@end example

@c page
@node oopp define
@section Defining class and label types


@cindex Class type definition
@cindex Label type definition
@cindex Type, class definition
@cindex Type, label definition
@cindex Definition of class types
@cindex Definition of label types


In the context of the library @library{nausicaa language oopp}:

@itemize
@item
A @dfn{class type} is a regular record type as defined by
@rsixlibrary{records syntactic}, with the constraints of being
non--generative and derived only from record types defined with the
syntax @func{define-class}.  New class types are defined by
@func{define-class} which generates auxiliary syntaxes to allow for
virtual fields, methods, @oopp{} notation and multiple construction
protocols.

@item
A @dfn{label type} is a syntactic interface applicable to either a
record or non--record value; a label type can have a class type as
parent, but not vice versa.  Label types are defined by
@func{define-label} which generates syntaxes to allow for virtual
fields, methods, @oopp{} notation and simple construction protocol.
@end itemize

@quotation
@strong{NOTE} When writing a library implementing classes and labels for
Nausicaa: we must enable the option @code{visit-upon-loading} in the
options clause of the @code{library} form; @vicareref{iklib syntaxes
libraries, Extended @code{library} syntax}.  Without this option the
properties of the type identifiers may not be defined properly.
@end quotation


@defmac define-class @meta{name} @meta{clause} ...
Define a new record type satisfying the constraints of a class
definition; expand to a regular record type definition using
@rsixlibrary{records syntactic} and some additional syntax definitions.

There is some compatibility between the arguments of @func{define-class}
and the arguments of @func{define-record-type} from @rsixlibrary{records
syntactic}:

@itemize
@item
The form @meta{name} is defined in the same way of the first argument of
@func{define-record-type}, it can be one among:

@example
@meta{class-id}
(@meta{class-id} @meta{constructor-id} @meta{predicate-id})
@end example

@noindent
where: @meta{class-id} is the type identifier; @meta{constructor-id} is
the identifier to which the public constructor function is bound;
@meta{predicate-id} is the identifier to which the type predicate
function is bound.

@item
The forms @meta{clause} are similar to the clauses of an @rnrs{6} record
type definition, @func{define-class} accepts the following clauses:

@example
abstract        nongenerative           parent
sealed          opaque
fields          virtual-fields
method          method-syntax           methods
protocol        public-protocol         super-protocol
getter          setter
maker           satisfies
@end example

@noindent
among these, the following clauses are basically defined in the same way
of clauses for @func{define-record-type}, with some extensions for
@code{fields}:

@cindex @clause{nongenerative} clause in class definitions
@cindex @clause{parent} clause in class definitions
@cindex @clause{sealed} clause in class definitions
@cindex @clause{opaque} clause in class definitions
@cindex @clause{fields} clause in class definitions
@cindex @clause{protocol} clause in class definitions
@example
nongenerative           parent
sealed                  opaque
fields                  protocol
@end example

@noindent
so a @func{define-record-type} syntax use with only these forms can be
converted to @func{define-class} by just changing the syntax keyword;
notice that there is no @code{parent-rtd} clause.
@end itemize

Class types are always non--generative; when the @code{nongenerative}
clause is not explicitly used, the @code{(nongenerative)} clause is
implicitly added to the definition and a unique type identifier is
automatically generated; however it is safer to explicitly specify the
@uid{}.

When the @code{(abstract)} clause is present: the class type cannot be
instantiated.

If the @func{parent} clause is not explicitly present: the clause
@code{(parent <top>)} is implicitly added to the class definition, all
the classes are derived from @class{top}.  Notice that the constructor
of @class{top} accepts no arguments, so the protocol for a class derived
from @class{top} should be something like:

@example
(protocol (lambda (make-top)
            (lambda (field ...)
              ((make-top) field ...))))
@end example
@end defmac


@defmac define-label @meta{name} @meta{clause} ...
Define a new label type; expand to a set of syntax definitions and some
functions for constructors and predicates.

There is some similarity between the arguments of @func{define-label}
and the arguments of @func{define-class}:

@itemize
@item
The form @meta{name} is defined in the same way of the first argument of
@func{define-class}, it can be one among:

@example
@meta{label-id}
(@meta{label-id} @meta{constructor-id} @meta{predicate-id})
@end example

@noindent
where: @meta{label-id} is the type identifier; @meta{constructor-id} is
the identifier to which the public constructor function is bound;
@meta{predicate-id} is the identifier to which the type predicate
function is bound.

Label constructors are used to build Scheme values with the same syntax
used to build class instances.  Predicates are used to check values
using a custom function specified in the label definition.

@item
The forms @meta{clause} are similar to the clauses of a
@func{define-class} definition, @func{define-label} accepts the
following clauses:

@example
parent                  nongenerative
predicate
protocol                maker
method                  method-syntax
methods                 virtual-fields
getter                  setter
satisfies               shadows
@end example
@end itemize

Label types are always associated to a unique identifier; such
identifier has nothing to do with generative or non--generative record
types, because a label is not a record type.  When the
@code{nongenerative} clause is not explicitly used, the
@code{(nongenerative)} clause is implicitly added to the definition and
a unique type identifier is automatically generated; however it is safer
to explicitly specify the @uid{}.

If the @func{parent} clause is not explicitly present: the clause
@code{(parent <top>)} is implicitly added to the label definition, all
the labels are derived from @class{top}.  Notice that the semantics of
label constructor protocols is @strong{not} the same as the semantics of
class constructor protocols; a label protocol function does @strong{not}
accept the parent's constructor function as argument.
@end defmac

@c page
@node oopp parent
@section Type hierarchies


@cindex Defining inheritance for class types
@cindex Defining inheritance for label types
@cindex Class types, defining inheritance
@cindex Label types, defining inheritance
@cindex Inheritance, class types
@cindex Inheritance, label types


Type inheritance is defined by the @code{parent} clause of
@func{define-class} and @func{define-label}; only single inheritance is
supported.  Class types can only inherit from other class types,
inheritance is not supported from record types defined by either the
syntactic or procedural layers of @rnrs{6} libraries.  Label types can
inherit from either a class or label type.


@deffn {Auxiliary Syntax} parent @meta{super-type}
Make the type of the enclosing definition a subtype of
@meta{super-type}, which must be a type identifier.  The @code{parent}
binding is the one exported by the @rsixlibrary{records syntactic}
library.  This clause is accepted in both class and label types.

When this clause is not present in a type definition: inheritance from
@class{top} is implicitly assumed.
@end deffn


The following is an example of class definition inheriting from
@class{top}:

@example
#!vicare
(import (nausicaa))

(define-class <alpha>
  (fields a))

(define @{O <alpha>@}
  (<> (1)))
(is-a? O <alpha>)       @result{} #t
(is-a? O <top>)         @result{} #t
@end example

@noindent
the following is an example of class definition inheriting from another
class:

@example
#!vicare
(import (nausicaa))

(define-class <alpha>
  (fields a))

(define-class <beta>
  (parent <alpha>)
  (fields b))

(define @{O <beta>@}
  (<> (1 2)))

(is-a? O <beta>)        @result{} #t
(is-a? O <alpha>)       @result{} #t
(is-a? O <top>)         @result{} #t

(O a)                   @result{} 1
(O b)                   @result{} 2
@end example

@noindent
the following is an example of label definition inheriting from
@class{top}:

@example
#!vicare
(import (nausicaa))

(define-label <a-pair>
  (protocol (lambda () cons))
  (predicate pair?)
  (virtual-fields (immutable car car)
                  (immutable cdr cdr)))

(define @{O <a-pair>@}
  '(1 2))
(is-a? O <a-pair>)      @result{} #t
(is-a? O <top>)         @result{} #t

(O car)                 @result{} 1
(O cdr)                 @result{} 2
@end example

@noindent
the following is an example of label definitions inheriting from other
labels:

@example
#!vicare
(import (nausicaa))

(define-label <car>
  (virtual-fields (immutable car car)))

(define-label <car-and-cdr>
  (parent <car>)
  (virtual-fields (immutable cdr cdr)))

(define-label <a-pair>
  (parent <car-and-cdr>)
  (predicate pair?))

(define @{O <a-pair>@}
  '(1 . 2))

(is-a? O <a-pair>)      @result{} #t
(is-a? O <car-and-cdr>) @result{} #t
(is-a? O <car>)         @result{} #t
(is-a? O <top>)         @result{} #t

(O car)                 @result{} 1
(O cdr)                 @result{} 2
@end example

@noindent
the following is an example of label inheriting from a class:

@example
#!vicare
(import (nausicaa))

(define-class <alpha>
  (fields a b))

(define-label <beta>
  (parent <alpha>)
  (predicate <alpha>?)
  (protocol (lambda () make-<alpha>))
  (virtual-fields (immutable sum
                             (lambda/tags (@{O <beta>@})
                               (+ (O a) (O b))))))

(define @{O <beta>@}
  (<> (1 2)))

(is-a? O <beta>)        @result{} #t
(is-a? O <alpha>)       @result{} #t
(is-a? O <top>)         @result{} #t

(O a)                   @result{} 1
(O b)                   @result{} 2
(O sum)                 @result{} 3
@end example

@c page
@node oopp abstract
@section Abstract class types


@deffn {Auxiliary Syntax} abstract
Makes a class type non instantiable; it is meant to be used for class
definitions in which some methods are implemented as multimethods
(@pxref{multimethods}) and the subclasses are responsible to provide
implementations.  This clause is accepted in class and mixin
definitions.  This clause can be used only once.

It is a syntax violation to specify a public or common protocol in the
definition of an abstract class; only the super protocol is allowed.
@end deffn


Here is an example of abstract class:

@example
#!vicare
(import (nausicaa))

(define-class <alpha>
  (abstract)
  (fields a))

(define-class <beta>
  (parent <alpha>)
  (fields b))

(define @{O <beta>@}
  (<> (1 2))

(O a)           @result{} 1
(O b)           @result{} 2

(<alpha> (1))   @error{} &syntax
@end example

@noindent
another example with the @clause{super-protocol}:

@example
#!vicare
(import (nausicaa))

(define-class <alpha>
  (abstract)
  (super-protocol
    (lambda (make-top)
      (lambda (a)
        ((make-top) (number->string a)))))
  (fields a))

(define-class <beta>
  (parent <alpha>)
  (fields b))

(define @{O <beta>@}
  (<> (1 2)))

(O a)           @result{} "1"
(O b)           @result{} 2
@end example

@c page
@node oopp protocol
@section Defining constructor protocols


@menu
* oopp protocol classes::       Class construction protocols.
* oopp protocol labels::        Labeled values construction protocols.
@end menu

@c page
@node oopp protocol classes
@subsection Class construction protocols


Class types have explicitly defined construction protocols; the
semantics of protocol functions is @strong{the same} as the one defined
by @rnrs{6} for record protocols.  The following constructor functions
are made available by @func{define-class}:

@table @dfn
@item Public constructor
It is used when instantiating a class through the maker syntax.  The
public constructor of a class @class{B}, derived from class @class{A},
is built on top of the super constructor of @class{A}.  It is defined
with the @clause{public-protocol} clause.

@item Super constructor
It is used when instantiating a subclass, it is the function handed as
argument to the subclass' constructor protocol function.  The super
constructor of a class @class{B}, derived from class @class{A}, is built
on top of the super constructor of @class{A}.  It is defined with the
@func{super-protocol} clause.

@item Common constructor
When the public constructor is not explicitly defined: the common
constructor is used as public constructor.  When the super constructor
is not explicitly defined: the common constructor is used as super
constructor.  The common constructor of a class @class{B}, derived from
class @class{A}, is built on top of the super constructor of @class{A}.
It is defined with the @clause{protocol} clause.

When no common constructor is explicitly defined: it defaults to the
from--fields constructor.

@item From--fields constructor
It is always and automatically generated to be used by the macro
@func{make-from-fields} and it builds instances from raw field values.
The from--fields constructor of a class @class{B}, derived from class
@class{A}, is built on top of the from--fields constructor of @class{A}.

This constructor is equivalent to the default constructor generated by
@func{define-record-type} when no @clause{protocol} clause is used.
@end table


@deffn {Auxiliary Syntax} protocol @meta{expression}
Define the common constructor's protocol function.  @meta{expression}
must evaluate to the protocol function.
@end deffn


@deffn {Auxiliary Syntax} public-protocol @meta{expression}
Define the public constructor's protocol function.  @meta{expression}
must evaluate to the protocol function.
@end deffn


@deffn {Auxiliary Syntax} super-protocol @meta{expression}
Define the super constructor's protocol function.  @meta{expression}
must evaluate to the protocol function.
@end deffn

@c ------------------------------------------------------------

@subsubheading Examples of building class instances

Here is an example of default constructor usage; notice that no
@clause{protocol} syntax is used, so the constructors accept the raw
field values as arguments:

@example
#!vicare
(import (nausicaa))

(define-class <alpha>
  (fields a b))

(define-class <beta>
  (parent <alpha>)
  (fields c d))

(define @{A <alpha>@}
  (<> (1 2)))
(A a)                   @result{} 1
(A b)                   @result{} 2

(define @{B <beta>@}
  (<> (1 2 3 4)))
(B a)                   @result{} 1
(B b)                   @result{} 2
(B c)                   @result{} 3
(B d)                   @result{} 4
@end example

The following code makes use of explicitly defined common protocols
completely equivalent to the default ones:

@example
#!vicare
(import (nausicaa))

(define-class <alpha>
  (fields a b)
  (protocol (lambda (make-top)
              (lambda (a b)
                ((make-top) a b)))))

(define-class <beta>
  (parent <alpha>)
  (fields c d)
  (protocol (lambda (make-alpha)
              (lambda (a b c d)
                ((make-alpha a b) c d)))))

(define @{A <alpha>@}
  (<> (1 2)))
(A a)                   @result{} 1
(A b)                   @result{} 2

(define @{B <beta>@}
  (<> (1 2 3 4)))
(B a)                   @result{} 1
(B b)                   @result{} 2
(B c)                   @result{} 3
(B d)                   @result{} 4
@end example

The following code makes use of the @func{make-from-fields} syntax:

@example
#!vicare
(import (nausicaa))

(define-class <alpha>
  (fields a b))

(define-class <beta>
  (parent <alpha>)
  (fields c d))

(define @{A <alpha>@}
  (make-from-fields <alpha> 1 2))
(A a)                   @result{} 1
(A b)                   @result{} 2

(define @{B <beta>@}
  (make-from-fields <beta> 1 2 3 4))
(B a)                   @result{} 1
(B b)                   @result{} 2
(B c)                   @result{} 3
(B d)                   @result{} 4
@end example

The following code defines a common protocol accepting only some of the
fields' values:

@example
#!vicare
(import (nausicaa))

(define-class <alpha>
  (fields a b)
  (protocol (lambda (make-top)
              (lambda (a)
                ((make-top) a 2)))))

(define-class <beta>
  (parent <alpha>)
  (fields c d)
  (protocol (lambda (make-alpha)
              (lambda (a c)
                ((make-alpha a) c 4)))))

(define @{A <alpha>@}
  (<> (1)))
(A a)                   @result{} 1
(A b)                   @result{} 2

(define @{B <beta>@}
  (<> (1 3)))
(B a)                   @result{} 1
(B b)                   @result{} 2
(B c)                   @result{} 3
(B d)                   @result{} 4
@end example

The following code shows how to use the super and public protocols:

@example
#!vicare
(import (nausicaa))

(define-class <alpha>
  (fields a b)
  (public-protocol (lambda (make-top)
                     (lambda ()
                       ((make-top) 1 2))))
  (super-protocol  (lambda (make-top)
                     (lambda (a b)
                       ((make-top) (* 10 a) (* 10 b))))))

(define-class <beta>
  (parent <alpha>)
  (fields c d)
  (public-protocol (lambda (make-alpha)
                     (lambda (a b)
                       ((make-alpha a b) 3 4)))))

(define @{A <alpha>@}
  (<> ()))
(A a)                   @result{} 1
(A b)                   @result{} 2

(define @{B <beta>@}
  (<> (1 2)))
(B a)                   @result{} 10
(B b)                   @result{} 20
(B c)                   @result{} 3
(B d)                   @result{} 4
@end example

@c page
@node oopp protocol labels
@subsection Labeled values construction protocols


Labeled values have explicitly defined construction protocols; the
semantics of protocol functions is @strong{different} from the one
defined by @rnrs{6} for record protocols.  The following constructor
functions are built by @func{define-label}:

@table @dfn
@item Public constructor
It is used when building a labeled value through the maker syntax.  The
public constructor is a standalone function: it does @strong{not} invoke
the constructor of the superlabel or superclass.  It is defined with the
@clause{public-protocol} clause.

@item Common constructor
When the public constructor is not explicitly defined: the common
constructor is used as public constructor.  The common constructor is a
standalone function: it does @strong{not} invoke the constructor of the
superlabel or superclass.  It is defined with the @clause{protocol}
clause.

When no common constructor is explicitly defined: a default function is
created accepting any number of arguments and always raising an
@condition{assertion} exception.
@end table


Label protocol functions must accept no arguments and return a
constructor function.


@deffn {Auxiliary Syntax} protocol @meta{expression}
Define the common constructor's protocol function.  @meta{expression} is
evaluated only if the common protocol is used and it must evaluate to
the protocol function.
@end deffn


@deffn {Auxiliary Syntax} public-protocol @meta{expression}
Define the public constructor's protocol function.  @meta{expression}
must evaluate to the protocol function.
@end deffn

@c ------------------------------------------------------------

@subsubheading Examples of building labeled values

Here is an example of common protocol definition for a labeled value:

@example
#!vicare
(import (nausicaa))

(define-label <a-pair>
  (protocol (lambda () cons))
  (virtual-fields (immutable car car)
                  (immutable cdr cdr)))

(define @{P <a-pair>@}
  (<> (1 2)))
(P car)                 @result{} 1
(P cdr)                 @result{} 2
@end example

@c page
@node oopp maker
@section Defining custom makers


@deffn Syntax make-from-fields @meta{class} @meta{expression} ...
Build and return an instance of @meta{class} from raw field values; each
@meta{expression} is evaluated once and it must return a raw field
value.  The order of the @meta{expression} arguments must match the
order of the arguments to the from--fields constructor.  @ref{oopp
protocol classes, From--fields constructor}.

This macro @strong{cannot} be used to build labeled values.
@end deffn


@deffn {Auxiliary Syntax} maker @meta{expression}
Define the transformer function used by the maker syntax of classes and
labels.  @meta{expression} is evaluated once at expand time and it must
return a macro transformer function.

When the maker syntax of @meta{type}:

@example
(@meta{type} (@meta{arg} @dots{}))
@end example

@noindent
is expanded, the transformer is applied to a syntax object:

@example
#'(@meta{type} (@meta{arg} ...))
@end example

@noindent
and it must return a syntax object representing an expression that,
evaluated at run time, must return an instance of @meta{type} or raise
an exception.

Example:

@example
#!vicare
(import (nausicaa))

(define-auxiliary-syntaxes rec pol)

(define-class <rect-coords>
  (fields x y)
  (maker (lambda (stx)
           (syntax-case stx (rec pol)
             ((_ (pol ?rho ?theta))
              #'(let ((rho   ?rho)
                      (theta ?theta))
                  (make-<rect-coords> (* rho (cos theta))
                                      (* rho (sin theta)))))
             ((_ (rec ?x ?y))
              #'(make-<rect-coords> ?x ?y))))))

(define @{R <rect-coords>@}
  (<> (rec 1.0 2.0)))
(R x)                   @result{} 1.0
(R y)                   @result{} 2.0

(define @{Q <rect-coords>@}
  (<> (pol 1.0 2.0)))
(R x)                   @result{} -0.4161468365471424
(R y)                   @result{} +0.9092974268256817
@end example
@end deffn

@c page
@node oopp finaliser
@section Defining custom finalisers


@deffn {Auxiliary Syntax} finaliser @meta{expression}
Optional clause selecting a finaliser function for class instances;
@vicareref{iklib records final, Automatic finalisation of records}.
This clause can be used in the body of @func{define-class} and
@func{define-mixin}.

@meta{expression}, evaluated at run--time, must return a function
accepting a single argument; such function is used as second argument in
a call to @func{record-destructor-set!} setting a destructor function
for instances of the class type.
@end deffn

@c page
@node oopp predicate
@section Defining custom predicates


Predicate clauses allow the definition of custom predicates for labeled
values; they @strong{cannot} be used in the definition of class types.


@deffn {Auxiliary Syntax} predicate @meta{expression}
Define a custom predicate function or syntax to be used to identify
instances of labeled values with the predicate syntax or the
@func{is-a?} macro.  This clause can be used in the body of
@func{define-label} and @func{define-mixin}.

@meta{expression} is evaluated once and it must return a predicate
function.
@end deffn


Usage example:

@example
#!vicare
(import (nausicaa))

(define-label <a-pair>
  (predicate pair?)
  (virtual-fields (immutable car car)
                  (immutable cdr cdr)))

(is-a? '(1 . 2) <a-pair>)       @result{} #t
(is-a? 123      <a-pair>)       @result{} #f
@end example

Custom predicates of sublabels are composed with the custom predicates
of their superlabels, with the predicate of the superlabel applied
first; example:

@example
#!vicare
(import (nausicaa))

(define-label <a-list>
  (predicate list?)
  (virtual-fields (immutable car car)
                  (immutable cdr cdr)))

(define-label <list-of-numbers>
  (parent <a-list>)
  (predicate (lambda (ell)
               (for-all number? ell))))

(define L '(1 2 3))
(define M '(a b c))
(define N "abc")

(is-a? L <a-list>)           @result{} #t
(is-a? L <list-of-numbers>)  @result{} #t
(<a-list>? L)                @result{} #t
(<list-of-numbers>? L)       @result{} #t

(is-a? M <a-list>)           @result{} #t
(is-a? M <list-of-numbers>)  @result{} #f

(is-a? N <a-list>)           @result{} #f
(is-a? N <list-of-numbers>)  @result{} #f
@end example

@noindent
the predicate function of @class{list-of-numbers} is equivalent to:

@example
(define <list-of-numbers>-private-predicate
  (lambda (ell)
    (for-all number? ell)))

(define (<list-of-numbers>? obj)
  (and (list? obj)
       (<list-of-numbers>-private-predicate obj)))
@end example

@c page
@node oopp fields
@section Defining concrete and virtual fields


Concrete and virtual fields are defined by the @clause{fields} and
@clause{virtual-fields} clauses.  The clauses have the syntax:

@example
(fields         @meta{field-spec} ...)
(virtual-fields @meta{field-spec} ...)
@end example

@noindent
where @meta{field-spec} has one of the following syntaxes:

@example
(mutable   @meta{field})
(mutable   @meta{field} @meta{accessor} @meta{mutator})
(immutable @meta{field})
(immutable @meta{field} @meta{accessor})
@meta{field}
@end example

@noindent
where @meta{field} has one of the following syntaxes:

@example
@meta{field-name-id}
(brace @meta{field-name-id} @meta{type-tag-id})
@end example

@noindent
where: @meta{field-name-id} is an identifier representing the field
name, @meta{type-tag-id} is an identifier representing the field type
tag, @func{brace} is the identifier exported by @library{vicare} and
reexported by @library{nausicaa language oopp}.

The format of the @meta{field-spec} arguments is similar to the one
defined by @rnrs{6} in the syntactic records layer, extended with type
tags.  When @meta{accessor} and @meta{mutator} are @strong{not}
specified: a default identifier is built and registered in the enclosing
definition as specified by @rnrs{6} for record types, @vicareref{stdlib
records syntactic layer, fields}.

@clause{fields}, @clause{mutable} and @clause{immutable} are the
bindings exported by the library @rsixlibrary{records syntactic} and
reexported by the libraries @library{nausicaa language
auxiliary-syntaxes} and @library{nausicaa language oopp}.
@clause{virtual-fields} is a binding exported by library
@library{nausicaa language auxiliary-syntaxes} and reexported by
@library{nausicaa language oopp}.


@deffn {Auxiliary Syntax} fields @meta{field-spec} @dots{}
@deffnx {Auxiliary Syntax} mutable
@deffnx {Auxiliary Syntax} immutable
Add concrete fields to the enclosing class or mixin definition; labels
cannot have concrete fields.  This clause can be used multiple times in
the same type definition.

For concrete fields the accessor and mutator functions are automatically
generated, and we optionally have to select their names.  When
@meta{accessor} and @meta{mutator} are specified in a @clause{fields}
clause: they must be identifiers and they will be bound to the concrete
accessor and mutator functions.
@end deffn


@deffn {Auxiliary Syntax} virtual-fields @meta{field-spec} @dots{}
@deffnx {Auxiliary Syntax} mutable
@deffnx {Auxiliary Syntax} immutable
Add virtual fields to the enclosing class, label or mixin definition.
This clause can be used multiple times in the same type definition.

For virtual fields the accessor and mutator must be explicitly defined
as functions or syntaxes.

@itemize
@item
When @meta{accessor} and @meta{mutator} are
specified in a @clause{virtual-fields} clause they can be:

@itemize -
@item
Identifiers representing the names of the accessor and mutator.  It is
responsibility of the user code to bind such identifiers to functions or
syntaxes that can be used to access or mutate the fields.  The
identifiers are used as follows:

@example
(@meta{accessor} @meta{instance})
(@meta{mutator}  @meta{instance} @meta{new-value})
@end example

@item
Syntax objects representing expressions which, evaluated at run--time,
must return the accessor and mutator function.  In this case a default
identifier for the accessor and mutator is built and the expression
bound to it as in:

@example
(define @meta{default-accessor-id} @meta{accessor})
(define @meta{default-mutator-id}  @meta{mutator})
@end example
@end itemize

@item
When @meta{accessor} and @meta{mutator} are @strong{not} specified in a
@clause{virtual-fields} clause: a default identifier is built and
registered in the enclosing definition; it is responsibility of the user
code to bind such identifiers to functions or syntaxes that can be used
to access or mutate the fields.
@end itemize
@end deffn

@c ------------------------------------------------------------

@subsubheading Examples of concrete and virtual fields


The following is an example of class virtual fields usage in which the
accessor and mutator are defined as expressions inlined in the class
definition:

@example
#!vicare
(import (nausicaa)
  (vicare numerics constants))

(define-class <angle>
  (fields (mutable @{radians <real>@}))
  (virtual-fields
    (mutable @{degrees <real>@}
      (lambda (@{A <angle>@})
        (* (/ 180.0 greek-pi) (A radians)))
      (lambda (@{A <angle>@} @{deg <real>@})
        (set! (A radians) (* (/ greek-pi 180.0) deg))))
   ))

(define @{A <angle>@}
  (<> (greek-pi)))
(A radians)             @result{} greek-pi
(A degrees)             @result{} 180.0
(set! (A degrees) 90.0)
(A radians)             @result{} greek-pi/2
@end example

@noindent
here is the same definition with accessor and mutator defined as
functions and the default names:

@example
#!vicare
(import (nausicaa)
  (vicare numerics constants))

(define-class <angle>
  (fields (mutable @{radians <real>@}))
  (virtual-fields (mutable @{degrees <real>@})))

(define (<angle>-degrees @{A <angle>@})
  (* (/ 180.0 greek-pi) (A radians)))

(define (<angle>-degrees-set! @{A <angle>@} @{deg <real>@})
  (set! (A radians) (* (/ greek-pi 180.0) deg)))
@end example

@noindent
and here is again the same definition with accessor and mutator defined
as syntaxes:

@example
#!vicare
(import (nausicaa)
  (vicare numerics constants))

(define-class <angle>
  (fields (mutable @{radians <real>@}))
  (virtual-fields (mutable @{degrees <real>@})))

(define-inline (<angle>-degrees A)
  (let ((@{A <angle>@} A))
    (* (/ 180.0 greek-pi) (A radians))))

(define-inline (<angle>-degrees-set! A deg)
  (let ((@{A <angle>@}  A)
        (@{deg <real>@} deg))
    (set! (A radians) (* (/ greek-pi 180.0) deg))))
@end example

@c page
@node oopp method
@section Defining classes having methods


@menu
* oopp method methods::         The @clause{methods} clause.
* oopp method method::          The @clause{method} clause.
* oopp method method-syntax::   The @clause{method-syntax} clause.
* oopp method overloading::     Method overloading.
@end menu

@c page
@node oopp method methods
@subsection The @clause{methods} clause


@deffn {Auxiliary Syntax} methods @meta{method} @dots{}
Add methods to the enclosing class, label or mixin definition; the
methods are applicable only through a syntax use in @oopp{} notation.
This clause can be used multiple times.

The @meta{method} arguments can be of the form:

@example
@meta{method-name}
(@meta{method-name} @meta{invokable-name})
((brace @meta{method-name} @meta{rv-tag}) @meta{invokable-name})
@end example

@noindent
where @meta{method-name} and @meta{invokable-name} must be identifiers,
@func{brace} is the identifier exported by @library{vicare} and
reexported by @library{nausicaa language oopp}.

In the first two forms the invokable name is built in the same way the
field accessor names are built: appending a dash and @meta{method-name}
to the type name.  When @meta{rv-tag} is used: it must be the tag
identifier representing the type of a return value, the method is then
available for nested method invocation according to @oopp{} syntax
specifications.

@meta{invokable-name} must be an identifier bound to a Scheme function
or syntax which will be invoked as method; it must accept as first
argument the type instance which is the subject of the application.

Here is a usage example of the first form:

@example
#!vicare
(import (nausicaa))

(define-class <stuff>
  (fields a b)
  (methods sum))

(define (<stuff>-sum @{S <stuff>@})
  (+ (S a) (S b)))

(define @{S <stuff>@}
  (<> (1 2)))

(S sum)                 @result{} 3
@end example

@noindent
here is a usage example of the second form with a method function:

@example
#!vicare
(import (nausicaa))

(define-class <stuff>
  (fields a b)
  (methods (sum <stuff>-sum)))

(define (<stuff>-sum @{S <stuff>@})
  (+ (S a) (S b)))

(define @{S <stuff>@}
  (<> (1 2)))

(S sum)                 @result{} 3
@end example

@noindent
and here is a usage example of the second form with a method syntax:

@example
#!vicare
(import (nausicaa))

(define-class <stuff>
  (fields a b)
  (methods (sum <stuff>-sum)))

(define-syntax (<stuff>-sum stx)
  (syntax-case stx ()
    ((_ ?instance)
     #'(let ((@{S <stuff>@} ?instance))
         (+ (S a) (S b))))))

(define @{S <stuff>@}
  (<> (1 2)))

(S sum)                 @result{} 3
@end example

@noindent
here is a usage example of the third form with a method function; the
return value tag is in the @clause{methods} clause:

@example
#!vicare
(import (nausicaa))

(define-class <stuff>
  (fields @{a <exact-integer>@}
          @{b <exact-integer>@})
  (methods (@{sum <exact-integer>@} <stuff>-sum)))

(define (<stuff>-sum @{S <stuff>@})
  (+ (S a) (S b)))

(define @{S <stuff>@}
  (<> (1 2)))

(S sum)                 @result{} 3
((S sum) positive?)     @result{} #t
@end example

@noindent
here is a usage example of the third form with a method function; the
return value tag is in the method's function definition:

@example
#!vicare
(import (nausicaa))

(define-class <stuff>
  (fields @{a <exact-integer>@}
          @{b <exact-integer>@})
  (methods (sum <stuff>-sum)))

(define (@{<stuff>-sum <exact-integer>@} @{S <stuff>@})
  (+ (S a) (S b)))

(define @{S <stuff>@}
  (<> (1 2)))

(S sum)                 @result{} 3
((S sum) positive?)     @result{} #t
@end example
@end deffn

@c page
@node oopp method method
@subsection The @clause{method} clause


@deffn {Auxiliary Syntax} method (@meta{method} . @meta{formals}) . @meta{body}
@deffnx {Auxiliary Syntax} method @meta{method} @meta{expression}
Add a method to the enclosing class, label or mixin definition; the
method is applicable only through a syntax use in @oopp{} notation.
This clause can be used multiple times.

When the first form is used, the argument @meta{method} can have one of
the following formats:

@example
@meta{method-name}
(brace @meta{method-name} @metao{rv-tag} @meta{rv-tag} ...)
@end example

@noindent
when the second form is used, the argument @meta{method} can have one of
the following formats:

@example
@meta{method-name}
(brace @meta{method-name} @meta{rv-tag})
@end example

@noindent
where: @meta{method-name} must be an identifier representing the method
name; @meta{rv-tag} must be a tag identifier representing the type of a
return value; @func{brace} is the identifier exported by
@library{vicare} and reexported by @library{nausicaa language oopp}.

When a single return value tag is specified: the method is available for
nested method invocation according to @oopp{} syntax specifications.
When the first form is used: the return value tags are used to validate
the returned arguments as described for @func{lambda/tags}.

@itemize
@item
When the first form is used, the method definition is added to the
methods list as if the following clause had been used:

@example
(methods (@meta{method-name} function-name))
@end example

@noindent
the function definition is expanded to:

@example
(define function-name
  (lambda/tags (@{_ @metao{rv-tag} @meta{rv-tag} ...@} . @meta{formals})
    . @meta{body}))
@end example

@noindent
where @code{function-name} is an automatically generated identifier
built by appending a dash and @meta{method-name} to the type name.  The
first argument in @meta{formals} must be the type instance.

@item
When the second form is used, the method definition is added to the
methods list as if the following clause had been used:

@example
(methods (@meta{method-name} function-name))
@end example

@noindent
the function definition is expanded to:

@example
(define function-name @meta{expression})
@end example

@noindent
where @code{function-name} is an automatically generated identifier
built by appending a dash and @meta{method-name} to the type name; the
@meta{expression} must evaluate to a function accepting at least one
argument: the type instance.
@end itemize

Here is an example of the first form:

@example
#!vicare
(import (nausicaa))

(define-class <stuff>
  (fields a b)
  (method (sum @{S <stuff>@})
    (+ (S a) (S b))))

(<stuff> S (<> (1 2)))
(S sum)                 @result{} 3
@end example

@noindent
and an example of the second form:

@example
#!vicare
(import (nausicaa))

(define-class <stuff>
  (fields a b)
  (method sum
    (lambda/tags (@{S <stuff>@})
      (+ (S a) (S b)))))

(<stuff> S (<> (1 2)))
(S sum)                 @result{} 3
@end example
@end deffn

@c page
@node oopp method method-syntax
@subsection The @clause{method-syntax} clause


@deffn {Auxiliary Syntax} method-syntax @meta{method} @meta{transformer}
Add a method to the enclosing class, label or mixin definition; the
method is applicable only through a syntax use in @oopp{} notation.
This clause can be used multiple times.

The argument @meta{method} can have one of the following formats:

@example
@meta{method-name}
(brace @meta{method-name} @meta{rv-tag})
@end example

@noindent
where: @meta{method-name} must be an identifier representing the method
name; @meta{rv-tag} must be a tag identifier representing the type of
the single return value; @func{brace} is the identifier exported by
@library{vicare} and reexported by @library{nausicaa language oopp}.

When the single return value tag is specified: the method is available
for nested method invocation according to @oopp{} syntax specifications.
When the method returns multiple values: no type tag must be specified.

The method definition is added to the methods list as if the following
clause had been used:

@example
(methods (@meta{method-name} transformer-name))
@end example

@noindent
the macro definition is expanded to:

@example
(define-syntax transformer-name @meta{transformer})
@end example

@noindent
where @code{transformer-name} is an automatically generated identifier
built by appending a dash and @meta{method-name} to the type name.
@meta{transformer} must evaluate to a macro transformer: a function
accepting a syntax object as single argument and returning a syntax
object as single value.  The first argument to the macro will be the
type instance.

Here is an example of method syntax:

@example
#!vicare
(import (nausicaa))

(define-class <stuff>
  (fields a b)
  (method-syntax sum
    (lambda (stx)
      (syntax-case stx ()
        ((_ ?instance)
         #'(let ((@{S <stuff>@} ?instance))
             (+ (S a) (S b))))))))

(<stuff> S (<> (1 2)))
(S sum)                 @result{} 3
@end example
@end deffn

@c page
@node oopp method overloading
@subsection Method overloading


There is no support for methods overloading in the @library{nausicaa
language oopp} library, but we can do it using the facilities of the
@library{nausicaa language generics} library.  Example:

@example
#!vicare
(import (nausicaa))

(define-class <alpha>
  (fields a)
  (methods doit))

(define-generic <alpha>-doit @{o v@})

(define-method (<alpha>-doit @{o <alpha>@} @{v <char>@})
  (cons 'char v))

(define-method (<alpha>-doit @{o <alpha>@} @{v <integer>@})
  (cons 'int  v))

(define @{O <alpha>@}
  (<> (1)))

(O doit #\a)                    @result{} (char . #\a)
(O doit 2)                      @result{} (int . 2)
@end example

@c page
@node oopp getter
@section Getter syntaxes


@deffn {Auxiliary Syntax} getter @meta{transformer}
Add a getter syntax to instances of the enclosing class, label or mixin
definition; this clause can be used only once.

@meta{transformer} must be an expression evaluating to a syntax
transformer: a function accepting 2 arguments and returning a syntax
object as single value; the arguments are: a syntax object described
below, the tag identifier of the type for which the getter is invoked.

Whenever a tagged variable @meta{var} is used as follows (lookout for
the parentheses!):

@example
(@meta{var} (@metao{key} ...) (@meta{key} ...) ...)
@end example

@noindent
the getter transformer is applied to the syntax object:

@example
#'(@meta{var} ((@metao{key} ...) (@meta{key} ...) ...))
@end example

@noindent
and the return value of the transformer is the result of the expansion.
Notice that when using the keyword @keyword{oopp-syntax} to expand an
expression in @oopp{} syntax: @meta{var} can be any expression, not only
an identifier; @ref{oopp notation type expr, Applying @oopp{} syntax to
any expression}.

The tag argument is useful whenever we define a getter in a mixin: the
tag argument will be the type tag of the class or label in which the
mixin has been imported.

Getter definition examples:

@example
#!vicare
(import (nausicaa))

(define-label <vector>
  (getter (lambda (stx tag)
            (syntax-case stx ()
              ((?var ((?idx)))
               #'(vector-ref ?var ?idx))))))

(define-label <matrix>
  (getter (lambda (stx tag)
            (syntax-case stx ()
              ((?var ((?row) (?col)))
               #'(vector-ref
                    (vector-ref ?var ?row)
                    ?col))))))

(define @{V <vector>@}
  '#(1 2 3))

(define @{M <matrix>@}
  '#(#(1 2 3)
     #(4 5 6)))

(V[0])                  @result{} 1
(V[1])                  @result{} 2
(V[2])                  @result{} 3

(M[0][2])               @result{} 3
(M[1][1])               @result{} 5
@end example

Getter definition examples with nested syntax support:

@example
#!vicare
(import (nausicaa))

(define-label <fixnum-vector>
  (parent <vector>)
  (getter
   (lambda (stx tag)
     (syntax-case stx ()
       ((?expr ((?index)))
        #'(<fixnum> #:nested-oopp-syntax
                    (vector-ref ?expr ?index)))))))

(define @{O <fixnum-vector>@}
  '#(0 1 2 3))

((O[1]) string)         @result{} "1"
((O[1]) odd?)           @result{} #t
((O[2]) * 10)           @result{} 20
@end example
@end deffn

@c page
@node oopp setter
@section Setter syntaxes


@deffn {Auxiliary Syntax} setter @meta{transformer}
Add a setter syntax to instances of the enclosing class, label or mixin
definition; this clause can be used only once.

@meta{transformer} must be an expression evaluating to a syntax
transformer: a function accepting 2 arguments and returning a syntax
object as single value; the arguments are: a syntax object described
below, the tag identifier of the type for which the setter is invoked.

Whenever a tagged variable @meta{var} is used as follows (lookout for
the parentheses):

@example
(set!/tags (@meta{var} (@metao{key} ...) (@meta{key} ...) ...) @meta{expr})
(set!/tags @meta{var} (@metao{key} ...) (@meta{key} ...) ... @meta{expr})
@end example

@noindent
the setter transformer is applied to the syntax object (lookout for the
parentheses):

@example
#'(@meta{var} ((@metao{key} ...) (@meta{key} ...) ...) @meta{expr})
@end example

@noindent
and the return value of the transformer is the result of the expansion.

The tag argument is useful whenever we define a setter in a mixin: the
tag argument will be the type tag of the class or label in which the
mixin has been imported.

Setter definition examples:

@example
#!vicare
(import (nausicaa))

(define-label <vector>
  (setter (lambda (stx tag)
            (syntax-case stx ()
              ((?var ((?idx)) ?expr)
               #'(vector-set! ?var ?idx ?expr))))))

(define-label <matrix>
  (setter (lambda (stx tag)
            (syntax-case stx ()
              ((?var ((?row) (?col)) ?expr)
               #'(vector-set!
                    (vector-ref ?var ?row)
                    ?col ?expr))))))

;;We can mutate only dynamically built objects.
(define @{V <vector>@}
  (vector 1 2 3))

(define @{M <matrix>@}
  (vector (vector 1 2 3)
          (vector 4 5 6)))

(set! V[1] 77)
(set! (V[2]) 99)
V               @result{} #(1 77 99)

(set! M[0][2] 77)
(set! (M[1][1]) 99)
M               @result{} #(#(1 2 77) #(4 99 6))
@end example
@end deffn


@deffn Syntax set!/tags @meta{id} @meta{val}
@deffnx Syntax set!/tags (@meta{var} @meta{field-name}) @meta{val}
@deffnx Syntax set!/tags (@meta{var} (@metao{form} ...) (@meta{form} ...) ...) @meta{expr}
@deffnx Syntax set!/tags @meta{var} (@metao{form} ...) (@meta{form} ...) ... @meta{expr}
A syntax that generalises @func{set!} as defined by @rnrs{6} to support
@oopp{} notation.

@itemize
@item
In the first form, in which @meta{id} is an identifier and @meta{val}
and expression, it is equivalent to @func{set!} as defined by @rnrs{6}.

@item
In the second form, in which @meta{var} is a tagged variable or
expression, the mutator of the field @meta{field-name} is applied to the
given arguments as documented in the @oopp{} syntax definition,
@ref{oopp notation}.

@item
In the third and fourth forms, in which @meta{var} is a tagged variable
or expression, the setter transformer for @meta{var} is applied to the
form as documented in the @oopp{} syntax definition, @ref{oopp
notation}, and the setter clause.
@end itemize
@end deffn

@c page
@node oopp mixins
@section Composing with mixins


@dfn{Mixins} are a way to add definition clauses to classes and labels.
Let's consider this situation:

@example
#!vicare
(import (nausicaa))

(define-class <alpha>
  (fields a))

(define-class <beta>
  (fields b))

(define-class <delta>
  (parent <alpha>)
  (fields v)
  (method (doit @{o <delta>@})
    (+ 1 (o v))))

(define-class <gamma>
  (parent <beta>)
  (fields v)
  (method (doit @{o <gamma>@})
    (+ 1 (o v))))
@end example

@noindent
the definitions of @class{delta} and @class{gamma} share some clauses;
both of them already have a parent class and multiple inheritance is not
supported by @library{nausicaa language oopp}.  Is it possible to
write the shared clauses only once and attach them to the class
definitions?  Yes, with mixins.  The example above is equivalent to the
following:

@example
#!vicare
(import (nausicaa))

(define-class <alpha>
  (field a))

(define-class <beta>
  (field b))

(define-mixin <stuff>
  (field v)
  (method (doit @{o <stuff>@})
    (+ 1 (o v))))

(define-class <delta>
  (parent <alpha>)
  (mixins <stuff>))

(define-class <gamma>
  (parent <beta>)
  (mixins <stuff>))
@end example

@noindent
@func{define-mixin} associates a set of clauses to the identifier
@class{stuff}; when the @clause{mixins} clause is used in the body of a
class definition:

@enumerate
@item
The clauses associated to the selected identifier are retrieved as
syntax object.

@item
All the instances of the identifier @class{stuff} are substituted with
the identifier of the enclosing class or label, @class{delta} and
@class{gamma} in the example.

@item
The resulting clauses are added to the enclosing definition.
@end enumerate

@quotation
@strong{NOTE} When writing a library implementing mixins for Nausicaa:
we must enable the option @code{visit-upon-loading} in the options
clause of the @code{library} form; @vicareref{iklib syntaxes libraries,
Extended @code{library} syntax}.  Without this option the properties of
the type identifiers may not be defined properly.
@end quotation


@deffn {Auxiliary Syntax} mixins @meta{spec} @dots{}
Compose the enclosing class, label or mixin definition with the given
list of mixins.  This clause can be used multiple times.

Each @meta{spec} element must have one of the forms:

@example
@meta{mixin-name}
(@meta{mixin-name} (@meta{from} @meta{to}) ...)
@end example

@noindent
in which @meta{mixin-name} is the identifier referencing the mixin,
@meta{from} and @meta{to} are identifiers specifying the specialisation
for this mixin.  To specialise a mixin's clauses for the receiving
definition means the following:

@enumerate
@item
All the occurrences of @meta{mixin-name} are replaced with the receiving
definition's class, label or mixin name.

@item
All the occurrences of the @meta{from} identifiers are replaced with the
@meta{to} identifiers.
@end enumerate

It is a syntax violation if a mixin identifier name is not already
associated to a set of clauses at the time the receiving definition is
expanded; it is a syntax violation if the same @meta{mixin-name} is used
multiple times in the @clause{mixins} clauses of a definition.
@end deffn


@deffn Syntax define-mixin @meta{name} @metao{clause} @meta{clause} ...
Associate a set of mixin clauses to the identifier @meta{name}, which
can be later referenced by a @clause{mixins} clause in the body of a
class or label definition.

Right or wrong, @func{define-mixin} imposes no constraints on the given
clauses; it is our responsibility to select the ones which are
convenient for the application model.

The @clause{mixins} clause can be used in the body of a mixin
definition; the result is that the clauses of the selected mixins are
added to the definition of the current mixin.
@end deffn


The @clause{mixins} clause can be used any number of times, each of them
can list any number of mixin identifiers; the following clauses:

@example
(mixins <a> <b>)
(mixins <c> <d>)
(mixins <e> <f>)
@end example

@noindent
are equivalent to the single clause:

@example
(mixins <a> <b> <c> <d> <e> <f>)
@end example

@noindent
notice how the order is preserved from left to right and top to bottom.

Mixin clauses are added to the receiving definition in a deterministic
order: first the original clauses, then the mixin clauses in the same
order in which the mixin identifiers appear in the @clause{mixins}
clauses.  For example the following definitions:

@example
#!vicare
(import (nausicaa))

(define-mixin <alpha>
  (fields second))

(define-mixin <beta>
  (fields third))

(define-mixin <gamma>
  (fields fourth))

(define-class <red>
  (fields first)
  (mixins <alpha> <beta> <gamma>)
  (protocol
    (lambda (make-top)
      (lambda (first second third fourth)
        ((make-top) first second third fourth)))))
@end example

@noindent
are equivalent to the following single definition:

@example
#!vicare
(import (nausicaa))

(define-class <red>
  (fields first second third fourth)
  (protocol
    (lambda (make-top)
      (lambda (first second third fourth)
        ((make-top) first second third fourth)))))
@end example

@noindent
notice how the order of the @clause{fields} clauses matches the order of
the arguments to the constructor function.

@c page
@node oopp satisfy
@section Verifying definition constraints


@cindex Satisfaction functions for classes and labels
@cindex Satisfying constraints in classes and labels
@cindex Classes, satisfaction functions
@cindex Labels, satisfaction functions


It is useful to validate the definition of classes and labels against a
set of requirements; this allows, for example, to verify if a class
implements an @api{} (at least formally).


@deffn {Auxiliary Syntax} satisfies @meta{satisfaction} @dots{}
Add satisfaction constraints to the enclosing class, label or mixin
definition.  This clause can be used any number of times.

Each @meta{satisfaction} must be an identifier bound to a syntax; when
the enclosing definition is used to define a type: the syntax is applied
to the definition clauses and can do anything both at expand time and at
run time.
@end deffn


If the enclosing definition ends being @func{define-class}, the
following syntax, used as satisfaction, will be evaluated correctly:

@example
(define-syntax general-class-constraint
  (lambda (stx)
    (syntax-case stx (parent fields virtual-fields
                      mutable immutable
                      methods getter setter nongenerative
                      sealed opaque abstract)
      ((_ (?class-id ?constructor ?predicate ?record-type)
          (parent ?parent)
          (fields
           (mutable (?cm-field ?cm-tag) ?cm-accessor ?cm-mutator)
           ...)
          (fields
           (immutable (?ci-field ?ci-tag) ?ci-accessor #f)
           ...)
          (virtual-fields
           (mutable (?vm-field ?vm-tag) ?vm-accessor ?vm-mutator)
           ...)
          (virtual-fields
           (immutable (?vi-field ?vi-tag) ?vi-accessor #f)
           ...)
          (methods (?method-name . ?method-callable) ...)
          (getter ?getter)
          (setter ?setter)
          (nongenerative ?uid)
          (sealed ?sealed)
          (opaque ?opaque)
          (abstract ?abstract))
       #f))))
@end example

@noindent
if the enclosing definition ends being @func{define-label}, the
following syntax, used as satisfaction, will be evaluated correctly:

@example
(define-syntax general-label-constraint
  (lambda (stx)
    (syntax-case stx (parent virtual-fields mutable immutable
                      methods getter setter nongenerative
                      shadows)
      ((_ (?label-id ?constructor ?predicate)
          (parent ?parent)
          (virtual-fields
           (mutable   (?vm-field ?vm-tag) ?vm-accessor ?vm-mutator)
           ...)
          (virtual-fields
           (immutable (?vi-field ?vi-tag) ?vi-accessor #f)
           ...)
          (methods (?method-name . ?method-callable) ...)
          (getter ?getter)
          (setter ?setter)
          (nongenerative ?uid)
          (shadows ?shadows))
       #f))))
@end example

@noindent
in both cases when the getter and setter are not defined: @code{?getter}
and @code{?setter} are @false{}.

@c page
@node oopp shadow
@section Label shadowing


@deffn {Auxiliary Syntax} shadows @meta{identifier}
Select an identifier shadowed by a label.
@end deffn


@deffn Syntax with-label-shadowing (@meta{label} ...) . @meta{body}
Substitute every occurrence of @meta{label}, which must be a label type,
in @meta{body} with the corresponding shadowed identifer.
@end deffn


Below is an example of label shadowing a condition object type; it works
by redefining @func{define-condition-type} so that it creates both a
condition object type and a corresponding label:

@smallexample
#!vicare
(import (except (nausicaa)
                define-condition-type
                &warning)
  (prefix (only (rnrs)
                define-condition-type
                &warning)
          rnrs.))

(define-syntax (define-condition-type stx)
  (syntax-case stx ()
    ((_ ?type ?supertype ?constructor ?predicate (?field ?accessor) ...)
     #'(begin
         (with-label-shadowing (?supertype)
           (rnrs.define-condition-type the-type
             ?supertype ?constructor ?predicate
             (?field ?accessor) ...))
         (define-label ?type
           (shadows the-type)
           (maker (syntax-rules ()
                    ((_ (?arg (... ...)))
                     (?constructor ?arg (... ...)))))
           (predicate ?predicate)
           (virtual-fields (immutable ?field ?accessor) ...))))
    (_
     (synner "invalid syntax for condition type definition"))))

(define-label &warning
  (predicate warning?)
  (shadows rnrs.&warning))

(define-condition-type &warning-with-fields
  &warning make-warning-with-fields warning-with-fields?
  (a warning-with-fields-a)
  (b warning-with-fields-b))

(let ((E (&my-warning ())))
  (warning? E)                  @result{} #t
  ((&my-warning) E)             @result{} #t
  (is-a? E &my-warning))        @result{} #t

(let ((@{E &warning-with-fields@} (&warning-with-fields (1 2))))
  (warning-with-fields? E)              @result{} #t
  ((&warning-with-fields) E)            @result{} #t
  (is-a? E &warning-with-fields)        @result{} #t
  (warning? E)                          @result{} #t
  (warning-with-fields-a E)             @result{} 1
  (warning-with-fields-b E)             @result{} 2
  (E a)                                 @result{} 1
  (E b))                                @result{} 2
@end smallexample

@noindent
we see that the type name we give to the redefined
@func{define-condition-type} is actually the label type, while the
condition type gets an automatically generated identifier name which is
shadowed by the label.

Such mechanism allows us to use @oopp{} notation to access the fields of
a condition object and also to extend condition object types with
sublabels.

@c page
@node oopp is-a
@section Testing a value's type


@deffn Syntax is-a? @meta{expression} @meta{tag}
@deffnx Syntax is-a? <> @meta{tag}
@deffnx {Auxiliary Syntax} <>
In the first form: expand to the application of the class predicate of
@meta{tag}, a class or label type, to the result of evaluating
@meta{expression}, which can be any expression and is evaluated only
once.  In the second form: returns the predicate function of @meta{tag}.

For example, given:

@example
(define-class <alpha>
  (fields a b c))
@end example

@noindent
the following statement:

@example
(is-a? x <alpha>)
@end example

@noindent
is equivalent to:

@example
(<alpha>? x)
@end example

Another example, the following two forms are equivalent:

@example
(is-a? x <list>)
((is-a? <> <list>) x)
@end example

@noindent
this is especially useful when using @func{map} or @func{for-all}:

@example
(for-all (is-a? <> <list>) obj)
@end example

The @code{<>} auxiliary syntax is exported by the library
@library{nausicaa language auxiliary-syntaxes} and reexported by
@library{nausicaa language oopp}.
@end deffn

@c page
@node oopp slots
@section Accessors and mutators


The following syntaxes provide a way to access concrete and virtual
fields of class instances and labeled values; they also allow the
extraction of accessor and mutator functions.


@deffn Syntax slot-ref @meta{expr} @meta{field-name} @meta{tag}
@deffnx {Auxiliary Syntax} <>
Expand to the slot accessor of @meta{field-name} applied to @meta{expr},
which can be any expression evaluating to an instance of @meta{tag}, a
class or label type.  @meta{field-name} can be either the name of a
concrete field or the name of a virtual field.

When the auxiliary syntax @code{<>} is used in place of @meta{expr}: the
macro expands to the accessor function itself; the following forms are
equivalent:

@example
(slot-ref o car <pair>)
((slot-ref <> car <pair>) o)
@end example

@noindent
this is useful whenever the accessor has to be used as function
argument, for example for @func{map} or @func{for-all}.  The @code{<>}
auxiliary syntax is exported by the library @library{nausicaa language
auxiliary-syntaxes} and reexported by @library{nausicaa language
oopp}.
@end deffn


@deffn Syntax slot-set! @meta{obj-expr} @meta{field-name} @meta{tag} @meta{val-expr}
@deffnx {Auxiliary Syntax} <>
Expand to the slot mutator of @meta{field-name} applied to
@meta{obj-expr} and @meta{val-expr}.  @meta{obj-expr} can be any
expression evaluating to an instance of @meta{tag}, a class or label
type; @meta{val-expr} can be any expression evaluating to the new field
value.  @meta{field-name} can be either the name of a concrete field or
the name of a virtual field.

When the auxiliary syntax @code{<>} is used in place of @strong{both}
@meta{obj-expr} and @meta{val-expr}: the macro expands to the mutator
function itself; the following forms are equivalent:

@example
(slot-set! o car <pair> 1)
((slot-set! <> car <pair> <>) o 1)
@end example

@noindent
this is useful whenever the mutator has to be used as function argument.
The @code{<>} auxiliary syntax is exported by the library
@library{nausicaa language auxiliary-syntaxes} and reexported by
@library{nausicaa language oopp}.
@end deffn

@c page
@node oopp inspect
@section Tags and objects inspection


@deffn Syntax tag-unique-identifiers @meta{tag}
Return the list of @uid{}s in the class hierarchy of @meta{tag}.

@example
(tag-unique-identifiers <top>)
@result{} (nausicaa:builtin:<top>)

(tag-unique-identifiers <pair>)
@result{} (nausicaa:builtin:<pair>
    nausicaa:builtin:<top>)

(tag-unique-identifiers <textual-port>)
@result{} (nausicaa:builtin:<textual-port>
    nausicaa:builtin:<port>
    nausicaa:builtin:<top>)
@end example
@end deffn

@c page
@node oopp bindings
@section Defining bindings in @oopp{} notation


The syntaxes described in this section allow the use of @oopp{} notation
to access tag fields and to apply tag methods.

@menu
* oopp bindings overview::      Introduction to @oopp{} bindings.
* oopp bindings let::           @oopp{} bindings: @func{let}--like syntaxes.
* oopp bindings begin::         @oopp{} bindings: @func{begin}--like syntaxes.
* oopp bindings lambda::        @oopp{} bindings: @func{lambda}--like syntaxes.
* oopp bindings define::        @oopp{} bindings: @func{define}--like syntaxes.
* oopp bindings do::            @oopp{} bindings: @func{do}--like syntaxes.
@end menu

@c page
@node oopp bindings overview
@subsection Introduction to @oopp{} bindings


@oopp{} notation is available only for the members of tags defined by
@func{define-class} and @func{define-label}, it cannot be used with
types defined by @func{define-record-type}.

The binding syntaxes exported by @library{nausicaa language oopp}
match the @rnrs{6} ones exported by @rsixlibrary{base} and
@rsixlibrary{control} and some Vicare--specific ones exported by
@library{vicare}.

Whenever in the original syntaxes a @meta{variable} identifier appears,
in the @oopp{} syntaxes a @meta{tagged-variable} form appears;
a use of @meta{tagged-variable} must have one of the formats:

@example
@meta{variable}
(brace @meta{variable} @meta{tag})
@end example

@noindent
where: @meta{variable} is an identifier representing the binding name,
@meta{tag} is an identifier representing a class or label type,
@func{brace} is the identifier exported by @library{vicare} and
reexported by @library{nausicaa language oopp}.

@quotation
@strong{NOTE} When the reader is in @code{#!vicare} mode: braces can be
used to build a @func{brace} syntax, @vicareref{iklib reader mode,
Textual input port modes}.  So the following syntax is possible for
@meta{tagged-variable}:

@example
@{@meta{variable} @meta{tag}@}
@end example
@end quotation

Whenever in the original syntaxes a @meta{bindings} form appears, in the
@oopp{} syntaxes a @meta{tagged-bindings} form appears; a use of
@meta{tagged-bindings} must have the format:

@example
((@meta{tagged-variable} @meta{init}) ...)
@end example

Whenever in the original syntaxes a @meta{mv-bindings} form appears, in
the @oopp{} syntaxes a @meta{tagged-mv-bindings} form appears; a use of
@meta{tagged-mv-bindings} must have the format:

@example
((@meta{tagged-formals} @meta{init}) ...)
@end example

Whenever in the original syntaxes a @meta{formals} form appears, in the
@oopp{} syntaxes a @meta{tagged-formals} form appears; a use of
@meta{tagged-formals} must have one of the formats:

@example
@meta{tagged-variable}
(@meta{tagged-variable} ...)
(@metao{tagged-variable} @meta{tagged-variable} ... . @metan{tagged-variable})
@end example

@c page
@node oopp bindings let
@subsection @oopp{} bindings: @func{let}--like syntaxes


@deffn Syntax with-tags (@meta{tagged-variable} @dots{}) @metao{body} @meta{body} @dots{}
The @func{with-tags} syntax is the basic tool to provide @oopp{}
notation for objects use.  Expand into a @func{let-syntax} form which
defines @oopp{} notation syntaxes for already existent bindings; the
names of the new bindings are equal to the names of the already existent
bindings.

Usage example:

@example
#!vicare
(import (rnrs)
  (nausicaa language oopp))

(define-class <alpha>
  (fields a b))

(define A (<alpha> (1 2)))

(with-tags (@{A <alpha>@})
  (A a))
@result{} 1
@end example
@end deffn


@deffn Syntax let/tags @meta{tagged-bindings} @metao{body} @meta{body} @dots{}
@deffnx Syntax let/tags @meta{name} @meta{tagged-bindings} @metao{body} @meta{body} @dots{}
Like @func{let} (both named and unnamed) and defines the @oopp{}
bindings.  When all the bindings have no tags: this syntax is equivalent
to @func{let} as defined by @rnrs{6}; an untagged binding is equivalent
to a binding tagged with @class{top}.

Usage example:

@example
#!vicare
(import (rnrs)
  (nausicaa language oopp))

(let/tags ((@{a <list>@} '(1 2 3))
           (@{b <pair>@} '(a . b)))
  (a car)               @result{} 1
  (b car))              @result{} a
@end example
@end deffn


@deffn Syntax let*/tags @meta{tagged-bindings} @metao{body} @meta{body} @dots{}
Like @func{let*} and defines the @oopp{} bindings.  When all the
bindings have no tags: this syntax is equivalent to @func{let*} as
defined by @rnrs{6}; an untagged binding is equivalent to a binding
tagged with @class{top}.

Usage example:

@example
#!vicare
(import (rnrs)
  (nausicaa language oopp))

(let*/tags ((@{a <number>@} 123)
            (@{b <string>@} (a string)))
  b)                    @result{} "123"
@end example
@end deffn


@deffn Syntax letrec/tags @meta{tagged-bindings} @metao{body} @meta{body} @dots{}
Like @func{letrec} and defines the @oopp{} bindings.  When all the
bindings have no tags: this syntax is equivalent to @func{letrec} as
defined by @rnrs{6}; an untagged binding is equivalent to a binding
tagged with @class{top}.
@end deffn


@deffn Syntax letrec*/tags @meta{tagged-bindings} @metao{body} @meta{body} @dots{}
Like @func{letrec*} and defines the @oopp{} bindings.  When all the
bindings have no tags: this syntax is equivalent to @func{letrec*} as
defined by @rnrs{6}; an untagged binding is equivalent to a binding
tagged with @class{top}.

The only difference between @func{letrec/tags} and @func{letrec*/tags}
is that the latter enforces the order of evaluation of the @meta{init}
expressions.
@end deffn


@deffn Syntax let-values/tags @meta{tagged-mv-bindings} @metao{body} @meta{body} @dots{}
Like @func{let-values} and defines the @oopp{} bindings.  When all the
bindings have no tags: this syntax is equivalent to @func{let-values} as
defined by @rnrs{6}; an untagged binding is equivalent to a binding
tagged with @class{top}.
@end deffn


@deffn Syntax let*-values/tags @meta{tagged-mv-bindings} @metao{body} @meta{body} @dots{}
Like @func{let*-values} and defines the @oopp{} bindings.  When all the
bindings have no tags: this syntax is equivalent to @func{let*-values}
as defined by @rnrs{6}; an untagged binding is equivalent to a binding
tagged with @class{top}.
@end deffn


@deffn Syntax receive/tags @meta{tagged-formals} @meta{init} @metao{body} @meta{body} @dots{}
Like @func{receive}, as defined by @library{vicare}, and defines the
@oopp{} bindings.  When all the bindings have no tags: this syntax is
equivalent to @func{receive} as defined by @library{vicare}; an untagged
binding is equivalent to a binding tagged with @class{top}.

Usage example:

@example
#!vicare
(import (rnrs)
  (nausicaa language oopp))

(receive/tags (@{a <number>@} @{b <number>@})
    (values 1 2)
  (a string)            @result{} "1"
  (b string))           @result{} "2"
@end example
@end deffn


@deffn Syntax receive-and-return/tags @meta{tagged-formals} @meta{init} @metao{body} @meta{body} @dots{}
Like @func{receive-and-return}, as defined by @library{vicare}, and
defines the @oopp{} bindings.  When all the bindings have no tags: this
syntax is equivalent to @func{receive-and-return} as defined by
@library{vicare}; an untagged binding is equivalent to a binding tagged
with @class{top}.

Usage example:

@example
#!r6rs
(import (rnrs)
  (nausicaa language oopp))

(receive-and-return/tags (@{a <number>@} @{b <number>@})
    (values 1 2)
  (a string)            @result{} "1"
  (b string))           @result{} "2"
@result{} 1, 2 ;;two values
@end example
@end deffn

@c page
@node oopp bindings begin
@subsection @oopp{} bindings: @func{begin}--like syntaxes


@deffn Syntax begin/tags @metao{body} @meta{body} @dots{}
@deffnx Syntax begin/tags (<- @meta{tag} ...) @metao{body} @meta{body} @dots{}
@deffnx {Auxiliary Syntax} <-
When the auxiliary syntax @func{<-} is not used: @func{begin/tags}
behaves like @func{begin} from @library{rnrs (6)}.  When the auxiliary
syntax @func{<-} is used: it specifies one tag for each value returned
by the last @meta{body} form; such tag is used to validate the
corresponding return value with the tag's predicate.
@end deffn

@c page
@node oopp bindings lambda
@subsection @oopp{} bindings: @func{lambda}--like syntaxes


@deffn Syntax lambda/tags @meta{tagged-formals} @metao{body} @meta{body} @dots{}
Like @func{lambda} and defines the @oopp{} bindings for the arguments.
When all the bindings have no tags: this syntax is equivalent to
@func{lambda} as defined by @rnrs{6}; an untagged binding is equivalent
to a binding tagged with @class{top}.

If procedure arguments validation, as defined by @library{vicare
arguments validation}, is enabled:

@itemize
@item
The function will validate its tagged arguments using the tag predicates
and raise a @condition{procedure-argument-violation} exception in case
of failure.

@item
If the first element of @meta{tagged-formals} has the format:

@example
@{_ @metao{tag} @meta{tag} ...@}
@end example

@noindent
where @code{_} is the binding exported by the library @rsixlibrary{base}
and reexported by the library @library{nausicaa language oopp}: the
@meta{body} forms will be enclosed in a @func{begin/tags} syntax, and
the returned values validated as specified by the @meta{tag}
identifiers.
@end itemize

Usage examples:

@itemize
@item
Function with two tagged arguments:

@example
#!vicare
(import (rnrs)
  (nausicaa language oopp))

(define f
  (lambda/tags (@{a <number>@} @{b <number>@})
    (list (a string) (b string))))

(f 1 2)                 @result{} ("1" "2")
@end example

@item
Function with two mandatory arguments and the rest argument:

@example
#!vicare
(import (rnrs)
  (nausicaa language oopp))

(define g
  (lambda/tags (@{a <number>@} @{b <number>@} . @{args <list>@})
    (list (a string)
          (b string)
          (args length))))

(g 1 2 3 4 5)           @result{} ("1" "2" 3)
@end example

@item
Function with only the rest argument:

@example
#!vicare
(import (rnrs)
  (nausicaa language oopp))

(define g
  (lambda/tags @{args <list>@}
    (args length)))

(g 1 2 3)               @result{} 3
@end example

@item
Functions with a single validated return value:

@example
#!vicare
(import (rnrs)
  (nausicaa language oopp))

(define f
  (lambda/tags (@{_ <fixnum>@} val)
    val))

(f 1)                   @result{} 1
@end example

@item
Functions with multiple validated return values:

@example
#!vicare
(import (rnrs)
  (nausicaa language oopp))

(define f
  (lambda/tags (@{_ <fixnum> <string>@} a b)
    (values a b)))

(f 1 "2")               @result{} 1, "2"
@end example
@end itemize
@end deffn


@deffn Syntax case-lambda/tags @meta{cl-clause} @dots{}
Like @func{case-lambda} and defines the @oopp{} bindings for the
arguments.  When all the bindings have no tags: this syntax is
equivalent to @func{case-lambda} as defined by @rnrs{6}; an untagged
binding is equivalent to a binding tagged with @class{top}.

Each @meta{cl-clause} must have the format:

@example
(@meta{tagged-formals} @metao{body} @meta{body} @dots{})
@end example

If procedure arguments validation, as defined by @library{vicare
arguments validation}, is enabled:

@itemize
@item
The function will validate its tagged arguments using the tag predicates
and raise a @condition{procedure-argument-violation} exception in case
of failure.

@item
If the first element of @meta{tagged-formals} has the format:

@example
@{_ @metao{tag} @meta{tag} ...@}
@end example

@noindent
where @code{_} is the binding exported by the library @rsixlibrary{base}
and reexported by the library @library{nausicaa language oopp}: the
@meta{body} forms will be enclosed in a @func{begin/tags} syntax, and
the returned values validated as specified by the @meta{tag}
identifiers.
@end itemize

Usage examples:

@example
#!vicare
(import (rnrs)
  (nausicaa language oopp))

(define f
  (case-lambda/tags
   ((@{a <number>@})
    (a string))))

(define g
  (case-lambda/tags
   (@{args <list>@}
    (args length))))

(f 123)                 @result{} "123"
(g 1 2 3)               @result{} 3
@end example
@end deffn

@c page
@node oopp bindings define
@subsection @oopp{} bindings: @func{define}--like syntaxes


@deffn Syntax define/tags @meta{variable}
@deffnx Syntax define/tags @meta{variable} @meta{expression}
@deffnx Syntax define/tags @{@meta{variable} @meta{tag}@}
@deffnx Syntax define/tags @{@meta{variable} @meta{tag}@} @meta{expression}
@deffnx Syntax define/tags (@meta{variable} . @meta{tagged-formals}) @metao{body} @meta{body} @dots{}
@deffnx Syntax define/tags (@{@meta{variable} @metao{tag} @meta{tag} @dots{}@} . @meta{tagged-formals}) @metao{body} @meta{body} @dots{}
Like @func{define} and defines the @oopp{} bindings for function
arguments.  When all the bindings have no tags: this syntax is almost
equivalent to @func{define} as defined by @rnrs{6}; an untagged binding
is equivalent to a binding tagged with @class{top}.

@cindex @code{__who__}
When the syntax is used for function definition: the fluid identifier
syntax @code{__who__} is bound to the quoted function name.  This is
useful when raising exceptions with condition type @condition{who}.

When the syntax is used for function definition and procedure arguments
validation, as defined by @library{vicare arguments validation}, is
enabled:

@itemize
@item
The function will validate its tagged arguments using the tag predicates
and raise a @condition{procedure-argument-violation} exception in case
of failure.

@item
If the @meta{variable} argument comes with @meta{tag} arguments: the
@meta{body} forms will be enclosed in a @func{begin/tags} syntax, and
the returned values validated as specified by the @meta{tag}
identifiers.
@end itemize

Usage examples:

@itemize
@item
Function with two tagged arguments:

@example
#!vicare
(import (rnrs)
  (nausicaa language oopp))

(define/tags (f @{a <number>@} @{b <number>@})
  (list (a string) (b string)))

(f 1 2)                 @result{} ("1" "2")
@end example

@item
Function with two mandatory arguments and the rest argument:

@example
#!vicare
(import (rnrs)
  (nausicaa language oopp))

(define/tags (g @{a <number>@} @{b <number>@} . @{args <list>@})
  (list (a string)
        (b string)
        (args length)))

(g 1 2 3 4 5)           @result{} ("1" "2" 3)
@end example

@item
Function with only the rest argument:

@example
#!vicare
(import (rnrs)
  (nausicaa language oopp))

(define/tags (g . @{args <list>@})
  (args length))

(g 1 2 3)               @result{} 3
@end example

@item
Tagged variable definition:

@example
#!vicare
(import (rnrs)
  (nausicaa language oopp))

(define/tags @{a <number>@} 123)

(a string)              @result{} "123"
@end example

@item
Tagged variable definition initially left uninitialised:

@example
#!vicare
(import (rnrs)
  (nausicaa language oopp))

(define/tags @{a <number>@})
(set! a 123)
(a string)              @result{} "123"
@end example
@end itemize
@end deffn

@c ------------------------------------------------------------

@deffn Syntax case-define/tags @meta{who} @meta{cl-clause} @dots{}
Like @func{case-define} and defines the @oopp{} bindings for the
arguments.  It expands as follows:

@example
(case-define/tags @meta{who}
  @meta{cl-clause} ...)
@expansion{} (define @meta{who}
      (fluid-let-syntax
          ((__who__ (identifier-syntax (quote @meta{who}))))
        (case-lambda/tags @meta{cl-clause} ...)))
@end example

@noindent
so the fluid syntax @code{__who__} is available as argument for
@condition{who} condition objects.
@end deffn

@c ------------------------------------------------------------

@deffn Syntax define-values/tags (@metao{tagged-variable} @meta{tagged-variable} @dots{}) @metao{form} @meta{form} @dots{}
Like @func{define-values} from @library{vicare} and defines the @oopp{}
bindings for function arguments.  When all the bindings have no tags:
this syntax is equivalent to @func{define-values} from @library{vicare};
an untagged binding is equivalent to a binding tagged with @class{top}.

Evaluate the given forms and bind the, possibly multiple, result of the
last one to the given @meta{tagged-variables}.

@example
#!vicare
(import (rnrs)
  (nausicaa language oopp))

(define-values (a b c)
  (values 1 2 3))

(define-values (@{A <integer>@} @{B <string>@} @{C <pair>@})
  (values 123 "ciao" '(1 . 2)))

(list a b c)    @result{} (1 2 3)

(A odd?)        @result{} #t
(B length)      @result{} 4
(C cdr)         @result{} 2
@end example
@end deffn

@c page
@node oopp bindings do
@subsection @oopp{} bindings: @func{do}--like syntaxes


@deffn Syntax do/tags ((@meta{tagged-variable} @meta{init} @meta{step}) @dots{}) (@meta{test} @meta{expression} @dots{}) @meta{command} @dots{}
Like @func{do} and defines the @oopp{} bindings for the arguments.  When
all the bindings have no tags: this syntax is equivalent to @func{do} as
defined by @rnrs{6}; an untagged binding is equivalent to a binding
tagged with @class{top}.  The @meta{step}, @meta{expression} and
@meta{command} expressions can use @oopp{} notation when accessing the
bindings.
@end deffn


@deffn Syntax do*/tags ((@meta{tagged-variable} @meta{init} @meta{step}) @dots{}) (@meta{test} @meta{expression} @dots{}) @meta{command} @dots{}
Like @func{do} and defines the @oopp{} bindings for the arguments; in
addition the bindings are created in a @func{let*} style.  When all the
bindings have no tags: this syntax is equivalent to @func{do} as defined
by @rnrs{6}; an untagged binding is equivalent to a binding tagged with
@class{top}.  The @meta{step}, @meta{expression} and @meta{command}
expressions can use @oopp{} notation when accessing the binding.
@end deffn

@c page
@node oopp misc
@section Miscellaneous syntaxes


@deffn Macro tag-case @meta{expr} ((@metao{tag} @meta{tag} @dots{}) @metao{tag-body} @meta{tag-body} @dots{}) @dots{}
@deffnx Macro tag-case @meta{expr} ((@metao{tag} @meta{tag} @dots{}) @metao{tag-body} @meta{tag-body} @dots{}) @dots{} (else @metao{else-body} @meta{else-body} @dots{})
@deffnx {Auxiliary Syntax} else
Syntax similar to @func{case}.  @func{else} must be the binding exported
by @library{rnrs} and @library{vicare}.

@meta{expr} must be an expression and it is evaluated once; its result
is tested with the predicates of the specified tags and the body of the
selected branch is evaluated.

@example
(tag-case 123
  ((<string> <vector>)
   #f)
  ((<fixnum>)
   #t))
@result{} #t

(tag-case 1.2
  ((<string> <vector>)
   #f)
  ((<fixnum>)
   #f)
  (else #t))
@result{} #t
@end example
@end deffn

@c end of file
